settings
{
	lobby
	{
		Max Team 1 Players: 3
		Max Team 2 Players: 2
	}

	modes
	{
		Elimination
		{
			Hero Selection: Limited
			Score To Win: 5

			enabled maps
			{
			}
		}

		Skirmish
		{
			enabled maps
			{
				Workshop Expanse 0
			}
		}

		General
		{
			Hero Limit: Off
		}
	}

	heroes
	{
		Team 1
		{
			Ultimate Generation - Combat: 0%
			Ultimate Generation - Passive: 380%
			
			Cassidy
			{
				Ultimate Generation - Passive Deadeye: 260%
			}
			
			Hanzo
			{
				Ultimate Generation - Passive Dragonstrike: 240%
			}
			
			Sigma
			{
				Ultimate Generation - Passive Gravitic Flux: 300%
			}

			Sombra
			{
				Ultimate Generation - Passive EMP: 220%
			}
			
			disabled heroes
			{
				D.Va
			}
		}

		Team 2
		{
			Orisa
			{
				Projectile Speed: 60%
				Ultimate Ability Terra Surge: Off
			}

			Reinhardt
			{
				Barrier Field: Off
				Charge: Off
				Fire Strike: Off
				Ultimate Generation - Combat Earthshatter: 0%
				Ultimate Generation - Passive Earthshatter: 0%
			}

			Tracer
			{
				Blink: Off
				No Ammunition Requirement: On
				Projectile Gravity: 0%
				Projectile Speed: 70%
				Quick Melee: Off
				Recall: Off
				Ultimate Generation - Passive Pulse Bomb: 500%
				Ultimate Generation Pulse Bomb: 200%
			}

			Wrecking Ball
			{
				Adaptive Shield: Off
				Grappling Claw: Off
				Piledriver: Off
				Quick Melee: Off
				Ultimate Ability Minefield: Off
			}

			Zenyatta
			{
				Orb of Discord: Off
				Orb of Harmony: Off
				Primary Fire: Off
				Projectile Speed: 25%
				Quick Melee: Off
				Ultimate Ability Transcendence: Off
			}

			enabled heroes
			{
				Reinhardt
			}
		}
	}

	workshop
	{
		Difficulty: 3
		Enable Dialogue: On
		Music Mode: [1]
		Player Level: 23
		Test Mode: On
	}

	extensions
	{
		Beam Effects
		Beam Sounds
		Buff Status Effects
		Debuff Status Effects
		Buff and Debuff Sounds
		Energy Explosion Effects
		Kinetic Explosion Effects
		Explosion Sounds
		Play More Effects
		Spawn More Dummy Bots
	}
}

variables
{
	global:
		0: State
		1: Phase
		2: Heroes
		3: Bosses
		4: TestMode
		5: DeathLineRadius
		6: OverallBossLevel
		7: OverallPlayerLevel
		8: PlayerCount
		9: PlayerFactor
		10: Difficulty
		11: TimeFactor
		12: StagesCompleted
		14: BossCount
		15: Items
		16: ItemSymbols
		17: ItemRarities
		18: ItemColours
		19: ItemDistributionQueue
		20: ItemDistributionInfo
		21: ItemStacks
		22: ItemStackOwners
		23: ItemStackNewOwners
		24: ItemStackOriginalOwners
		25: ItemStackSizes
		26: ItemStackIndex
		27: NewItemStackIndex
		28: ItemStackHUDs
		29: ItemStackEffects
		30: ItemStackUpdateInfos
		31: ItemStackUpdateInfo
		32: ExistingMatchingItemStacks
		33: CurrentItemStackSize
		34: ItemShops
		35: ItemShopPositions
		36: ItemShopPrices
		37: ItemShopEffects1
		38: ItemShopEffects2
		39: ItemShopIndex
		40: Stealees
		41: BossIndex
		42: CurrentStealee
		43: StealeeIndex
		44: Stealer
		45: ItemStackBeingStolenIndex
		46: BossSpawnEffect
		47: FlamePillars
		48: FlamePillarPositions
		49: FlamePillarExpirationTimes
		50: OrbCreationTimes
		51: OrbEffects
		52: OrbInitialAngles
		53: OrbPositions
		54: OrbCreators
		55: OrbEvaluationIndex
		56: OrbVictims
		57: OrbInitialPositions
		58: OrbSounds
		59: BotCreationQueue
		60: AvailableBotSlots
		61: TracerNames
		62: ZenyattaNames
		63: BallNames
		64: ArenaRadius
		65: StrikeVictims
		66: LightningStrikes
		67: NullPlayer
		68: ItemShopRadii
		69: ShopIndex
		70: ItemShopRarities
		71: Director
		72: AiIndex
		73: Adds
		74: Add
		75: Dialogue
		76: UsedDialogue
		77: EarlyHeroDeathDialogue
		78: LateHeroDeathDialogue
		79: BossDeathDialogue
		80: DamageBeamInstances
		81: DamageBeamIndex
		82: DamageBeamInfo
		83: Buttons
		84: AllHeroes
		85: ProcCoefs
		86: ChainLightningBans
		87: MusicMode
		88: ItemDescriptions
		89: ItemShopDescriptions
		90: Numbers
		91: ItemCategories
		92: BuyPhaseSettings
		93: Entities
		94: ShowBossAbilityInfo
		95: HealthScalar
		96: OrbDisplayPositions
		97: PreviousOrbPositions
		98: OrbPositionDeltas

	player:
		0: Ids
		1: Role
		2: State
		3: Hero
		4: Level
		5: IsDead
		6: Master
		7: Target
		8: Bots
		9: Victims
		10: ShouldUpdateDamageReceived
		11: ArmourModifiers
		12: ArmourIndex
		13: DamageReceivedMultiplier
		14: BaseMoveSpeedModifier
		15: ShouldUpdateMoveSpeed
		16: MoveSpeedBuffs
		17: MoveSpeedDebuffs
		18: MoveSpeedIndex
		19: BaseRegen
		20: ShouldUpdateHealing
		21: HealingModifiers
		22: HealingIndex
		23: DefaultHealth
		24: NormalExtraHealth
		25: IntendedMaxHealth
		26: TotalHPUnits
		27: HealthScale
		28: NormalExtraHealthPools
		29: HealthPoolIndex
		30: BarrierHealth
		31: BarrierHealthDamageModification
		32: CachedHealth
		33: BaseDamageMultiplier
		34: Crit
		35: Visibility
		36: ExtraDeathInfo
		37: MyItemStacks
		38: ShowItemNames
		39: FallDamage
		40: DoubleJumps
		41: BlastCooldown
		42: FlameTornado
		43: FlameTornadoPosition
		44: FlameTornadoExpirationTime
		45: FlameTornadoDamage
		46: WallAcceleration
		47: RecoveryTime
		48: StealthTime
		49: BoomTime
		50: BarrierInfo
		51: DebuffShield
		52: SlowTime
		53: BleedTime
		54: BleedInfo
		55: DebuffFocusTime
		56: APTime
		57: ArmourPiercingStacks
		58: IsHacked
		59: Currency
		60: BuyIndex
		61: CameraPosition
		62: CrippleTime
		63: EvenRarityItemsCount
		64: Sounds
		65: UltCharges
		66: MaxHealthReduction
		67: ShowBossInfo
		68: HasLostThisPhase
		69: NeedleAmmo
		70: WispAcceleration
		71: CanSwing
		72: CanDash
		73: CanSlam
		74: CanSprint
		75: CanNeedle
		76: CanTakeOff
		77: CanUseOrbs
		78: SwingCooldown
		79: DashCooldown
		80: SlamCooldown
		81: NeedleCooldown
		82: TakeoffCooldown
		83: ShockwaveRadius
		84: ShockwaveEffect
		85: DashAngles
		86: DashSpeed
		87: NumPizzaLines
		88: PizzaIndex
		89: PizzaAngle
		90: PizzaAngularVelocity
		91: PizzaRadius
		92: PizzaTime
		93: Phase4DamageReceived
		94: HealthPerItemStack
		95: NumberOfStacksReturned
		96: ItemStackReturnInfo
		97: StackBeingReturnedIndex
		98: StackBeingDepletedIndex
		99: RemainingMatchingStacks
		100: OrbCreationIndex
		101: NewOrbGlobalIndex
		102: DashStartTime
		103: DashStartPosition
		104: NoBlastReason
		105: IsBoss
		106: IsCharacterBody
		107: IsMook
		108: IsHero
		109: MyItemStackSizes
		110: IsSetup
		111: AI
		112: DamageItemsValue
		113: BurnTime
		114: BurnInfo
		115: IsNullPlayer
		116: NewBurnInfo
		117: CauseOfDeath
		118: DashVector
		119: IsUsingUltimate
}

subroutines
{
	1: Steal
	2: Acquire
	3: DistributeItem
	4: DetermineAcceleration
	5: Dash
	6: UpdateMoveSpeed
	7: UpdateDamageReceived
	8: DestroyOrb
	9: HandleOrb
	10: CreateItemStack
	11: SetCoefficient
	12: UpdateStats
	13: ChooseState
	14: UpdateItemStack_Add
	15: UpdateItemStack_Remove
	16: UpdateItemStack_Modify
	17: Settings
	18: CleanseSomeDebuffs
	19: CleanseAllDebuffs
	20: DestroyMe
	21: Buy
	22: UpdateHealing
	23: TrySpawn
	24: SoundCue
	25: PrepareSounds
	26: Call
	27: AiStep
	28: TryShoot
	29: BossSetup
	30: HeroSetup
	31: AddSetup
	32: LoseTarget
	33: ChooseVThrottle
	34: PlayerSetup
	35: DialogueStep
	36: CalculateStats
	37: CapMaxHealth
	38: UpdateCrit
	39: NormalBleed
	40: CreateDamageBeam
	41: OnSlow
	42: SpaceDash
	43: ChooseHThrottle
	44: PrepareForDebuffs
	45: ChooseAdd
}

rule("Global setup")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		If(Global.State);
			Log To Inspector(Custom String("Tried to run global setup rule again"));
			Abort;
		Else;
			Log To Inspector(Custom String("Running global setup"));
		End;
		Call Subroutine(Settings);
		If(Global.MusicMode == 2);
			Disable Built-In Game Mode Music;
		End;
		Log To Inspector(Custom String("BroadcastState: Waiting"));
		Global.Entities = Array(False, False, 0);
		Global.ArenaRadius = 80;
		Global.StagesCompleted = 5;
		Global.Numbers = Empty Array;
		Global.LightningStrikes = Empty Array;
		Global.DamageBeamInfo = Empty Array;
		Global.DamageBeamInstances = Empty Array;
		Global.ChainLightningBans = Empty Array;
		Global.BotCreationQueue = Empty Array;
		Global.AvailableBotSlots = Append To Array(Vector(1, 23, 0), Mapped Array(Array(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
			19, 20, 21, 22, 23), Vector(2, Current Array Element, 0)));
		If(Current Game Mode == Game Mode(Skirmish));
			Disable Built-In Game Mode Completion;
			Set Match Time(0);
		End;
		Global.ItemStackUpdateInfos = Empty Array;
		Global.DeathLineRadius = 0.750;
		Create Effect(All Players(All Teams), Bad Aura, Color(Black), Vector(0, 0, 0), 3.500, Visible To Position and Radius);
		Global.BossSpawnEffect = Last Created Entity;
		Global.ItemRarities = Array(1, 1, 2, 1, 3, 3, 1, 2, 2, 2, 1, 1, 2, 3, 4, 2, 4, 4, 4, 1, 1, 3, 2, 2, 1, 2, 3, 4, 2, 2, 1);
		Global.Items = Array(Custom String("Max HP"), Custom String("Speed"), Custom String("Slow"), Custom String("Bleed"), Custom String("Armour Piercing"), Custom String("Extra Life"), Custom String("Close Range Damage"), Custom String("Ice Blast"), Custom String("Flame Blast"), Custom String("Lifesteal"), Custom String("Stun Chance"), Custom String("Recovery"), Custom String("Double Jump"), Custom String("Armour Reduction"), Custom String("Egg"), Custom String("Reprieve"), Custom String("Lightning"), Custom String("Big Explosion"), Custom String("Rock"), Custom String("Shields"), Custom String("Barrier"), Custom String("Debuff Shield"), Custom String("Chain Lightning"), Custom String("Ult Charge"), Custom String("Crit %"), Custom String("Heal on Crit"), Custom String("Extra Crit Damage"), Custom String("Insides"), Custom String("Debuff Focus"), Custom String("Retaliation"), Custom String("Explosive Kill"));
		Global.ItemSymbols = Array(Custom String("♥"), Custom String("»"), Custom String("«"), Custom String("†"), Custom String("▲"), Custom String("+1"), Custom String("(•)"), Custom String("*"), Custom String("*"), Custom String("Ϣ"), Custom String("@"), Custom String("+"), Custom String("ニ"), Custom String("Ø"), Custom String("0"), Custom String("◌"), Icon String(Bolt), Icon String(Warning), Custom String("●"), Custom String("♥"), Custom String("○"), Custom String("Θ"), Custom String("Y"), Custom String("Ult"), Custom String("!%"), Custom String("!+"), Custom String("!!!"), Custom String("8"), Custom String("ǒ"), Custom String("↑↓"), Custom String("Ḿ"));
		Global.ItemColours = Array(Custom Color(205, 83, 63, 255), Custom Color(189, 192, 159, 255), Custom Color(230, 225, 209, 255), Custom Color(171, 43, 43, 255), Custom Color(88, 100, 73, 255), Custom Color(189, 191, 206, 255), Custom Color(226, 40, 78,255), Custom Color(214, 229, 233, 255), Custom Color(165, 114, 106, 255), Custom Color(77, 34, 21, 255), Custom Color(62, 75,53, 255), Custom Color(25, 98, 10, 255), Custom Color(85, 188, 229, 255), Custom Color(230, 139, 142, 255), Custom Color(255,185, 148, 255), Custom Color(96, 71, 70, 200), Color(White), Color(White), Custom Color(13, 20, 59, 255), Custom Color(165,239, 246, 255), Custom Color(198, 193, 252, 200), Custom Color(239, 221, 23, 255), Custom Color(180, 229, 222, 255), Custom Color(82, 83, 71, 255), Custom Color(100, 0, 0, 244), Custom Color(143, 131, 126, 255), Custom Color(255, 0, 0, 244), Custom Color(123, 23, 45, 255), Custom Color(143, 91, 101, 255), Custom Color(161, 187, 208, 255), Custom Color(112, 27, 19, 255));
		Global.ItemDescriptions = Array(Custom String("Each stack increases maximum health.\n"), Custom String("Each stack increases movement speed.\n"), Custom String("Slow enemies on hit for 2s\n(extra stacks increase the duration)."), Custom String("Each stack grants 10% chance to bleed enemies on hit.\n"), Custom String("Hitting an enemy 5 times increases their damage taken for 8s\n(extra stacks increase the duration)."), Custom String("Each stack grants one extra life.\n"), Custom String("Each stack increases damage dealt to nearby enemies by 20%.\n"), Custom String("High damage hits also blast enemies with ice, on a 10s cooldown.\n"), Custom String("High damage hits also leave behind a flame blast, on a 10s cooldown.\n"), Custom String("Dealing damage heals you.\n"), Custom String("5% chance to stun enemies on hit for 2s\n(extra stacks increase the stun chance)."), Custom String("Heal for a % of max HP 2s after getting hurt\n(extra stacks increase the healing received)."), Custom String("Each stack grants an extra jump.\n"), Custom String("Each hit on an enemy permanently increases their damage taken.\n"), Custom String("is egg\n"), Custom String("Turn invisible at low health\n(extra stacks reduce the cooldown)."), Custom String("is lightning!\n"), Custom String("is beeg explosion\n"), Custom String("rok\n"), Custom String("Each stack adds 8% of your max HP as regenerating shield health.\n"), Custom String("Reduce the damage of one hit, on a cooldown\n(extra stacks increase the damage reduction)."), Custom String("Prevent 1 debuff on a 5s cooldown\n(extra stacks prevent more debuffs)."), Custom String("25% chance for hits to fire chain lightning\n(extra stacks increase the number of targets hit)."), Custom String("Each stack grants an extra charge of your ultimate ability.\nUlt also charges faster."), Custom String("Each stack grants 10% critical hit damage / chance\n(depending on your hero)."), Custom String("Grants 5% critical hit damage / chance.\nCritical hits heal you (extra stacks heal more)."), Custom String("Each stack causes critical hits to deal 100% more damage.\n"), Custom String("yuck :/\n"), Custom String("Hitting an enemy with at least 4 debuffs increases their damage taken\n(for 7 seconds per stack)."), Custom String("25% chance to damage up to 5 nearby enemies every time you are hit\n(extra stacks increase the range and the number of targets)."), Custom String("Killing an enemy sets other nearby enemies on fire.\n(extra stacks increase the range and the burn damage)"));
		Global.ItemCategories = Array(Vector(0, 1, 0), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 0, 0), Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 0, 0), Vector(1, 0, 0), Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1), Vector(1, 0, 0), Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 1, 0), Vector(0, 0, 1), Vector(0, 0, 1), Vector(1, 0, 0), Vector(0, 0, 1), Vector(1, 0, 0), Vector(0, 1, 0), Vector(1, 0, 0), Vector(1, 0, 0), Vector(1, 0, 0), Vector(1, 0, 0), Vector(1, 0, 0));
		Global.ItemDistributionQueue = Empty Array;
		Global.ItemStackOriginalOwners = Empty Array;
		Global.Buttons = Array(Button(Ability 1), Button(Ability 2), Button(Crouch), Button(Melee), Button(Primary Fire), Button(
			Secondary Fire), Button(Ultimate));
		Global.AllHeroes = Array(Hero(Ana), Hero(Ashe), Hero(Baptiste), Hero(Bastion), Hero(Brigitte), Hero(Cassidy), Hero(D.Va), Hero(
			Doomfist), Hero(Echo), Hero(Genji), Hero(Hanzo), Hero(Junker Queen), Hero(Junkrat), Hero(Kiriko), Hero(Lúcio), Hero(Mei), Hero(
			Mercy), Hero(Moira), Hero(Orisa), Hero(Pharah), Hero(Ramattra), Hero(Reaper), Hero(Reinhardt), Hero(Roadhog), Hero(Sigma),
			Hero(Sojourn), Hero(Soldier: 76), Hero(Sombra), Hero(Symmetra), Hero(Torbjörn), Hero(Tracer), Hero(Widowmaker), Hero(Winston),
			Hero(Wrecking Ball), Hero(Zarya), Hero(Zenyatta));
		Global.ProcCoefs = Array(-1, 1, 1, 0, 1, 0.850, 0, 0, 0.500, -1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0.650, 0, 0, 0, 0, 0, 1, -1, 1, 1, 1,
			0, 0, 1, 1, 0, 0, 0, -1, 0, 1, 1, 0.750, 1, 1, 0.650, 0, 1, 0.700, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0.500, 0, 1, 0.800, -1, 0, 1,
			-1, 0, 1, 0.750, 0.800, 1, 1, 1, 0, 1, 1, 0, 0.850, 0, -1, 0, -1, 1, -1, -1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
			1, 1, 1, 0, 0, 0, 0, 1, 0.350, 1, 0.100, 0, 0, 0, 1, 1, 0, 0, 0, 0.150, 0, 1, 0, 0.500, 0.500, 0, 0.650, 0, 1, 0.650, 1, 1, 0,
			1, 0, 1, 1, 0, 0.100, 1, 0.100, 0, 1, 0.350, 0, 0.150, 0, 0, 0, 1, 1, 0, 0.950, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0.600,
			0, 1, 0, 1, 1, 0, 0, 0, 0.200, 0, 1, 0.500, 1, 1, 0, 0, 0, 1, 0.700, 1, 0.700, 0, 0, 0, 1, 0.350, 0, 0, 0, 0, 0, 1, 0.500, 1,
			0, 0, 0, 0, 1, 1, 1, 0.100, 0, 0, 0, 1, 0.150, 0, 1, 0, 0.100, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0.600, 1, 1, 0, 0, 1, 1, 0.300, 1, 1,
			0, 0, 0, 1, 0.500, 1, 0.100, 0, 0, 0, 1, 1, 0.800, 0);
		Global.FlamePillarPositions = Empty Array;
		Global.FlamePillarExpirationTimes = Empty Array;
		Global.FlamePillars = Empty Array;
		Global.OrbCreators = Empty Array;
		Create HUD Text(Filtered Array(All Players(Team 1), Current Array Element.CameraPosition == Null), Custom String("{0}{1}{2}", Global.Difficulty[2] > 0 ? Custom String("") : Custom String("{0} ", Array(
			Icon String(Happy), Icon String(Sad), Icon String(Skull))[Global.Difficulty[0] - 1]), Global.Difficulty[2] > 0 ? Custom String("Extra Hard") : Array(Custom String("Easy"),
			Custom String("Normal"), Custom String("Hard"))[Global.Difficulty[0] - 1], Global.Difficulty[2] > 0 ? Custom String(" ({0})", Global.Difficulty[2]) : Custom String("")), Null, Null, Right, 0, Global.Difficulty[2] > 0 ? Custom Color(155, 197, 233, 255) : Array(Custom Color(102,
			153, 102, 255), Custom Color(204, 153, 102, 255), Custom Color(153, 51, 51, 255))[Global.Difficulty[0] - 1], Color(White),
			Color(White), Visible To, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Current Array Element.CameraPosition == Null), Null,
			Global.State == Custom String("BossFight") ? Custom String("Objective: Defeat the boss") : (Global.State == Custom String(
			"Buy") ? Custom String("Objective: Buy power-ups") : Custom String(" ")), Null, Right, 0.100, Array(Custom Color(102, 153, 102,
			255), Custom Color(204, 153, 102, 255), Custom Color(153, 51, 51, 255))[Global.Difficulty[0] - 1], Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 1, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 3, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		If(Global.TestMode[0]);
			Create HUD Text(All Players(All Teams), Server Load Peak, Null, Server Load Average, Left, 0, Color(White), Color(
				White), Color(White), Visible To and String, Default Visibility);
		End;
		Global.BallNames = Array(Custom String("Interference"), Custom String("Locomotion"), Custom String("Destruction"));
		Global.TracerNames = Array(Custom String("Soul"), Custom String("Design"), Custom String("Wonder"), Custom String("Speed"),
			Custom String("Inspiration"), Custom String("Strength"), Custom String("Curiosity"), Custom String("Spirit"), Custom String(
			"Life"), Custom String("Power"));
		Global.ZenyattaNames = Array(Custom String("Stone"), Custom String("Silver"), Custom String("Speed"), Custom String("Volatility"),
			Custom String("Stability"), Custom String("Dance"), Custom String("Song"));
		Create Effect(All Players(All Teams), Light Shaft, Color(Sky Blue), Vector(0, 0, 0), 1.060 * Global.ArenaRadius, Visible To);
		Create Effect(All Players(All Teams), Ring, Color(Gray), Vector(0, 0, 0), 57, Visible To);
		Create Beam Effect(Count Of(Global.LightningStrikes) ? All Players(All Teams) : Null, Bad Beam, Update Every Frame(
			Global.LightningStrikes[1] + 30 * Up), Update Every Frame(Global.LightningStrikes[1] + Down), Color(White),
			Visible To Position Radius and Color);
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Sigma), Team 2));
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Soldier: 76), Team 1));
		Global.EarlyHeroDeathDialogue = Array(Custom String("Return to dirt."), Custom String("Submit, vermin."), Custom String(
			"Die, vermin."), Custom String("Die, weakling."), Custom String("Become memories."));
		Global.LateHeroDeathDialogue = Array(Custom String("DIE."), Custom String("WEAK."), Custom String("USELESS."), Custom String(
			"AS I THOUGHT…"), Custom String("VERMIN."));
		Global.BossDeathDialogue = Array(Custom String("NO… NOT NOW…"), Custom String("WHY… WHY NOW…?"), Custom String("NO… NO…!"),
			Custom String("BROTHER… HELP ME…!"), Custom String("THIS PLANE GROWS DARK… BROTHER… I CANNOT SEE YOU… WHERE ARE YOU…?"),
			Custom String("BROTHER… PERHAPS… WE WILL GET IT RIGHT… NEXT TIME…"));
		Global.UsedDialogue = Empty Array;
		Global.ShowBossAbilityInfo[0] = True;
		Global.State = Custom String("Buy");
	}
}

rule("Settings")
{
	event
	{
		Subroutine;
		Settings;
	}

	actions
	{
		Global.TestMode[0] = Workshop Setting Toggle(Custom String("Developer"), Custom String("Test Mode"), False, 0);
		Global.TestMode[1] = Workshop Setting Toggle(Custom String("Developer"), Custom String("Auto-takeoff"), False, 1);
		Global.MusicMode = Workshop Setting Combo(Custom String("Customization"), Custom String("Music Mode"), 1, Array(Custom String(
			"Overwatch"), Custom String("Scuffed"), Custom String("Broadcast")), 0);
		Global.Difficulty[2] = Workshop Setting Combo(Custom String("Difficulty"), Custom String("Extra Hard Mode"), 0, 
		Array(Custom String("Disabled"), Custom String("-50% starting health"), Custom String("Fall damage"), Custom String("+40% enemy speed"), Custom String("-50% healing"), Custom String("Initial enemy level"), Custom String("Reduced enemy cooldowns"), Custom String("Some damage is permanent")), 0);
		Global.Difficulty[0] = Global.Difficulty[2] == 0 ? Workshop Setting Integer(Custom String("Difficulty"), Custom String("Difficulty"), 2, 1, 3, 0) : 3;
		Global.OverallPlayerLevel = Workshop Setting Integer(Custom String("Difficulty"), Custom String("Player Level"), 8, 1, 99, 0);
		Global.Dialogue = Array(Workshop Setting Toggle(Custom String("Customization"), Custom String("Enable Dialogue"), False, 0), 5,
			Null, Null, Null);
		Global.BuyPhaseSettings[0] = Workshop Setting Integer(Custom String("Customization"), Custom String(
			"Buy Phase Duration (seconds)"), 100, 10, 120, 1);
		Global.BuyPhaseSettings[1] = Workshop Setting Toggle(Custom String("Customization"), Custom String(
			"Buy Phase starts when a player picks a hero"), True, 3);
		Global.BuyPhaseSettings[3] = Workshop Setting Toggle(Custom String("Customization"), Custom String(
			"Buy Phase Timer"), True, 2);
		Global.HealthScalar = 0.900;
	}
}

rule("Dialogue")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.Dialogue) > 1 + Global.Dialogue[1];
	}

	actions
	{
		Call Subroutine(DialogueStep);
		Wait(0.200, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Dialogue Step")
{
	event
	{
		Subroutine;
		DialogueStep;
	}

	actions
	{
		Global.Dialogue[2] = Global.Dialogue[Global.Dialogue[1]];
		If(Global.Dialogue[2] == Null);
			Global.Dialogue[2] = Random Value In Array(Filtered Array(Global.Bosses, Is Alive(Current Array Element)
				&& Current Array Element.State != Custom String("Absent")));
		End;
		If(Global.Dialogue[2].Ids[0] != Null && Array Contains(All Players(All Teams), Global.Dialogue[2]));
			Global.Dialogue[3] = Global.Dialogue[Global.Dialogue[1] + 1];
			If(Global.Dialogue[3] == Custom String("BossSpawn"));
				Global.Dialogue[4] = Random Value In Array(Array(Custom String("Pray."), Custom String("Beg."), Custom String("Die."),
					Custom String("Be slaughtered.")));
			Else If(Global.Dialogue[3] == Custom String("EarlyHeroDeath"));
				Global.Dialogue[4] = Random Value In Array(Remove From Array(Global.EarlyHeroDeathDialogue, Global.UsedDialogue));
				If(Global.Dialogue[4] == Null);
					Modify Global Variable(UsedDialogue, Remove From Array By Value, Global.EarlyHeroDeathDialogue);
					Global.Dialogue[4] = Random Value In Array(Global.EarlyHeroDeathDialogue);
				End;
			Else If(Global.Dialogue[3] == Custom String("LateHeroDeath"));
				Global.Dialogue[4] = Random Value In Array(Remove From Array(Global.LateHeroDeathDialogue, Global.UsedDialogue));
				If(Global.Dialogue[4] == Null);
					Modify Global Variable(UsedDialogue, Remove From Array By Value, Global.LateHeroDeathDialogue);
					Global.Dialogue[4] = Random Value In Array(Global.LateHeroDeathDialogue);
				End;
			Else If(Global.Dialogue[3] == Custom String("BossDeath"));
				Global.Dialogue[4] = Random Value In Array(Remove From Array(Global.BossDeathDialogue, Global.UsedDialogue));
				If(Global.Dialogue[4] == Null);
					Modify Global Variable(UsedDialogue, Remove From Array By Value, Global.BossDeathDialogue);
					Global.Dialogue[4] = Random Value In Array(Global.BossDeathDialogue);
				End;
			End;
			If(Global.Dialogue[4] != Null);
				If(Global.Dialogue[3] == Custom String("BossSpawn"));
					Big Message(All Players(Team 1), Global.Dialogue[4]);
					Small Message(All Players(Team 2), Custom String("[{0}]: {1}", Global.Dialogue[2].Ids[0], Global.Dialogue[4]));
				Else If(Global.Dialogue[3] == Custom String("EarlyHeroDeath") || Global.Dialogue[3] == Custom String("LateHeroDeath"));
					Big Message(All Dead Players(Team 1), Global.Dialogue[4]);
					Small Message(Remove From Array(All Players(All Teams), All Dead Players(Team 1)), Custom String("[{0}]: {1}",
						Global.Dialogue[2].Ids[0], Global.Dialogue[4]));
				Else;
					Small Message(All Players(All Teams), Custom String("[{0}]: {1}", Global.Dialogue[2].Ids[0], Global.Dialogue[4]));
				End;
				Modify Global Variable(UsedDialogue, Append To Array, Global.Dialogue[4]);
			End;
		End;
		If(Count Of(Global.Dialogue) > 998);
			Global.Dialogue = Append To Array(Array Slice(Global.Dialogue, 0, 4), Array Slice(Global.Dialogue, 7, 1000));
		Else;
			Global.Dialogue[1] += 2;
		End;
	}
}

rule("Player Left Match")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		Global.Entities[0] = True;
		Global.Heroes = Filtered Array(Global.Heroes, Array Contains(All Players(All Teams), Current Array Element));
		Global.Bosses = Filtered Array(Global.Bosses, Array Contains(All Players(All Teams), Current Array Element));
	}
}

rule("Player Left Match")
{
	event
	{
		Ongoing - Global;
	}
	
	conditions
	{
		Global.Entities[0] == True;
		Global.Entities[1] == False;
	}

	actions
	{
		Global.Entities[1] = True;
		Global.Entities[0] = False;
		Global.Entities[2] = 3;
		While(Global.Entities[2] < Count Of(Global.Entities));
			If(!Is True For Any(All Players(All Teams), Current Array Element.Ids[1] == Global.Entities[Global.Entities[2]]));
				If(Global.Entities[Global.Entities[2] + 1] == 0);
					Destroy Effect(Global.Entities[Global.Entities[2] + 2]);
				End;
				Global.Entities = Append To Array(Array Slice(Global.Entities, 0, Global.Entities[2]), Array Slice(Global.Entities, Global.Entities[2] + 3, 1000));
			Else;
				Global.Entities[2] += 3;
			End;
			Wait(0.016, Ignore Condition);
		End;
		Wait(0.016, Ignore Condition);
		Loop If(Global.Entities[0] == True);
		Global.Entities[1] = False;
	}
}

rule("Identify Boss")
{
	event
	{
		Player Joined Match;
		Team 2;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.Ids[1] = Random Integer(-9999999, 9999999);
		Log To Inspector(Custom String("boss joined"));
		Event Player.Role = Custom String("Boss");
		Event Player.IsBoss = True;
		Event Player.IsCharacterBody = True;
		Event Player.Master[0] = Event Player;
		Start Rule(PlayerSetup, Do Nothing);
	}
}

rule("Boss Setup")
{
	event
	{
		Subroutine;
		BossSetup;
	}

	actions
	{
		Event Player.Ids[0] = Custom String("{0}", Event Player);
		Event Player.PizzaRadius = 100;
		Chase Player Variable At Rate(Event Player, SwingCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, SlamCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, NeedleCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, DashCooldown, 0, 1, None);
		"Hammer swing"
		Create HUD Text(Global.ShowBossAbilityInfo[0] ? Event Player : Null, Ability Icon String(Hero(Reinhardt), Button(
			Primary Fire)), Custom String("[{0}]", Input Binding String(Button(Primary Fire))),
			Event Player.SwingCooldown ? Round To Integer(Event Player.SwingCooldown, Up) : Custom String(" "), Right, 0.100,
			Event Player.CanSwing ? (Event Player.SwingCooldown > 0 ? Color(Orange) : Color(Gray)) : Color(Red), Event Player.CanSwing ? Color(White) : Custom Color(127, 127, 127, 170), Color(
			White), Visible To String and Color, Default Visibility);
		"Shoot"
		Create HUD Text(Global.Phase != Custom String("X") ? Event Player : Null, Ability Icon String(Hero(Sojourn), Button(
			Ultimate)), Custom String("[{0}]", Input Binding String(Button(Secondary Fire))),
			Event Player.NeedleCooldown > 0 ? Custom String("…") : Round To Integer(Event Player.NeedleAmmo, Up), Right, 0.200,
			Event Player.CanNeedle[1] ? (Event Player.NeedleCooldown > 0 ? Color(Orange) : Color(Gray)) : Color(Red), Event Player.CanNeedle[1] ? Color(White) : Custom Color(127, 127, 127, 170), Color(
			White), Visible To String and Color, Default Visibility);
		"Slam"
		Create HUD Text(Global.ShowBossAbilityInfo[0] ? Event Player : Null, Ability Icon String(Hero(Reinhardt), Button(
			Ultimate)), Custom String("[{0}]", Input Binding String(Button(Ultimate))), Event Player.SlamCooldown ? Round To Integer(
			Event Player.SlamCooldown, Up) : Custom String(" "), Right, 0.300, Event Player.CanSlam[0] ? (Event Player.SlamCooldown > 0 ? Color(
			Orange) : Color(Gray)) : Color(Red), Event Player.CanSlam ? Color(White) : Custom Color(127, 127, 127, 170), Color(White), Visible To String and Color, Default Visibility);
		"Sprint"
		Create HUD Text(Global.ShowBossAbilityInfo[0] ? Event Player : Null, Ability Icon String(Hero(Soldier: 76), Button(
			Ability 1)), Custom String("[{0}]", Input Binding String(Button(Ability 1))), Null, Right, 0.400, Event Player.CanSprint ? (
			Event Player.State == Custom String("ClosingIn") ? Color(Orange) : Color(Gray)) : Color(Red), Event Player.CanSprint ? Color(White) : Custom Color(127, 127, 127, 170), Color(White),
			Visible To String and Color, Default Visibility);
		"Orbs"
		Create HUD Text(Global.Phase == 4 ? Event Player : Null, Ability Icon String(Hero(Echo), Button(
			Secondary Fire)), Custom String("[{0}]", Input Binding String(Button(Ability 2))), Null, Right, 0.500, Event Player.CanUseOrbs ? (
			Event Player.State == Custom String("Orbs") ? Color(Orange) : Custom Color(204 + 51 * Cosine From Degrees(360 * Total Time Elapsed), 204 + 51 * Cosine From Degrees(360 * Total Time Elapsed), 255, 255)) : Color(Red), Event Player.CanUseOrbs ? Color(White) : Custom Color(127, 127, 127, 170), Color(White),
			Visible To String and Color, Default Visibility);
		"Dash"
		Create HUD Text(Global.ShowBossAbilityInfo[0] ? Event Player : Null, Ability Icon String(Hero(Tracer), Button(
			Ability 1)), Event Player.State == Custom String("ClosingIn") ? Custom String("←/↓/→") : Custom String("[{0}]",
			Input Binding String(Button(Jump))), Custom String("{0} • {1}", Event Player.DashCooldown > 0 ? Round To Integer(
			Event Player.DashCooldown, Up) : Custom String(" "), Event Player.CanDash[1]), Right, 0.600, Event Player.CanDash[0] ? (
			Event Player.DashCooldown > 0 || Event Player.CanDash[1] == 0 || Event Player.State == Custom String("Dashing") ? Color(Orange) : Color(Gray)) : Color(Red),
			Event Player.CanDash ? Color(White) : Custom Color(127, 127, 127, 170), Color(White), Visible To String and Color, Default Visibility);
		"Takeoff"
		Create HUD Text(Global.ShowBossAbilityInfo[0] ? Event Player : Null, Ability Icon String(Hero(Doomfist), Button(
			Ultimate)), Global.TestMode[1] ? Custom String("") : Custom String("[{0}]", Input Binding String(Button(Crouch))), Event Player.CanTakeOff && Event Player.TakeoffCooldown ? Round To Integer(Event Player.TakeoffCooldown, Up)
			: Custom String(" "), Right, 0.700, Event Player.CanTakeOff ? ((Global.TestMode[1] || Event Player.TakeoffCooldown || String Contains(Event Player.State, Custom String("Takeoff"))) ? Color(Orange) : Custom Color(204 + 51 * Cosine From Degrees(360 * Total Time Elapsed), 204 + 51 * Cosine From Degrees(360 * Total Time Elapsed), 255, 255)) : Color(Red), Event Player.CanTakeOff ? Color(White) : Custom Color(127, 127, 127, 170), Color(White),
			Visible To String and Color, Default Visibility);
		"Pizza"
		Create HUD Text(Global.Phase == 3 ? Event Player : Null, Ability Icon String(Hero(Orisa), Button(Ability 2)),
			Null, Event Player.PizzaIndex == Custom String("Dormant") ? Custom String(" ") : Max(0,
			Event Player.PizzaTime[0] - Total Time Elapsed), Right, 0.800, Event Player.PizzaIndex == Custom String("Dormant")
			|| Event Player.IsHacked ? Color(Red) : (Event Player.PizzaIndex == Custom String("Soon") ? Color(Gray) : Color(Orange)),
			Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Event Player.Target == Null ? Null : Event Player, Hero Icon String(Hero Of(Event Player.Target)),
			Custom String("Controlling: {0} ({1})", Event Player.Target.Ids[0], Event Player.Target.Hero[0]), Is Dead(Event Player.Target) ? Icon String(X) : Custom String("{0}{1}", Mapped Array(Custom String(
			"■■■■■■■■■■■■■■"), String Slice(Current Array Element, 0, Round To Integer(Normalized Health(Event Player.Target)
			* String Length(Current Array Element), Up))), Mapped Array(Custom String("□□□□□□□□□□□□□□"), String Slice(
			Current Array Element, 0, Round To Integer((1 - Normalized Health(Event Player.Target)) * String Length(Current Array Element),
			Down)))), Left, 3.100, Color(White), Color(White), Health Of Type(Event Player, Shields) > 0 ? (Normalized Health(
			Event Player.Target) > 0.900 ? Color(Blue) : Custom Color(46, 172, 246, 255)) : (Normalized Health(Event Player.Target)
			> 0.900 ? Color(Green) : Color(Lime Green)), Visible To String and Color, Default Visibility);
		Create HUD Text(Event Player.Target == Null || Is Dead(Event Player.Target) ? Null : Event Player, Null, Custom String("Hold [{0}] to control a different minion", Input Binding String(Button(Interact))), Null, Left, 3.200, Color(White), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Event Player.Target == Null || Hero Of(Event Player.Target) == Hero(Wrecking Ball) ? Null : Event Player, Hero Of(
			Event Player.Target) == Hero(Tracer) ? (Ultimate Charge Percent(Event Player.Target) == 100 ? Ability Icon String(Hero(Tracer),
			Button(Ultimate)) : String("{0}%", Ultimate Charge Percent(Event Player.Target))) : (
			Event Player.Target.DashCooldown == 0 ? Ability Icon String(Hero(Sojourn), Button(Ability 1)) : Round To Integer(
			Event Player.Target.DashCooldown, Up)), Custom String("[{0}]", Input Binding String(Hero Of(Event Player.Target) == Hero(
			Tracer) ? Button(Ultimate) : Button(Ability 1))), Null, Left, 3.300, (Hero Of(Event Player.Target) == Hero(Tracer)
			? Event Player.Target.IsUsingUltimate : Event Player.Target.State == Custom String("Dashing")) ? Color(Orange) : Color(
			White), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create Effect(Is Alive(Event Player) && Event Player.State != Custom String("Absent") && (Global.Phase == 1 || Global.Phase == 3)
			? Remove From Array(All Players(All Teams), Event Player) : Null, Moira Coalescence Sound, Color(White), Event Player, 100,
			Visible To Position and Radius);
		Set Jump Enabled(Event Player, False);
		Event Player.ShockwaveRadius = -1;
		Event Player.PizzaIndex = Custom String("Dormant");
		Create Icon(Event Player.ShowBossInfo[1] ? Filtered Array(Global.Heroes,
			Current Array Element.CameraPosition == Null && Has Spawned(Event Player) && Is Alive(Event Player) && (
			Event Player.ShowBossInfo[1] == 2 || (Event Player.Visibility[0] ? !Is In View Angle(Current Array Element, Eye Position(
			Event Player), 52) : Event Player.Visibility[1]))) : Null, Event Player, Arrow: Down, Visible To and Position, Color(Red),
			True);
		Event Player.NumPizzaLines = 4;
		For Player Variable(Event Player, PizzaIndex, 0, Event Player.NumPizzaLines, 1);
			Create Beam Effect(Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage")), Event Player.State) ? All Players(
				All Teams) : Null, Bad Beam, Update Every Frame(Position Of(Event Player) + (Event Player.State == Custom String("Pizza")
				? 0 : Max(0, Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20) * Up + Event Player.PizzaRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0)
				+ Global.DeathLineRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)), Update Every Frame(Position Of(Event Player) + (
				Event Player.State == Custom String("Pizza") ? 0 : Max(0, Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20)
				* Up - Event Player.PizzaRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0) + Global.DeathLineRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)),
				Event Player.State == Custom String("Pizza") ? Color(Blue) : Color(White), Visible To Position Radius and Color);
			Create Beam Effect(Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage")), Event Player.State) ? All Players(
				All Teams) : Null, Bad Beam, Update Every Frame(Position Of(Event Player) + (Event Player.State == Custom String("Pizza")
				? 0 : Max(0, Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20) * Up + Event Player.PizzaRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0)
				- Global.DeathLineRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)), Update Every Frame(Position Of(Event Player) + (
				Event Player.State == Custom String("Pizza") ? 0 : Max(0, Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20)
				* Up - Event Player.PizzaRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0) - Global.DeathLineRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)),
				Event Player.State == Custom String("Pizza") ? Color(Blue) : Color(White), Visible To Position Radius and Color);
		End;
		Create Icon(Event Player.ArmourModifiers[1] && Has Spawned(Event Player) && !Event Player.HasLostThisPhase && !Has Status(Event Player, Phased Out) ? All Players(
			All Teams) : Null, Event Player, Heart, Visible To and Position, Color(Yellow), False);
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Orisa), Event Player));
		Set Knockback Received(Event Player, 0);
		Event Player.ItemStackReturnInfo = Empty Array;
		Event Player.CanDash[1] = 2;
		Event Player.State = Custom String("Waiting");
		Event Player.CanDash[3] = 1;
		Event Player.IsSetup = True;
	}
}

rule("Player Setup")
{
	event
	{
		Subroutine;
		PlayerSetup;
	}

	actions
	{
		If(Current Game Mode == Game Mode(Skirmish));
			Disable Game Mode HUD(Event Player);
		End;
		If(Global.State == Custom String("BossFight"));
			Disable Built-In Game Mode Respawning(Event Player);
		End;
		Wait Until(Array Contains(All Heroes, Hero Of(Event Player)) && Max Health(Event Player) > 0, 9999);
		"If I enable Echo I should allow this to change based on who she's duplicating"
		Event Player.Hero[0] = Hero Of(Event Player);
		Event Player.Hero[1] = Index Of Array Value(Global.AllHeroes, Event Player.Hero[0]);
		Disable Kill Feed(Event Player);
		If(Event Player.IsNullPlayer);
			Set Invisible(Event Player, All);
			Set Status(Event Player, Null, Phased Out, 9999);
			If(Team Of(Event Player) == Team 2);
				Global.NullPlayer[1] = Event Player;
				Start Forcing Player Position(Event Player, Vector(-5, 300, 0), False);
				Event Player.Ids[0] = Custom String("The Planet");
			Else If(Team Of(Event Player) == Team 1);
				Global.NullPlayer[0] = Event Player;
				Start Forcing Player Position(Event Player, Vector(5, 300, 0), False);
				Event Player.Ids[0] = Custom String("The Captain");
			End;
			Start Forcing Dummy Bot Name(Event Player, Event Player.Ids[0]);
			Event Player.IsSetup = True;
			Abort;
		End;
		Event Player.FallDamage[0] = (Workshop Setting Toggle(Custom String("Difficulty"), Custom String("Fall damage"), True, 2) ? 1 : 0) + (Global.Difficulty[2] >= 2 ? 1 : 0);
		Event Player.Crit[0] = !Array Contains(Array(Hero(Ana), Hero(Brigitte), Hero(Junkrat), Hero(Moira), Hero(Pharah), Hero(Sigma),
			Hero(Symmetra), Hero(Winston), Hero(Zarya)), Event Player.Hero[0]);
		Call Subroutine(UpdateCrit);
		Event Player.MyItemStacks = Empty Array;
		Event Player.NormalExtraHealthPools = Empty Array;
		Event Player.HealthScale = Array(Null, Null, 1, Null, Null, Team Of(Event Player) == Team 2 ? 1 / (1 + 0.200 * (Round To Integer(Global.OverallPlayerLevel, Down) - 1)) : 1);
		Event Player.HealthScale[3] = Global.HealthScalar * Event Player.HealthScale[5];
		If(Event Player.IsBoss || Event Player.IsHero);
			Chase Player Variable At Rate(Event Player, RecoveryTime, 0, 1, None);
			Create HUD Text(Event Player.CameraPosition != Null || Array Contains(Array(Null, Custom String("Buy")), Global.State)
				? Null : Event Player, Null, Null, Custom String("{0}{1}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}",
				Event Player.BlastCooldown ? Custom String("{0}×{1} ", Icon String(Asterisk), Round To Integer(Event Player.BlastCooldown, Up))
				: Custom String(""), Event Player.BarrierInfo[0] && Event Player.BarrierInfo[1] < Total Time Elapsed ? Custom String("{0} ", Icon String(Ring Thick))
				: Custom String(""), Event Player.DebuffShield[0] > 0 ? Custom String("Θ×{0} ", Event Player.DebuffShield[0]) : Custom String(
				"")), Event Player.RecoveryTime ? Custom String("{0} ", Icon String(Plus)) : Custom String(""), Event Player.StealthTime[1] ? Custom String(
				"{0}{1} ", Icon String(Eye), Event Player.Visibility[0] || Event Player.Visibility[1] ? Custom String("") : Max(1,
				Round To Integer(Event Player.StealthTime[1] - Total Time Elapsed, Up))) : Custom String("")), Custom String("{0}{1}{2}", Custom String("{0}{1}", Event Player.BurnTime ? Custom String("{0} ", Icon String(Fire)) : Custom String(""),
				Event Player.CrippleTime ? Custom String("{0} ", Icon String(Skull)) : Custom String("")), Custom String("{0}{1}{2}",
				Event Player.SlowTime ? Custom String("{0} ", Icon String(Arrow: Down)) : Custom String(""), Event Player.DebuffFocusTime ? Custom String("{0} ", Ability Icon String(Hero(
				Zenyatta), Button(Ability 2))) : Custom String(""), Event Player.MaxHealthReduction[0] ? Custom String("{0}×{1} ", Icon String(Poison), Event Player.MaxHealthReduction[0]) : Custom String("")), Custom String("{0}{1}{2}", Event Player.BleedInfo[0] ? Custom String(
				"†×{0} ", Event Player.BleedInfo[0]) : Custom String(""), Event Player.ArmourPiercingStacks[0] ? Custom String("Ѳ×{0} ",
				Event Player.ArmourPiercingStacks[0]) : Custom String(""), Event Player.ArmourPiercingStacks[1] ? Custom String("Ø×{0} ",
				Event Player.ArmourPiercingStacks[1]) : Custom String("")))), Left, 2.100, Color(White), Color(White), Color(White),
				Visible To and String, Default Visibility);
			Create HUD Text(Event Player.CameraPosition != Null || (Event Player.IsBoss && Global.Phase == 2)
				? Null : Remove From Array(All Players(Team Of(Event Player)), Event Player), Hero Icon String(Hero Of(Event Player)),
				Event Player, Is Dead(Event Player) ? Icon String(X) : Custom String("{0}{1}", Mapped Array(Custom String("■■■■■■■■■■■■■■"),
				String Slice(Current Array Element, 0, Round To Integer((Health(Event Player) + Event Player.BarrierHealth) / (2 * Max Health(
				Event Player)) * String Length(Current Array Element), Up))), Mapped Array(Custom String("□□□□□□□□□□□□□□"), String Slice(
				Current Array Element, 0, Round To Integer((1 - (Health(Event Player) + Event Player.BarrierHealth) / (2 * Max Health(
				Event Player))) * String Length(Current Array Element), Down)))), Left, 3.100, Color(White), Color(White),
				Event Player.BarrierHealth > 0 ? Custom Color(225, 200, 70, 255) : (Health Of Type(Event Player, Shields) > 0 ? (
				Normalized Health(Event Player) > 0.900 ? Color(Blue) : Custom Color(46, 172, 246, 255)) : (Normalized Health(Event Player)
				> 0.900 ? Color(Green) : Color(Lime Green))), Visible To String and Color, Default Visibility);
			Create HUD Text(Event Player.ExtraDeathInfo[0] && Count Of(Event Player.ExtraDeathInfo) > 1 ? Event Player : Null, Custom String(
				"Killed by: {0}", Hero Icon String(Event Player.ExtraDeathInfo[2])), Null, Custom String("{0} dealt {1} damage to you with {2}",
				Mapped Array(Event Player.ExtraDeathInfo[3], Current Array Element == Null ? Custom String("???") : Current Array Element),
				Event Player.ExtraDeathInfo[1], Event Player.CauseOfDeath[1] == Null ? Custom String("???") : Event Player.CauseOfDeath[1]),
				Right, 2, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			Start Healing Modification(Event Player, All Players(All Teams), 100 * Event Player.HealingModifiers[0] / Event Player.HealthScale[2], Receivers Healers and Healing Percent);
		End;
		Event Player.DefaultHealth = Array(Max Health(Event Player), Max Health Of Type(Event Player, Health), Max Health Of Type(
			Event Player, Armor), Max Health Of Type(Event Player, Shields));
		If(Team Of(Event Player) == Team 2);
			Call Subroutine(PrepareForDebuffs);
			If(Global.Difficulty[2] >= 3);
				Event Player.MoveSpeedBuffs[5] = 40;
				Event Player.ShouldUpdateMoveSpeed = True;
			End;
		Else If(Team Of(Event Player) == Team 1 && Global.Difficulty[2] >= 4);
			Event Player.HealingModifiers[5] = Vector(1, 0.500, 0);
			Event Player.ShouldUpdateHealing = True;
		End;
		Event Player.State = Custom String("IndividualSetup");
		If(Event Player.IsBoss);
			Start Rule(BossSetup, Do Nothing);
		Else If(Event Player.IsHero);
			Start Rule(HeroSetup, Do Nothing);
		Else If(Event Player.IsMook);
			Start Rule(AddSetup, Do Nothing);
		End;
	}
}

rule("Player Setup")
{
	event
	{
		Subroutine;
		PrepareForDebuffs;
	}

	actions
	{
		Event Player.NewBurnInfo = Empty Array;
		Create Effect(Event Player.DebuffFocusTime > 0 && (Event Player.Visibility[0] || Event Player.Visibility[1]) ? All Players(
			All Teams) : Null, Sigma Gravitic Flux Target Effect, Color(White), Event Player, 4.500, Visible To Position and Radius);
		Modify Global Variable(Entities, Append To Array, Array(Event Player.Ids[1], 0, Last Created Entity));
		Chase Player Variable At Rate(Event Player, SlowTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, DebuffFocusTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, BleedTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, BurnTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, APTime, 0, 1, None);
	}
}

rule("Update Difficulty Coefficient (And Boss Level)")
{
	event
	{
		Subroutine;
		SetCoefficient;
	}

	actions
	{
		"{1, 1.3, 1.6, ...} + "
		Global.Difficulty[1] = (Global.PlayerFactor + ((Global.OverallPlayerLevel - 2.250) / (Global.Difficulty[2] < 5 ? 0.395 : 0.357) + (Total Time Elapsed - Global.BuyPhaseSettings[2]) / 60)
			* Global.TimeFactor) * 1.150 ^ Global.StagesCompleted;
		Global.OverallBossLevel = 1 + 3 * (Global.Difficulty[1] - Global.PlayerFactor);
	}
}

rule("Identify Heroes")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.Ids[1] = Random Integer(-9999999, 9999999);
		Log To Inspector(Custom String("hero joined"));
		Event Player.Role = Custom String("Hero");
		Event Player.IsHero = True;
		Event Player.IsCharacterBody = True;
		Event Player.Master[0] = Event Player;
		Start Rule(PlayerSetup, Do Nothing);
	}
}

rule("Team 1 Setup")
{
	event
	{
		Subroutine;
		HeroSetup;
	}

	actions
	{
		Event Player.Ids[0] = Custom String("{0}", Event Player);
		Event Player.ShowItemNames = True;
		Event Player.UltCharges = Array(0, 1);
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Chase Player Variable At Rate(Event Player, CrippleTime, 0, 1, None);
		Call Subroutine(UpdateStats);
		Event Player.Currency = Workshop Setting Integer(Custom String("Difficulty"), Custom String("£ per level"), 140, 0, 150, 1)
			* Round To Integer(Event Player.Level, To Nearest);
		Create Effect(Event Player.CrippleTime > 0 && (Event Player.Visibility[0] || Event Player.Visibility[1]) ? All Players(All Teams)
			: Null, Good Aura, Color(Sky Blue), Eye Position(Event Player), 1, Visible To Position and Radius);
		If(Global.Difficulty[0] == 1);
			Event Player.ArmourModifiers[3] = 70;
		End;
		Create Effect(Global.State == Custom String("Buy") && Is True For Any(Global.ItemShopPositions, Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Current Array Element) < 1.500) ? Event Player : Null, Sphere, Color(Yellow), Sorted Array(
			Global.ItemShopPositions, Distance Between(Current Array Element, Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False)))[0], 0.600,
			Visible To Position Radius and Color);
		Create HUD Text(Global.State == Custom String("Buy") ? Event Player : Null, Custom String("£{0}", Event Player.Currency), Null,
			Global.BuyPhaseSettings[3] ? Max(0, Round To Integer(Global.BuyPhaseSettings[2] - Total Time Elapsed, Up)) : Custom String(""), Left, 1.100, Color(Yellow), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Global.State == Custom String("Buy") && Is True For Any(Global.ItemShopPositions, Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Current Array Element) < 1.500) ? Event Player : Null, Global.ItemShops[Sorted Array(Mapped Array(
			Global.ItemShopPositions, Current Array Index), Distance Between(Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False),
			Global.ItemShopPositions[Current Array Element]))[0]], Global.ItemShopRarities[Sorted Array(Mapped Array(
			Global.ItemShopPositions, Current Array Index), Distance Between(Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False),
			Global.ItemShopPositions[Current Array Element]))[0]] < 4 ? Custom String("[{0}] Buy", Input Binding String(Button(Interact)))
			: Custom String(" "), Custom String("£{0}", Global.ItemShopPrices[Sorted Array(Mapped Array(Global.ItemShopPositions,
			Current Array Index), Distance Between(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 4 * Facing Direction Of(Event Player), Null, Event Player, False), Global.ItemShopPositions[Current Array Element]))[0]]),
			Top, 1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Global.State == Custom String("Buy") && Is True For Any(Global.ItemShopPositions, Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Current Array Element) < 1.500) ? Event Player : Null, Null, Global.ItemShopDescriptions[Sorted Array(
			Mapped Array(Global.ItemShopPositions, Current Array Index), Distance Between(Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False),
			Global.ItemShopPositions[Current Array Element]))[0]], Null, Top, 1.100, Color(White), Color(Black), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Event Player.CameraPosition == Null && (Event Player.UltCharges[1] > 1 || Event Player.UltCharges[0] > 1)
			? Event Player : Null, Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Mapped Array(Round To Integer(
			Event Player.UltCharges[4] - Total Time Elapsed - 1.500, Up), Current Array Element <= 0 ? Custom String(" ")
			: Current Array Element), Event Player.UltCharges[0], Right, 1.100, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Event Player.Target[0].ShowBossInfo[0] ? Event Player : Null, Null, Custom String("{0}{1}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}",
			Event Player.Target[0].BlastCooldown ? Custom String("{0}×{1} ", Icon String(Asterisk), Round To Integer(Event Player.Target[0].BlastCooldown, Up))
			: Custom String(""), Event Player.Target[0].BarrierInfo[0] && Event Player.Target[0].BarrierInfo[1] < Total Time Elapsed ? Custom String("{0} ", Icon String(Ring Thick))
			: Custom String(""), Event Player.Target[0].DebuffShield[0] > 0 ? Custom String("Θ×{0} ", Event Player.Target[0].DebuffShield[0]) : Custom String(
			"")), Event Player.Target[0].RecoveryTime ? Custom String("{0} ", Icon String(Plus)) : Custom String(""), Event Player.Target[0].StealthTime[1] ? Custom String(
			"{0}{1} ", Icon String(Eye), Event Player.Target[0].Visibility[0] || Event Player.Target[0].Visibility[1] ? Custom String("") : Max(1,
			Round To Integer(Event Player.Target[0].StealthTime[1] - Total Time Elapsed, Up))) : Custom String("")), Custom String("{0}{1}{2}", Custom String("{0}{1}", Event Player.Target[0].BurnTime ? Custom String("{0} ", Icon String(Fire)) : Custom String(""),
			Event Player.Target[0].CrippleTime ? Custom String("{0} ", Icon String(Skull)) : Custom String("")), Custom String("{0}{1}{2}",
			Event Player.Target[0].SlowTime ? Custom String("{0} ", Icon String(Arrow: Down)) : Custom String(""), Event Player.Target[0].DebuffFocusTime ? Custom String("{0} ", Ability Icon String(Hero(
			Zenyatta), Button(Ability 2))) : Custom String(""), Event Player.Target[0].MaxHealthReduction[0] ? Custom String("{0}×{1} ", Icon String(Poison), Event Player.Target[0].MaxHealthReduction[0]) : Custom String("")), Custom String("{0}{1}{2}", Event Player.Target[0].BleedInfo[0] ? Custom String(
			"†×{0} ", Event Player.Target[0].BleedInfo[0]) : Custom String(""), Event Player.Target[0].ArmourPiercingStacks[0] ? Custom String("Ѳ×{0} ",
			Event Player.Target[0].ArmourPiercingStacks[0]) : Custom String(""), Event Player.Target[0].ArmourPiercingStacks[1] ? Custom String("Ø×{0} ",
			Event Player.Target[0].ArmourPiercingStacks[1]) : Custom String("")))), Null, Top, 1, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create Progress Bar HUD Text(Event Player.Target[0].ShowBossInfo[0] ? Event Player : Empty Array, 100 * (
			Event Player.Target[0].CachedHealth[1] ? Event Player.Target[0].CachedHealth[2] : Health(Event Player.Target[0])
			+ Event Player.Target[0].BarrierHealth) / (
			Event Player.Target[0].CachedHealth[1] ? Event Player.Target[0].CachedHealth[3] : Max Health(Event Player.Target[0])), String(
			"{0} / {1}", Max(1, Round To Integer(1 + (((Event Player.Target[0].CachedHealth[1] ? Event Player.Target[0].CachedHealth[2] : Health(Event Player.Target[0])) - 1) / (Max Health(Event Player.Target[0])  - 1)) * (Max Health(Event Player.Target[0]) / Event Player.Target[0].HealthScale[0] - 1) + Event Player.Target[0].BarrierHealth / Event Player.Target[0].HealthScale[0], To Nearest)), Round To Integer((
			Event Player.Target[0].CachedHealth[1] ? Event Player.Target[0].CachedHealth[3] : Max Health(Event Player.Target[0]))
			/ Event Player.Target[0].HealthScale[0], To Nearest)), Top, 1.100, Color(Red), Color(White), Visible To and Values,
			Default Visibility);
		Create HUD Text(Event Player.Target[0].ShowBossInfo[0] ? Event Player : Null, Null, Null, Event Player.Target[0], Top, 1.200,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Set Ultimate Ability Enabled(Event Player, False);
		Event Player.State = Custom String("Ready");
		Event Player.IsSetup = True;
	}
}

rule("Is using ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}
	
	conditions
	{
		((Hero Of(Event Player) == Hero(Echo)) ? Is Duplicating (Event Player) : Is Using Ultimate(Event Player)) == True;
	}
	
	actions
	{
		Event Player.IsUsingUltimate = True;
		Wait Until(!((Hero Of(Event Player) == Hero(Echo)) ? Is Duplicating(Event Player) : Is Using Ultimate(Event Player)), 99999);
		Event Player.IsUsingUltimate = False;
	}
}

rule("Is Duplicating")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Echo;
	}
	
	conditions
	{
		Is Duplicating(Event Player) == True;
	}
	
	actions
	{
		Event Player.Hero[0] = Hero Being Duplicated(Event Player);
		Event Player.Hero[1] = Index Of Array Value(Global.AllHeroes, Event Player.Hero[0]);
		Wait Until(!Is Duplicating(Event Player), 99999);
		Event Player.Hero[0] = Hero Of(Event Player);
		Event Player.Hero[1] = Index Of Array Value(Global.AllHeroes, Event Player.Hero[0]);
	}
}

rule("Team 1 Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Abort If(Is Dummy Bot(Event Player));
		Abort If(Array Contains(Global.Heroes, Event Player));
		Teleport(Event Player, Vector(Random Real(105, 115), 0, Random Real(-19, 19)));
		Set Facing(Event Player, Direction From Angles(Horizontal Angle Towards(Event Player, Vector(0, 0, 0)), 0), To Player);
	}
}

rule("Enable OSP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) - Event Player.MaxHealthReduction[1] > 0.900;
	}

	actions
	{
		Set Status(Event Player, Null, Unkillable, 9999);
	}
}

rule("Disable OSP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) - Event Player.MaxHealthReduction[1] <= 0.900;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Clear Status(Event Player, Unkillable);
	}
}

rule("Enforce max health reduction")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Health(Event Player) > Max Health(Event Player) * (1 - Event Player.MaxHealthReduction[1]);
	}

	actions
	{
		Wait(0.050, Abort When False);
		Set Player Health(Event Player, Max Health(Event Player) * (1 - Event Player.MaxHealthReduction[1]));
		Wait(0.050, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Enforce max health reduction")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Health(Event Player) >= Max Health(Event Player) * (1 - Event Player.MaxHealthReduction[1]) - 1;
	}

	actions
	{
		Set Healing Received(Event Player, 0);
	}
}

rule("Enforce max health reduction")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Health(Event Player) < Max Health(Event Player) * (1 - Event Player.MaxHealthReduction[1]) - 1;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Set Healing Received(Event Player, 100 * Event Player.HealthScale[2]);
	}
}

rule("Determine Acceleration")
{
	event
	{
		Subroutine;
		DetermineAcceleration;
	}
	
	actions
	{
		If(Magnitude Of(Event Player.WispAcceleration) + Event Player.WallAcceleration > 0);
			Start Accelerating(Event Player, Event Player.WispAcceleration - Event Player.WallAcceleration * Direction From Angles(
				Horizontal Angle From Direction(Position Of(Event Player)), 0), Magnitude Of(
				Event Player.WispAcceleration - Event Player.WallAcceleration * Direction From Angles(Horizontal Angle From Direction(
				Position Of(Event Player)), 0)), 60, To World, Direction Rate and Max Speed);
		Else;
			Stop Accelerating(Event Player);
		End;
	}
}

rule("Inwards")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.IsSetup == True;
		Global.State == Custom String("BossFight");
		Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) > Global.ArenaRadius;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, WallAcceleration, (Is On Ground(Event Player) ? 400 : 0) + Max(0,
			18 * Speed Of In Direction(Event Player, Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 81 * (
			Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 1 - Global.ArenaRadius)),
			1000000000, Destination and Rate);
		Start Rule(DetermineAcceleration, Restart Rule);
		Start Throttle In Direction(Event Player, Direction Towards(Event Player, Vector(0, 0, 0)), 2 * Max(0, Dot Product(World Vector Of(
			Throttle Of(Event Player), Event Player, Rotation), Direction From Angles(Horizontal Angle From Direction(Position Of(
			Event Player)), 0))), To World, Add to existing throttle, Direction and Magnitude);
		Log To Inspector(Custom String("{0}: inwards", Event Player.Ids[0]));
	}
}

rule("Not Inwards")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.IsSetup == True;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, WallAcceleration);
		Event Player.WallAcceleration = 0;
		Start Rule(DetermineAcceleration, Restart Rule);
	}
}

rule("Update Move Speed (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateMoveSpeed == True;
	}

	actions
	{
		Wait(0.080, Ignore Condition);
		Event Player.ShouldUpdateMoveSpeed = False;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Update Move Speed")
{
	event
	{
		Subroutine;
		UpdateMoveSpeed;
	}

	actions
	{
		Event Player.MoveSpeedBuffs[1] = 1;
		Event Player.MoveSpeedDebuffs[1] = 1;
		For Player Variable(Event Player, MoveSpeedIndex, 2, Count Of(Event Player.MoveSpeedBuffs), 1);
			"2: Sprint, 3: Speed Item, 4: Stealth bonus, 5: Extra Hard Enemy Speed"
			Event Player.MoveSpeedBuffs[1] += Event Player.MoveSpeedBuffs[Event Player.MoveSpeedIndex] / 100;
		End;
		For Player Variable(Event Player, MoveSpeedIndex, 2, Count Of(Event Player.MoveSpeedDebuffs), 1);
			"2: Cripple, 3: Slow"
			Event Player.MoveSpeedDebuffs[1] += Event Player.MoveSpeedDebuffs[Event Player.MoveSpeedIndex] / 100;
		End;
		Event Player.MoveSpeedBuffs[0] = Event Player.MoveSpeedBuffs[1];
		Event Player.MoveSpeedDebuffs[0] = Event Player.MoveSpeedDebuffs[1];
		Set Move Speed(Event Player, Event Player.BaseMoveSpeedModifier * (
			Event Player.MoveSpeedBuffs[0] / Event Player.MoveSpeedDebuffs[0]));
	}
}

rule("Update Damage Received (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateDamageReceived == True;
	}

	actions
	{
		Wait(0.050, Ignore Condition);
		Event Player.ShouldUpdateDamageReceived = False;
		Start Rule(UpdateDamageReceived, Restart Rule);
	}
}

rule("Update Damage Received")
{
	event
	{
		Subroutine;
		UpdateDamageReceived;
	}

	actions
	{
		Event Player.ArmourModifiers[0] = 0;
		For Player Variable(Event Player, ArmourIndex, 1, Count Of(Event Player.ArmourModifiers), 1);
			"1: Armour Boost, 2: Cripple, 3: Easy Mode, 4: Armour Piercing, 5: Armour Reduction, 6: Barrier"
			Event Player.ArmourModifiers[0] += Event Player.ArmourModifiers[Event Player.ArmourIndex];
		End;
		"Not including HealthScale, actual multiplier"
		Event Player.DamageReceivedMultiplier = Mapped Array(Array(1, Event Player.HealthScale[5] * Event Player.HealthScale[2]),
			Current Array Element * (Event Player.DebuffFocusTime > 0 ? 1.500 : 1) * (1 - Event Player.ArmourModifiers[0] / (100 + Absolute Value(
			Event Player.ArmourModifiers[0]))));
		Set Damage Received(Event Player, 100 * Event Player.DamageReceivedMultiplier[1]);
	}
}

rule("Update Crit (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Crit[3] == True;
	}

	actions
	{
		Event Player.Bots[0].Crit[3] = True;
		Wait(0.100, Ignore Condition);
		Event Player.Crit[3] = False;
		Start Rule(UpdateCrit, Restart Rule);
	}
}

rule("Update Crit")
{
	event
	{
		Subroutine;
		UpdateCrit;
	}

	actions
	{
		Event Player.Crit[4] = Event Player.Crit[0] ? 0 : 1;
		Event Player.Crit[5] = Event Player.Crit[0] ? 0 : 100;
		Event Player.Crit[6] = 7;
		"7: Common Crit %, 8: Rare Heal on Crit, 9: Legendary Extra Crit Damage, 10: Bloody Crit Explosion"
		While(Event Player.Crit[6] < Count Of(Event Player.Master[0].Crit));
			If(Event Player.Crit[0]);
				Event Player.Crit[5] += X Component Of(Event Player.Master[0].Crit[Event Player.Crit[6]]) + Y Component Of(
					Event Player.Master[0].Crit[Event Player.Crit[6]]);
			Else;
				Event Player.Crit[4] += X Component Of(Event Player.Master[0].Crit[Event Player.Crit[6]]);
				Event Player.Crit[5] += Y Component Of(Event Player.Master[0].Crit[Event Player.Crit[6]]);
			End;
			Event Player.Crit[6] += 1;
		End;
		Event Player.Crit[1] = Event Player.Crit[4] / 100;
		Event Player.Crit[2] = Event Player.Crit[5] / 100;
	}
}

rule("Update Healing (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateHealing == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Event Player.ShouldUpdateHealing = False;
		Start Rule(UpdateHealing, Restart Rule);
	}
}

rule("Update Healing")
{
	event
	{
		Subroutine;
		UpdateHealing;
	}

	actions
	{
		"Applied to all healing, Intended multiplier for healing items, regen cumulative, healing cumulative, ..."
		Event Player.HealingModifiers[2] = 0;
		Event Player.HealingModifiers[3] = 1;
		For Player Variable(Event Player, HealingIndex, 4, Count Of(Event Player.HealingModifiers), 1);
			"4: Rock, 5: Extra Hard Mode"
			If(X Component Of(Event Player.HealingModifiers[Event Player.HealingIndex]) == 1);
				Event Player.HealingModifiers[3] *= Y Component Of(Event Player.HealingModifiers[Event Player.HealingIndex]);
			Else;
				Event Player.HealingModifiers[2] += Y Component Of(Event Player.HealingModifiers[Event Player.HealingIndex]);
			End;
		End;
		Event Player.HealingModifiers[2] *= 1 + 0.200 * (Event Player.Level - 1);
		Event Player.HealingModifiers[2] += Event Player.BaseRegen;
		"(HealthScale[2] is factored in elsewhere) * Intended Regen * Healing Multiplier * Difficulty Multiplier / OW Regen"
		Event Player.HealingModifiers[0] = Event Player.HealthScale[0] * Event Player.HealingModifiers[2] * Event Player.HealingModifiers[3] * Array(1.500, 1, 0.600)
			[Global.Difficulty[0] - 1] / 15;
		Event Player.HealingModifiers[1] = Event Player.HealingModifiers[3] / (Event Player.HealingModifiers[0]);
	}
}

rule("Cap Maximum Health")
{
	event
	{
		Subroutine;
		CapMaxHealth;
	}

	actions
	{
		Event Player.HealthScale[4] = Event Player.TotalHPUnits;
		Event Player.HealthScale[2] = Min(Event Player.HealthScale[2], 3998.500 / Event Player.HealthScale[4]);
		Start Rule(UpdateDamageReceived, Restart Rule);
		Event Player.TotalHPUnits *= Event Player.HealthScale[2];
		If(Event Player.TotalHPUnits == 0);
			Small Message(Host Player, Custom String("Error setting TotalHPUnits"));
			Wait(5, Ignore Condition);
		End;
		Event Player.HealthScale[0] = Event Player.HealthScale[3] * Event Player.HealthScale[2];
	}
}

rule("Calculate Stats")
{
	event
	{
		Subroutine;
		CalculateStats;
	}

	actions
	{
		If(Event Player.IsHero);
			Event Player.Level = Round To Integer(Global.OverallPlayerLevel, Down);
			Event Player.TotalHPUnits = Event Player.HealthScale[3] * Event Player.DefaultHealth[0] * (90 / 150) * (1 + 0.300 * (
				Event Player.Level - 1)) / 25;
			Event Player.BaseDamageMultiplier[0] = 1 + 0.200 * (Event Player.Level - 1);
			Event Player.BaseDamageMultiplier[1] = Array(10, 16, 15, 10, 12, 16, 13, 13, 15, 12, 16, 16, 13, 10, 13, 10, 10, 11, 10, 13, 10, 16, 15, 16, 14, 16, 13, 13, 13, 14, 12, 16, 12, 10, 14, 10)[Index Of Array Value(Global.AllHeroes, Hero Of(Event Player))] * Event Player.BaseDamageMultiplier[0];
		Else If(Event Player.IsBoss);
			Call Subroutine(SetCoefficient);
			Event Player.Level = Min(99, Round To Integer(Global.OverallBossLevel, Down));
			If(Global.Phase < 2);
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[3] * (1000 + 300 * (Event Player.Level - 1)) * Global.Difficulty[3] / Global.BossCount / 25;
				If(Event Player.TotalHPUnits == 0);
					Small Message(Host Player, Custom String("Error setting TotalHPUnits"));
					Wait(5, Ignore Condition);
				End;
				Event Player.BaseDamageMultiplier[1] = Global.Difficulty[4] * (16 + 3.200 * (Event Player.Level - 1)) * Global.HealthScalar;
			Else If(Global.Phase == 3);
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[3] * (1000 + 300 * (Event Player.Level - 1)) * Global.Difficulty[3] / Global.BossCount / 25;
				Event Player.BaseDamageMultiplier[1] = Global.Difficulty[4] * (16 + 3.200 * (Event Player.Level - 1)) * Global.HealthScalar;
			Else If(Global.Phase == 4);
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[3] * (14 + Workshop Setting Integer(Custom String("Difficulty"), Custom String("Last Phase Relative Difficulty"), 3, -4, 6, 2)) * (100 + 30 * (Event Player.Level - 1)) / Global.BossCount / 25;
				Event Player.BaseDamageMultiplier[1] = (3 + 0.600 * (Event Player.Level - 1)) * Global.HealthScalar;
			End;
			Event Player.BaseDamageMultiplier[0] = 2 * Event Player.BaseDamageMultiplier[1] / 85;
		Else If(Event Player.IsMook);
			Event Player.Level = Min(99, Round To Integer(Global.OverallBossLevel, Down));
			If(Hero Of(Event Player) == Hero(Wrecking Ball));
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[3] * (180 + 54 * (Event Player.Level - 1)) / Global.BossCount / 25;
				"50% damage at level 17 (expected BossLevel for phase 2 on hard difficulty)"
				Event Player.BaseDamageMultiplier[1] = Global.HealthScalar * (11 + 2.2 * (Event Player.Level - 1));
				Event Player.BaseDamageMultiplier[0] = Event Player.BaseDamageMultiplier[1] / 55.44;
			Else If(Hero Of(Event Player) == Hero(Zenyatta));
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[3] * (1615 + 485 * (Event Player.Level - 1)) / Global.BossCount / 25;
				Event Player.BaseDamageMultiplier[1] = Global.HealthScalar * (35 + 7 * (Event Player.Level - 1));
				Event Player.BaseDamageMultiplier[0] = Event Player.BaseDamageMultiplier[1] / 48;
			Else If(Hero Of(Event Player) == Hero(Tracer));
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[3] * (850 + 255 * (Event Player.Level - 1)) / Global.BossCount / 25;
				Event Player.BaseDamageMultiplier[1] = Global.HealthScalar * (15 + 3 * (Event Player.Level - 1));
				Event Player.BaseDamageMultiplier[0] = Event Player.BaseDamageMultiplier[1] / 75.600;
			End;
		End;
		Event Player.BaseDamageMultiplier[2] = Event Player.BaseDamageMultiplier[1] / Event Player.BaseDamageMultiplier[0];
		Call Subroutine(CapMaxHealth);
		Event Player.BaseRegen = (Global.HealthScalar / 0.600) * 15 / Event Player.HealthScale[3] * (5 + (Event Player.Level - 1)) / 24;
	}
}

rule("Update Max HPs, healing and damage (after setting TotalHPUnits, BaseDamageMultiplier[0] and BaseRegen)")
{
	event
	{
		Subroutine;
		UpdateStats;
	}

	actions
	{
		Call Subroutine(CalculateStats);
		If(Event Player.IsBoss);
			If(Event Player.CachedHealth[0]);
				Event Player.CachedHealth[2] = Health(Event Player);
				Event Player.CachedHealth[3] = Max Health(Event Player);
				Event Player.CachedHealth[1] = True;
			End;
			If(Event Player.TotalHPUnits == 0);
				Small Message(Host Player, Custom String("Error reading TotalHPUnits"));
				Wait(5, Ignore Condition);
			End;
			Event Player.IntendedMaxHealth = Mapped Array(Array(0.533, 0.467), Event Player.TotalHPUnits * Current Array Element);
			Set Damage Dealt(Event Player.Bots[0], 100 * (Event Player.BaseDamageMultiplier[1] * 0.600 * 12) / ((12 - 3 * (Global.Difficulty[0] - 1)) * 12));
		Else;
			If(Event Player.IsHero);
				Event Player.IntendedMaxHealth[1] = Event Player.TotalHPUnits * Event Player.DefaultHealth[2] / Event Player.DefaultHealth[0];
				Event Player.IntendedMaxHealth[0] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1]) * (
					Event Player.DefaultHealth[1] + 0.600 * Event Player.DefaultHealth[3]) / (
					Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
				Event Player.IntendedMaxHealth[2] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1])
					* Event Player.DefaultHealth[3] * 0.400 / (Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
			Else If(Event Player.IsMook);
				Event Player.IntendedMaxHealth[1] = Event Player.TotalHPUnits * Event Player.DefaultHealth[2] / (
					Event Player.DefaultHealth[0] + Event Player.DefaultHealth[2] * 0.429);
				Event Player.IntendedMaxHealth[0] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1] / 0.700) * (
					Event Player.DefaultHealth[1] + 0.600 * Event Player.DefaultHealth[3]) / (
					Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
				Event Player.IntendedMaxHealth[2] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1] / 0.700)
					* Event Player.DefaultHealth[3] * 0.400 / (Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
				If(Hero Of(Event Player) == Hero(Wrecking Ball));
					Set Max Ammo(Event Player, 0, Round To Integer(Event Player.Level, To Nearest) + 3);
				End;
			End;
		End;
		Event Player.IntendedMaxHealth = Mapped Array(Event Player.IntendedMaxHealth, Round To Integer(Current Array Element, Up));
		Event Player.HealthScale[1] = Max(Min(Sorted Array(Remove From Array(Mapped Array(Event Player.IntendedMaxHealth,
			Current Array Element / (Event Player.DefaultHealth[Current Array Index + 1] / 25)), 0), Current Array Element)[0], 10),
			0.010);
		Set Max Health(Event Player, Event Player.HealthScale[1] * 100);
		Event Player.NormalExtraHealth = Mapped Array(Event Player.IntendedMaxHealth,
			Current Array Element * 25 - Event Player.DefaultHealth[Current Array Index + 1] * Event Player.HealthScale[1]);
		Set Damage Dealt(Event Player, Event Player.BaseDamageMultiplier[0] * 100);
		Call Subroutine(UpdateHealing);
		Wait(0.250, Ignore Condition);
		While(Count Of(Event Player.NormalExtraHealthPools) > 0);
			Remove Health Pool From Player(Event Player.NormalExtraHealthPools[0]);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Remove From Array By Index, 0);
		End;
		Set Player Health(Event Player, 100000);
		For Player Variable(Event Player, HealthPoolIndex, 0, Min(9, Round To Integer(Event Player.NormalExtraHealth[0] / 9999, Down)), 1);
			Add Health Pool To Player(Event Player, Health, 9999, True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Event Player.NormalExtraHealth[3] = Event Player.NormalExtraHealth[0] % 9999;
		If(Event Player.NormalExtraHealth[3] >= 1);
			Add Health Pool To Player(Event Player, Health, Event Player.NormalExtraHealth[3], True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		For Player Variable(Event Player, HealthPoolIndex, 0, Min(10, Round To Integer(Event Player.NormalExtraHealth[1] / 9999, Down)),
			1);
			Add Health Pool To Player(Event Player, Armor, 9999, True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Event Player.NormalExtraHealth[3] = Event Player.NormalExtraHealth[1] % 9999;
		If(Event Player.NormalExtraHealth[3] >= 1);
			Add Health Pool To Player(Event Player, Armor, Event Player.NormalExtraHealth[3], True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		For Player Variable(Event Player, HealthPoolIndex, 0, Min(9, Round To Integer(Event Player.NormalExtraHealth[2] / 9999, Down)), 1);
			Add Health Pool To Player(Event Player, Shields, 9999, True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Event Player.NormalExtraHealth[3] = Event Player.NormalExtraHealth[2] % 9999;
		If(Event Player.NormalExtraHealth[3] >= 1);
			Add Health Pool To Player(Event Player, Shields, Event Player.NormalExtraHealth[3], True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Wait(0.250, Ignore Condition);
		Modify Player Variable(Event Player, NormalExtraHealth, Remove From Array By Index, 3);
		If(Event Player.CachedHealth[0]);
			Event Player.CachedHealth[4] = Has Status(Event Player, Phased Out);
			Clear Status(Event Player, Phased Out);
			Event Player.CachedHealth[5] = Max Health(Event Player) - (Event Player.CachedHealth[3] - Event Player.CachedHealth[2]);
			If(Event Player.CachedHealth[5] < 0);
				Small Message(Host Player, Custom String("Error reading CachedHealth[5]"));
				Wait(5, Ignore Condition);
			End;
			Log To Inspector(Custom String("{0}: {1} -> {2}", Event Player, Custom String("{0} / {1}", Event Player.CachedHealth[2],
				Event Player.CachedHealth[3]), Custom String("{0} / {1}", Event Player.CachedHealth[5], Max Health(Event Player))));
			Set Player Health(Event Player, Event Player.CachedHealth[5]);
			If(Event Player.CachedHealth[4]);
				Set Status(Event Player, Null, Phased Out, 9999);
			End;
			Event Player.CachedHealth[1] = False;
			Event Player.CachedHealth[0] = False;
		End;
	}
}

rule("On hit effects")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	actions
	{
		"Killer, Cause"
		Victim.CauseOfDeath = Array(Attacker.IsNullPlayer ? Victim.CauseOfDeath[0] : Attacker.Master[0], Event Ability == Null ? Victim.CauseOfDeath[1] : Ability Icon String(Attacker.Hero[0], Event Ability));
		"Show cause of death HUD, Event Damage, Killer Hero, Killer Name"
		Victim.ExtraDeathInfo = Array(False, Event Damage, Hero Of(Victim.CauseOfDeath[0]), Victim.CauseOfDeath[0].Ids[0]);
		If(Attacker.IsHero && Victim.IsBoss);
			If(Attacker.Target[0] != Victim && Total Time Elapsed > Attacker.Target[1]);
				Attacker.Target = Array(Victim, Total Time Elapsed + 1.500);
			End;
			If(Attacker.Hero[0] == Hero(Hanzo) && Event Ability == Button(Ability 1));
				Event Player.Visibility[2] = Total Time Elapsed + 6;
			End;
		End;
		If(Attacker.Master[1] != Null);
			Damage(Victim, Attacker.Master[1], 0.001);
			If(Event Was Critical Hit);
				Play Effect(Attacker.Master[1], Brigitte Repair Pack Armor Sound, Color(White), Eye Position(Attacker), 100);
			Else;
				Play Effect(Attacker.Master[1], Widowmaker Venom Mine Explosion Sound, Color(White), Eye Position(Attacker), 100);
			End;
		End;
		If(Victim.IsMook);
			If(Attacker != Global.NullPlayer[0] && Victim.Master[1] == Null && Victim.Target[0] != Null && Is Alive(Victim) && Is Alive(
				Attacker) && (Attacker.Visibility[0] || Attacker.Visibility[1]) && Random Real(0, 1) < Event Damage / Max Health(Victim)
				* Normalized Health(Victim.Target[0]));
				Victim.Target[0] = Attacker;
				Victim.Target[1] = Eye Position(Attacker);
				Victim.Target[2] = Total Time Elapsed + 2;
			End;
		Else;
			If(Victim.BarrierHealth > 0);
				Heal(Victim, Null, (Event Damage - Max(Event Damage * (1 + Victim.BarrierHealth / (Health(Victim) + Event Damage))
					- Victim.BarrierHealth, 0)) / Victim.HealthScale[2]);
				Victim.BarrierHealth = Max(0, Victim.BarrierHealth - Event Damage * (1 + Victim.BarrierHealth / Health(Victim)));
			End;
			If(Is Alive(Victim));
				If(Victim.MyItemStackSizes[20]);
					Victim.BarrierInfo[1] = Total Time Elapsed + 7;
				End;
				"Egg"
				If(Victim.MyItemStackSizes[14] && Random Real(0, 1) < 0.500);
					Heal(Victim, Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Victim))],
						Victim.HealthScale[0] * Victim.MyItemStackSizes[14] * 15 * Victim.HealingModifiers[1]);
				End;
				If(Victim.MyItemStackSizes[11]);
					Victim.RecoveryTime = 2;
				End;
			End;
			"Retaliation"
			If(Team Of(Victim) == Team 1 && Random Real(0, 1) < 0.250 && Victim.MyItemStackSizes[29]);
				Modify Global Variable(DamageBeamInfo, Append To Array, Array(Custom String("Retaliation"), Victim, 320 / 14, Victim));
				Modify Global Variable(DamageBeamInfo, Append To Array, Array Slice(Randomized Array(Filtered Array(Players Within Radius(Victim,
					7.500 + 13 * (Victim.MyItemStackSizes[29] - 1), Opposite Team Of(Team Of(Victim)),
					Surfaces And Enemy Barriers), Current Array Element != Victim && Is Alive(Current Array Element) && !Has Status(
					Current Array Element, Phased Out) && Current Array Element.IsCharacterBody)), 0, 5 + 2 * (Victim.MyItemStackSizes[29] - 1)));
				Modify Global Variable(DamageBeamInfo, Append To Array, Custom String("0%END"));
			End;
			If(Victim.IsBoss && Global.Phase == 4 && Victim.State != Custom String("Absent"));
				Victim.Phase4DamageReceived += Event Damage / Max Health(Victim);
				Modify Player Variable(Victim, Phase4DamageReceived, Max, 1 - Normalized Health(Victim));
			End;
		End;
		If(Attacker.Master[0].MyItemStacks[0] == Null);
			disabled Log To Inspector(Custom String("{0} has no items", Attacker.Master[0]));
		Else If(Attacker.Master[0] == Victim);
			Log To Inspector(Custom String("{0} is also the victim", Attacker.Master[0]));
		Else;
			If(Is Alive(Victim));
				"Debuff Focus"
				If(Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons, Event Ability),
					Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)[0] + 1],
					Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
					Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
					Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)
					[0] > 0 && Attacker.Master[0].MyItemStackSizes[28]
					&& Victim.DebuffFocusTime == 0 && Count Of(Filtered Array(Array(Victim.SlowTime > 0, Victim.BleedTime > 0, Victim.BurnTime > 0, Has Status(Victim,
					Hacked), Has Status(Victim, Frozen), Has Status(Victim, Asleep), Has Status(Victim, Knocked Down), Has Status(Victim, Rooted),
					Victim.CrippleTime > 0, Victim.ArmourPiercingStacks[0] > 0, Victim.ArmourPiercingStacks[1] > 0), Current Array Element)) >= 4);
					If(Victim.DebuffShield[0] > 0);
						Victim.DebuffShield[0] -= 1;
						Victim.DebuffShield[3] += 1;
					Else;
						Modify Player Variable(Victim, DebuffFocusTime, Max, 7 * Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(
							Global.Buttons, Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons)
							+ Current Array Element)[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
							Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
							Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0]);
						Victim.ShouldUpdateDamageReceived = True;
					End;
				End;
				"Crit and bonus close range damage"
				If(Attacker.Crit[0] ? Event Was Critical Hit : !((Attacker.Hero[0] == Hero(Sombra) && Event Ability == Button(Ultimate)) || (
					Attacker.Hero[0] == Hero(Sigma) && Event Ability == Button(Ultimate))) && Random Real(0, 1) < Attacker.Crit[1]);
					Damage(Victim, Null, Event Damage * ((1 + Attacker.Crit[2] / (Attacker.Crit[0] ? (Attacker.Hero[0] == Hero(Kiriko) ? 3 : (
						Attacker.Hero[0] == Hero(Sojourn) && Event Ability == Button(Primary Fire) ? 1.500 : (Attacker.Hero[0] == Hero(Widowmaker)
						&& Is Firing Secondary(Attacker) ? 2.500 : 2))) : 1)) * (1 + (Attacker.Master[0].MyItemStackSizes[6] && Distance Between(Eye Position(Attacker.Master[0]), Eye Position(Victim))
						< 13 ? 0.200 * Attacker.Master[0].MyItemStackSizes[6] : 0)) - 1) / Victim.DamageReceivedMultiplier[1]);
					If(!Event Was Critical Hit);
						Play Effect(Attacker.Master[0], Brigitte Repair Pack Armor Sound, Color(White), Eye Position(Attacker.Master[0]), 100);
					End;
					"Heal on Crit"
					If(Attacker.Master[0].MyItemStackSizes[25]);
						Heal(Attacker.Master[0], Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Attacker.Master[0]))],
							Attacker.Master[0].HealthScale[0] * (4 + 4 * Attacker.Master[0].MyItemStackSizes[25]) * Mapped Array(Global.ProcCoefs[Mapped Array(
							Index Of Array Value(Global.Buttons, Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(
							Global.Buttons) + Current Array Element)[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200,
							Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200)
							: Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)
							[0] * Attacker.Master[0].HealingModifiers[1]);
					End;
					"Crit bleed"
					If(Attacker.Master[0].MyItemStackSizes[27] && Is Alive(Victim));
						If(Victim.DebuffShield[0] > 0);
							Victim.DebuffShield[0] -= 1;
							Victim.DebuffShield[3] += 1;
						Else;
							Modify Player Variable(Victim, BleedTime, Max, 3 * Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons,
								Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)
								[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
								Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
								Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0]);
							Victim.BleedInfo = Array(Victim.BleedInfo[0] + 1, Max(Attacker.Master[0].BaseDamageMultiplier[1], (Attacker.Master[0].BaseDamageMultiplier[1] + Victim.BleedInfo[1])
								/ 2), Attacker.Master[0], Attacker.Master[0]);
						End;
					Else;
						Call Subroutine(NormalBleed);
					End;
					disabled Modify Global Variable(Numbers, Append To Array, Array(Total Time Elapsed + 1.250, Event Damage * 1 + ((1 + Attacker.Crit[2] / (
						Attacker.Crit[0] ? (Attacker.Hero[0] == Hero(Kiriko) ? 3 : (Attacker.Hero[0] == Hero(Sojourn) && Event Ability == Button(
						Primary Fire) ? 1.500 : (Attacker.Hero[0] == Hero(Widowmaker) && Is Firing Secondary(Attacker) ? 2.500 : 2))) : 1)) * (1 + (
						Attacker.Master[0].MyItemStackSizes[6] && Distance Between(Eye Position(
						Attacker.Master[0]), Eye Position(Victim)) < 13 ? 0.200 * Attacker.Master[0].MyItemStackSizes[6] : 0)) - 1), Attacker.Master[0], Victim, Vector(255, 0,
						0)));
				Else;
					"Close range damage (not crit)"
					If(Attacker.Master[0].MyItemStackSizes[6] && Distance Between(Eye Position(
						Attacker.Master[0]), Eye Position(Victim)) < 13);
						Damage(Victim, Null, Event Damage * 0.200 * Attacker.Master[0].MyItemStackSizes[6] / Victim.DamageReceivedMultiplier[1]);
					End;
					Call Subroutine(NormalBleed);
				End;
				If(Attacker.Master[0].MyItemStackSizes[2] && !(Victim.IsBoss
					&& Victim.State == Custom String("Dashing")));
					If(Victim.DebuffShield[0] > 0);
						Victim.DebuffShield[0] -= 1;
						Victim.DebuffShield[3] += 1;
					Else;
						Modify Player Variable(Victim, SlowTime, Max, 2 * Attacker.Master[0].MyItemStackSizes[2]);
						Start Rule(OnSlow, Do Nothing);
					End;
				End;
				"Armour Piercing"
				If(Attacker.Master[0].MyItemStackSizes[4] && Victim.ArmourPiercingStacks[0] < 5);
					If(Victim.DebuffShield[0] > 0);
						Victim.DebuffShield[0] -= 1;
						Victim.DebuffShield[3] += 1;
					Else;
						If(Victim.ArmourPiercingStacks[0] < 4);
							Victim.ArmourPiercingStacks[0] += 1;
							Modify Player Variable(Victim, APTime, Max, 2 * Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons,
								Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)
								[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
								Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
								Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0]);
						Else;
							Victim.ArmourPiercingStacks[0] += 1;
							Victim.APTime = 8 * Attacker.Master[0].MyItemStackSizes[4];
							Victim.ArmourModifiers[4] = -60;
							Victim.ShouldUpdateDamageReceived = True;
						End;
					End;
				End;
				If(Attacker.Master.MyItemStackSizes[10]);
					If(!Victim.IsBoss && Random Real(0, 1) < (1 - 1 / (0.050 * Attacker.Master[0].MyItemStackSizes[10] + 1)) * Mapped Array(Global.ProcCoefs[Mapped Array(
						Index Of Array Value(Global.Buttons, Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(
						Global.Buttons) + Current Array Element)[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200,
						Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200)
						: Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)
						[0]);
						Set Status(Victim, Attacker.Master[0], Stunned, 2);
					End;
				End;
				"Armour Reduction"
				If(Attacker.Master[0].MyItemStackSizes[13]);
					If(Victim.DebuffShield[0] > 0);
						Victim.DebuffShield[0] -= 1;
						Victim.DebuffShield[3] += 1;
					Else;
						Victim.ArmourPiercingStacks[1] += Attacker.Master[0].MyItemStackSizes[13];
						Victim.ArmourModifiers[5] = -2 * Victim.ArmourPiercingStacks[1];
						Victim.ShouldUpdateDamageReceived = True;
					End;
				End;
			End;
			If(Attacker.Master[0].BlastCooldown == 0 && Event Damage / (
				Victim.DamageReceivedMultiplier[1] * (Event Was Critical Hit ? (
				Attacker.Hero[0] == Hero(Kiriko) ? 3 : (Attacker.Hero[0] == Hero(Sojourn) && Event Ability == Button(Primary Fire) ? 1.500 : (
				Attacker.Hero[0] == Hero(Widowmaker) && Is Firing Secondary(Attacker) ? 2.500 : 2))) : 1)) >= Attacker.Master[0].BaseDamageMultiplier[1] * 4 && Mapped Array(
				Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons, Event Ability),
				Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)[0] + 1],
				Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
				Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
				Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0] > 0);
				If(Attacker.Master[0].MyItemStackSizes[7] && Is Alive(Victim));
					Attacker.Master[0].BlastCooldown = 10;
					Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Victim, 100);
					Play Effect(All Players(All Teams), Echo Sticky Bomb Explosion Effect, Color(White), Victim, 1);
					If(!(Victim.IsBoss && Victim.State == Custom String("Dashing")));
						If(Victim.DebuffShield[0] > 0);
							Victim.DebuffShield[0] -= 1;
							Victim.DebuffShield[3] += 1;
						Else;
							Modify Player Variable(Victim, SlowTime, Max, 3);
							Start Rule(OnSlow, Do Nothing);
						End;
					End;
					If(Is Alive(Victim));
						Victim.CauseOfDeath = Array(Attacker.Master[0], Custom String("Ice Blast"));
						Damage(Victim, Global.NullPlayer[Index Of Array Value(Array(Team 2, Team 1), Team Of(Victim))], 2.500 * Attacker.Master[0].MyItemStackSizes[7] * Event Damage / Victim.DamageReceivedMultiplier[1]);
					End;
				End;
				If(Attacker.Master[0].MyItemStackSizes[8]);
					Attacker.Master[0].BlastCooldown = 10;
					Attacker.Master[0].FlameTornadoDamage = Event Damage / Victim.DamageReceivedMultiplier[1];
					Attacker.Master[0].FlameTornadoPosition = Position Of(Victim);
					Attacker.Master[0].FlameTornadoExpirationTime = Total Time Elapsed + 3;
					Create Effect(All Players(All Teams), Bad Aura, Color(Red), Attacker.Master[0].FlameTornadoPosition, 5, Visible To);
					Attacker.Master[0].FlameTornado = Last Created Entity;
					Play Effect(All Players(All Teams), Reaper Wraith Form Sound, Color(White), Attacker.Master[0].FlameTornadoPosition, 100);
				End;
			Else If(Global.TestMode[0]);
				Attacker.Master[0].NoBlastReason = Array(Event Damage, Victim.DamageReceivedMultiplier[1], Attacker.Master[0].BaseDamageMultiplier[0],
					Attacker.Master[0].BlastCooldown);
			End;
			"Lifesteal"
			If(Attacker.Master[0].MyItemStackSizes[9]);
				Heal(Attacker.Master[0], Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Attacker.Master[0]))],
					Attacker.Master[0].HealthScale[0] * Attacker.Master[0].MyItemStackSizes[9] * Mapped Array(Global.ProcCoefs[Mapped Array(
					Index Of Array Value(Global.Buttons, Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(
					Global.Buttons) + Current Array Element)[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200,
					Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200)
					: Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)
					[0] * Attacker.Master[0].HealingModifiers[1]);
			End;
			If(!Array Contains(Global.LightningStrikes, Attacker.Master[0]) && Attacker.Master[0].MyItemStackSizes[16] && Random Real(0, 1) < 0.100 * Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons,
				Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)
				[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
				Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
				Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0]);
				Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Color(White), Eye Position(Victim), 100);
				Modify Global Variable(LightningStrikes, Append To Array, Array(Total Time Elapsed + 0.250, Eye Position(Victim),
					Attacker.Master[0], 5 * Attacker.Master[0].MyItemStackSizes[16] * Event Damage / Victim.DamageReceivedMultiplier[1],
					Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons, Event Ability),
					Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)[0] + 1],
					Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
					Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
					Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0]));
			End;
			"Chain Lightning"
			If(!Array Contains(Global.DamageBeamInfo, Attacker.Master[0]) && !Array Contains(Global.ChainLightningBans, Attacker.Master[0])
				&& Attacker.Master[0].MyItemStackSizes[22] && Random Real(0, 1)
				< 0.250 * Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons, Event Ability),
				Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)[0] + 1],
				Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
				Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
				Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0]);
				Modify Global Variable(DamageBeamInfo, Append To Array, Array(Custom String("Chain Lightning"), Attacker.Master[0],
					Event Damage * 0.800 / Victim.DamageReceivedMultiplier[1], Victim));
				Modify Global Variable(DamageBeamInfo, Append To Array, Array Slice(Randomized Array(Filtered Array(Players Within Radius(Victim,
					6 + 2.500 * (Attacker.Master[0].MyItemStackSizes[22] - 1), Team Of(Victim), Surfaces),
					Current Array Element != Victim && Is Alive(Current Array Element) && !Has Status(Current Array Element, Phased Out)
					&& Current Array Element.IsCharacterBody)), 0,
					3 + 2 * (Attacker.Master[0].MyItemStackSizes[22] - 1)));
				Modify Global Variable(DamageBeamInfo, Append To Array, Custom String("0%END"));
			End;
		End;
		If(Is Alive(Victim) && Team Of(Victim) == Team 1 && Global.Difficulty[2] >= 7 && Event Damage >= 0.025 * Max Health(Victim));
			Victim.MaxHealthReduction[0] += Round To Integer(40 * Event Damage / Max Health(Victim), Down);
			Victim.MaxHealthReduction[1] = 1 - 1 / (1 + 0.010 * Victim.MaxHealthReduction[0]);
		End;
	}
}

rule("Normal Bleed")
{
	event
	{
		Subroutine;
		NormalBleed;
	}

	actions
	{
		Abort If(Is Dead(Victim));
		If(Random Real(0, 1) < 0.100 * Attacker.Master[0].MyItemStackSizes[3] * Mapped Array(Global.ProcCoefs[Mapped Array(
			Index Of Array Value(Global.Buttons, Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(
			Global.Buttons) + Current Array Element)[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200,
			Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200)
			: Event Damage / (Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)
			[0]);
			If(Victim.DebuffShield[0] > 0);
				Victim.DebuffShield[0] -= 1;
				Victim.DebuffShield[3] += 1;
			Else;
				Modify Player Variable(Victim, BleedTime, Max, 3 * Mapped Array(Global.ProcCoefs[Mapped Array(Index Of Array Value(Global.Buttons,
					Event Ability), Current Array Element == -1 ? -1 : Attacker.Hero[1] * Count Of(Global.Buttons) + Current Array Element)
					[0] + 1], Current Array Element == -1 ? Min(1, Event Ability == Null ? Max(0.200, Event Damage / (
					Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) * 0.260 - 11.200) : Event Damage / (
					Victim.DamageReceivedMultiplier[1] * Attacker.Master[0].BaseDamageMultiplier[0]) / 36) : Current Array Element)[0]);
				Victim.BleedInfo[0] += 1;
				Victim.BleedInfo[1] = Max(Attacker.Master[0].BaseDamageMultiplier[1], (Attacker.Master[0].BaseDamageMultiplier[1] + Victim.BleedInfo[1])
					/ 2);
				Victim.BleedInfo[2] = Attacker.Master[0];
			End;
		End;
	}
}

disabled rule("BOTS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Create Queued Bots")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.BotCreationQueue) > 1;
		Count Of(Global.AvailableBotSlots) > 0;
		Server Load Peak < 240;
		Server Load Average < 165;
	}

	actions
	{
		"Don't spawn adds after phase 3"
		If(Global.Phase == 2 || Global.Phase == 3 || !Array Contains(Array(Hero(Wrecking Ball), Hero(Zenyatta), Hero(Tracer)),
			Global.BotCreationQueue[0]));
			If((Array Contains(All Players(All Teams), Global.BotCreationQueue[1]) && Team Of(Global.BotCreationQueue[1]) == Team 1) || (
				Global.BotCreationQueue[1] == Team 1));
				Create Dummy Bot(Global.BotCreationQueue[0], Team 1, Y Component Of(Last Of(Filtered Array(Global.AvailableBotSlots,
					X Component Of(Current Array Element) == 1))), Vector(380, 0, 0), Forward);
			Else;
				Create Dummy Bot(Global.BotCreationQueue[0], Team 2, Y Component Of(Last Of(Filtered Array(Global.AvailableBotSlots,
					X Component Of(Current Array Element) == 2))), Vector(-380, 0, 0), Forward);
			End;
			Wait Until(Global.BotCreationQueue[0] == Null, 99999);
		End;
		Global.BotCreationQueue = Array Slice(Global.BotCreationQueue, 2, 1000);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Dummy Bot Setup")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Event Player.Ids[1] = Random Integer(-9999999, 9999999);
		If(Array Contains(Array(Hero(Sigma), Hero(Soldier: 76)), Hero Of(Event Player)));
			Event Player.Role = Custom String("NullPlayer");
			Event Player.IsNullPlayer = True;
		Else If(Array Contains(Array(Hero(Wrecking Ball), Hero(Zenyatta), Hero(Tracer)), Hero Of(Event Player)));
			Event Player.Role = Custom String("Add");
			Event Player.IsMook = True;
			Event Player.IsCharacterBody = True;
		Else If(Hero Of(Event Player) == Hero(Orisa));
			Event Player.Role = Custom String("Needler");
		End;
		Modify Global Variable(AvailableBotSlots, Remove From Array By Value, Vector(Team Of(Event Player) == Team 1 ? 1 : 2, Slot Of(
			Event Player), 0));
		If(Array Contains(All Players(All Teams), Global.BotCreationQueue[1]));
			Event Player.Master[0] = Global.BotCreationQueue[1];
			Event Player.Crit[0] = !Array Contains(Array(Hero(Ana), Hero(Brigitte), Hero(Junkrat), Hero(Moira), Hero(Pharah), Hero(Sigma),
				Hero(Symmetra), Hero(Winston), Hero(Zarya)), Event Player.Hero[0]);
		Else;
			Event Player.Master[0] = Event Player;
			Start Rule(PlayerSetup, Do Nothing);
		End;
		Global.BotCreationQueue[0] = Null;
	}
}

rule("Destroy bot subroutine")
{
	event
	{
		Subroutine;
		DestroyMe;
	}

	actions
	{
		If(Team Of(Event Player) == Team 2);
			Modify Global Variable(AvailableBotSlots, Append To Array, Vector(Team Of(Event Player) == Team 1 ? 1 : 2, Slot Of(Event Player),
				0));
		End;
		Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
	}
}

disabled rule("ITEMS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Steal subroutine")
{
	event
	{
		Subroutine;
		Steal;
	}

	actions
	{
		Play Effect(Global.CurrentStealee, Moira Fade Disappear Sound, Color(White), Global.CurrentStealee, 100);
		Global.ItemStackOriginalOwners[Global.ItemStackBeingStolenIndex] = Global.CurrentStealee;
		Global.ItemStackOwners[Global.ItemStackBeingStolenIndex] = Null;
		Global.ItemStackNewOwners[Global.ItemStackBeingStolenIndex] = Global.Stealer;
		Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ItemStackBeingStolenIndex, 2,
			-1 * Global.ItemStackSizes[Global.ItemStackBeingStolenIndex], Global.CurrentStealee, False));
	}
}

rule("Handle Item Instances")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State != Null;
		Count Of(Global.ItemStacks) > 0;
		Array Contains(Global.ItemStackOwners, Null) == True;
	}

	actions
	{
		If(Global.ItemStackNewOwners[Global.ItemStackIndex]);
			Call Subroutine(Acquire);
		End;
		Global.ItemStackIndex = (Global.ItemStackIndex + 1) % Count Of(Global.ItemStacks);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Acquire Item Subroutine")
{
	event
	{
		Subroutine;
		Acquire;
	}

	actions
	{
		If(Global.ItemStackNewOwners[Global.ItemStackIndex] != Global.ItemStackOriginalOwners[Global.ItemStackIndex]);
			Play Effect(Global.ItemStackNewOwners[Global.ItemStackIndex], Moira Fade Reappear Sound, Color(White),
				Global.ItemStackNewOwners[Global.ItemStackIndex], 100);
		End;
		Global.CurrentItemStackSize = Global.ItemStackSizes[Global.ItemStackIndex];
		Global.ExistingMatchingItemStacks = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
			Global.ItemStacks[Current Array Element] == Global.ItemStacks[Global.ItemStackIndex] && Global.ItemStackOwners[Current Array Element] == Global.ItemStackNewOwners[Global.ItemStackIndex]);
		Global.ItemStackOwners[Global.ItemStackIndex] = Global.ItemStackNewOwners[Global.ItemStackIndex];
		If(Count Of(Global.ExistingMatchingItemStacks) == 0);
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ItemStackIndex, 1, Global.CurrentItemStackSize,
				Global.ItemStackOwners[Global.ItemStackIndex], False));
		Else;
			Global.ItemStackSizes[Global.ItemStackIndex] -= Global.CurrentItemStackSize;
			Global.ItemStackSizes[Global.ExistingMatchingItemStacks[0]] += Global.CurrentItemStackSize;
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ExistingMatchingItemStacks[0], 0,
				Global.CurrentItemStackSize, Global.ItemStackOwners[Global.ItemStackIndex], False));
		End;
		Modify Player Variable(Global.ItemStackNewOwners[Global.ItemStackIndex], ItemStackReturnInfo, Append To Array, Array(
			Global.ItemStackIndex, Global.CurrentItemStackSize));
		Global.ItemStackNewOwners[Global.ItemStackIndex] = Null;
	}
}

rule("Distribute Item Subroutine")
{
	event
	{
		Subroutine;
		DistributeItem;
	}

	actions
	{
		Wait Until(Count Of(Global.ItemStackUpdateInfos) < 2, 9999);
		Global.NewItemStackIndex = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
			Global.ItemStacks[Current Array Element] == Global.ItemDistributionInfo[0] && Global.ItemStackOwners[Current Array Element] == Global.ItemDistributionInfo[1]);
		If(Count Of(Global.NewItemStackIndex) > 0);
			Global.NewItemStackIndex = Global.NewItemStackIndex[0];
			Global.ItemStackSizes[Global.NewItemStackIndex] += Global.ItemDistributionInfo[2];
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.NewItemStackIndex, 0, Global.ItemDistributionInfo[2],
				Global.ItemStackOwners[Global.NewItemStackIndex], False));
		Else;
			Call Subroutine(CreateItemStack);
			Global.ItemStackSizes[Global.NewItemStackIndex] += Global.ItemDistributionInfo[2];
		End;
	}
}

rule("Distribute Queued Items")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.ItemDistributionQueue) > 2;
	}

	actions
	{
		"[Item (name), Target Player, Count]"
		Global.ItemDistributionInfo = Array Slice(Global.ItemDistributionQueue, 0, 3);
		Call Subroutine(DistributeItem);
		Global.ItemDistributionQueue = Array Slice(Global.ItemDistributionQueue, 3, 1000);
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Create Item Stack Subroutine")
{
	event
	{
		Subroutine;
		CreateItemStack;
	}

	actions
	{
		Global.NewItemStackIndex = Count Of(Global.ItemStacks);
		Global.ItemStacks[Global.NewItemStackIndex] = Global.ItemDistributionInfo[0];
		Global.ItemStackOwners[Global.NewItemStackIndex] = Global.ItemDistributionInfo[1];
		Global.ItemStackNewOwners[Global.NewItemStackIndex] = Null;
		Create HUD Text(Global.ItemStackSizes[Evaluate Once(Global.NewItemStackIndex)] == 0 ? Null : Filtered Array(
			Global.ItemStackOwners[Evaluate Once(Global.NewItemStackIndex)], Current Array Element.CameraPosition == Null), Mapped Array(
			Evaluate Once(Global.ItemSymbols[Index Of Array Value(Global.Items, Global.ItemDistributionInfo[0])]),
			Current Array Element == Custom String("Ult") ? Ability Icon String(Hero Of(Global.ItemStackOwners[Evaluate Once(
			Global.NewItemStackIndex)]), Button(Ultimate)) : Current Array Element), Mapped Array(Custom String("{0}×{1}",
			Global.ItemStackOwners[Evaluate Once(Global.NewItemStackIndex)].ShowItemNames ? Custom String("{0} ", Evaluate Once(
			Global.ItemStacks[Global.NewItemStackIndex])) : Custom String(""), Global.ItemStackSizes[Evaluate Once(
			Global.NewItemStackIndex)]), Global.ItemStackOwners[Evaluate Once(Global.NewItemStackIndex)].ShowItemNames ? Custom String(
			"{0}{1}", Current Array Element, String Slice(Custom String("                                              "), 0, (
			23 - String Length(Current Array Element)) * 2)) : Current Array Element), Null, Left, 4 + Evaluate Once(
			Global.NewItemStackIndex + 1) / (Count Of(Global.ItemStacks) + 1), Evaluate Once(Global.ItemColours[Index Of Array Value(
			Global.Items, Global.ItemDistributionInfo[0])]), Color(White), Color(White),
			Visible To Sort Order String and Color, Default Visibility);
		Global.ItemStackHUDs[Global.NewItemStackIndex] = Last Text ID;
		Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.NewItemStackIndex, 1, Global.ItemDistributionInfo[2],
			Global.ItemStackOwners[Global.NewItemStackIndex], False));
	}
}

rule("Update Item Stacks from Queue")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State != Null;
		Count Of(Global.ItemStackUpdateInfos) > 4;
	}

	actions
	{
		Global.ItemStackUpdateInfo = Array(Global.ItemStackUpdateInfos[0], Global.ItemStacks[Global.ItemStackUpdateInfos[0]],
			Global.ItemStackUpdateInfos[3], Global.ItemStackUpdateInfos[2]);
		If(Array Contains(Array(2, 4), Global.ItemRarities[Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1])]));
			Global.ItemStackUpdateInfo[2].EvenRarityItemsCount += Global.ItemStackUpdateInfo[3];
		End;
		If(X Component Of(Global.ItemCategories[Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1])]));
			Global.ItemStackUpdateInfo[2].DamageItemsValue += Global.ItemStackUpdateInfo[3] * Array(25, 50, 400, 400)[Global.ItemRarities[Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1])] - 1];
		End;
		If(Global.ItemStackUpdateInfos[4]);
			Global.ItemStackSizes[Global.ItemStackUpdateInfos[0]] += Global.ItemStackUpdateInfo[3];
		End;
		If(Global.ItemStackUpdateInfo[3] < 0 && !Is True For Any(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Global.ItemStackUpdateInfo[1] && Global.ItemStackOwners[Current Array Index] == Global.ItemStackUpdateInfo[2]));
			Modify Player Variable(Global.ItemStackUpdateInfo[2], MyItemStacks, Remove From Array By Value, Global.ItemStackUpdateInfo[1]);
			Set Player Variable At Index(Global.ItemStackUpdateInfo[2], MyItemStackSizes, Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1]), 0); 
		End;
		If(Global.ItemStackUpdateInfo[3] > 0);
			If(!Global.ItemStackUpdateInfo[2].MyItemStackSizes[Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1])]);
				Modify Player Variable(Global.ItemStackUpdateInfo[2], MyItemStacks, Append To Array, Global.ItemStackUpdateInfo[1]);
			End;
			Set Player Variable At Index(Global.ItemStackUpdateInfo[2], MyItemStackSizes, Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1]), Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]]);
		End;
		If(Global.ItemStackUpdateInfos[1] == 0);
			Call Subroutine(UpdateItemStack_Modify);
		Else;
			If(Global.ItemStackUpdateInfos[1] > 1);
				Call Subroutine(UpdateItemStack_Remove);
			End;
			If(Global.ItemStackUpdateInfos[1] % 2 == 1);
				Call Subroutine(UpdateItemStack_Add);
			End;
		End;
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Wait(0.080, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Update Item Stack (Add)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Add;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Health, Evaluate Once(Global.ItemStackUpdateInfo[2])
				.HealthScale[0] * 25 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])], True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Shields, (Max Health Of Type(Evaluate Once(Global.ItemStackUpdateInfo[2]),
				Health) + Max Health Of Type(Evaluate Once(Global.ItemStackUpdateInfo[2]), Armor) / 0.700 - Evaluate Once(
				Global.ItemStackUpdateInfo[2]).BarrierHealth) * 0.080 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])],
				True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Health, Evaluate Once(Global.ItemStackUpdateInfo[2])
				.HealthScale[0] * 40 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])], True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
			Global.ItemStackUpdateInfo[2].HealingModifiers[4] = Vector(0, 1.600 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]], 0);
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].BarrierInfo[0] = True;
			Call Subroutine(UpdateItemStack_Modify);
		Else If(Array Contains(Array(Custom String("Speed"), Custom String("Double Jump"), Custom String("Ult Charge"), Custom String(
				"Crit %"), Custom String("Extra Crit Damage")), Global.ItemStackUpdateInfo[1]));
			Call Subroutine(UpdateItemStack_Modify);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Heal on Crit"));
			Global.ItemStackUpdateInfo[2].Crit[8] = Vector(5, 0, 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Insides"));
			Global.ItemStackUpdateInfo[2].Crit[10] = Vector(5, 0, 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Ice Blast"));
			Chase Player Variable At Rate(Global.ItemStackUpdateInfo[2], BlastCooldown, 0, 1, None);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Flame Blast"));
			Chase Player Variable At Rate(Global.ItemStackUpdateInfo[2], BlastCooldown, 0, 1, None);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Big Explosion"));
			If(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] == Null);
				Create Effect(Global.ItemStackOwners[Evaluate Once(Global.ItemStackUpdateInfo[0])].BoomTime[0] ? All Players(All Teams) : Null,
					Winston Tesla Cannon Target Sound, Color(White), Eye Position(Global.ItemStackOwners[Evaluate Once(
					Global.ItemStackUpdateInfo[0])]), 100, Visible To Position and Radius);
			End;
			Create Effect(Evaluate Once(Global.ItemStackUpdateInfo[2]).BoomTime[0] ? (Evaluate Once(Global.ItemStackUpdateInfo[2])
				.BoomTime[0] - Total Time Elapsed <= 2.8 ? All Players(All Teams) : Remove From Array(All Players(All Teams), Evaluate Once(Global.ItemStackUpdateInfo[2]))) : Null, Sphere, Color(White),
				Eye Position(Evaluate Once(Global.ItemStackUpdateInfo[2])), 30 - (Evaluate Once(Global.ItemStackUpdateInfo[2])
				.BoomTime[0] - Total Time Elapsed) * 10, Visible To Position and Radius);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Entity;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Debuff Shield"));
			Global.ItemStackUpdateInfo[2].DebuffShield[2] = 0;
			Global.ItemStackUpdateInfo[2].DebuffShield[0] += Global.ItemStackUpdateInfo[3];
			Global.ItemStackUpdateInfo[2].DebuffShield[1] += Global.ItemStackUpdateInfo[3];
		End;
	}
}

rule("Update Item Stack (Modify)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Modify;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP"));
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null, Global.ItemStackUpdateInfo[2].HealthScale[3] * 25 * Global.ItemStackUpdateInfo[3]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null, Max Health Of Type(Global.ItemStackUpdateInfo[2], Health)
				* 0.080 * Global.ItemStackUpdateInfo[3] / Global.ItemStackUpdateInfo[2].HealthScale[2]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Speed"));
			Global.ItemStackUpdateInfo[2].MoveSpeedBuffs[3] = 14 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateMoveSpeed = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Double Jump"));
			Global.ItemStackUpdateInfo[2].DoubleJumps[0] = Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].ArmourModifiers[6] = 100 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateDamageReceived = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Global.ItemStackUpdateInfo[2].HealingModifiers[4] = Vector(0, 1.600 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]], 0);
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null, Global.ItemStackUpdateInfo[2].HealthScale[3] * 40 * Global.ItemStackUpdateInfo[3]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Debuff Shield"));
			If(Global.ItemStackUpdateInfo[3] > 0);
				Global.ItemStackUpdateInfo[2].DebuffShield[2] = 0;
			End;
			Global.ItemStackUpdateInfo[2].DebuffShield[0] = Max(0,
				Global.ItemStackUpdateInfo[2].DebuffShield[0] + Global.ItemStackUpdateInfo[3]);
			Global.ItemStackUpdateInfo[2].DebuffShield[1] += Global.ItemStackUpdateInfo[3];
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Ult Charge"));
			Global.ItemStackUpdateInfo[2].UltCharges[1] += Global.ItemStackUpdateInfo[3];
			Global.ItemStackUpdateInfo[2].UltCharges[5] = 1 - (1 - 0.150) ^ Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			If(Global.ItemStackUpdateInfo[2].UltCharges[0] == 0);
				If(Global.ItemStackUpdateInfo[2].UltCharges[5] != Null);
					Set Ultimate Charge(Global.ItemStackUpdateInfo[2], Min(99, 100 * Global.ItemStackUpdateInfo[2].UltCharges[5] + (
						1 - Global.ItemStackUpdateInfo[2].UltCharges[5]) * (Is Duplicating(Global.ItemStackUpdateInfo[2]) ? 0 : Ultimate Charge Percent(Global.ItemStackUpdateInfo[2]))));
				End;
			Else If(Global.ItemStackUpdateInfo[2].UltCharges[0] < Global.ItemStackUpdateInfo[2].UltCharges[1]);
				If(Global.ItemStackUpdateInfo[2].UltCharges[3] != Null);
					Global.ItemStackUpdateInfo[2].UltCharges[4] = Total Time Elapsed + Global.ItemStackUpdateInfo[2].UltCharges[3];
				End;
			End;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Crit %"));
			Global.ItemStackUpdateInfo[2].Crit[7] = Vector(10 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]], 0, 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Extra Crit Damage"));
			Global.ItemStackUpdateInfo[2].Crit[9] = Vector(0, 100 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]], 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		End;
	}
}

rule("Update Item Stack (Remove)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Remove;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP") || Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Remove Health Pool From Player(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Null;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Speed"));
			Global.ItemStackUpdateInfo[2].MoveSpeedBuffs[3] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateMoveSpeed = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Double Jump"));
			Global.ItemStackUpdateInfo[2].DoubleJumps[0] = 0;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Big Explosion"));
			Destroy Effect(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackUpdateInfo[2].BoomTime[0] = 0;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].BarrierInfo[0] = False;
			Global.ItemStackUpdateInfo[2].ArmourModifiers[6] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateDamageReceived = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Reprieve"));
			Modify Player Variable At Index(Global.ItemStackUpdateInfo[2], StealthTime, 0, Min, Total Time Elapsed);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Remove Health Pool From Player(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Null;
			Global.ItemStackUpdateInfo[2].HealingModifiers[4] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Debuff Shield"));
			Global.ItemStackUpdateInfo[2].DebuffShield = Array(0, 0, 0);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Ult Charge"));
			Global.ItemStackUpdateInfo[2].UltCharges[1] = 1;
			Global.ItemStackUpdateInfo[2].UltCharges[4] = 0;
			Global.ItemStackUpdateInfo[2].UltCharges[5] = 0;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Crit %"));
			Global.ItemStackUpdateInfo[2].Crit[7] = Vector(0, 0, 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Heal on Crit"));
			Global.ItemStackUpdateInfo[2].Crit[8] = Vector(0, 0, 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Extra Crit Damage"));
			Global.ItemStackUpdateInfo[2].Crit[9] = Vector(0, 0, 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Insides"));
			Global.ItemStackUpdateInfo[2].Crit[10] = Vector(0, 0, 0);
			Global.ItemStackUpdateInfo[2].Crit[3] = True;
		End;
	}
}

disabled rule("STATUS EFFECTS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Cleanse some debuffs")
{
	event
	{
		Subroutine;
		CleanseSomeDebuffs;
	}

	actions
	{
		Stop All Damage Over Time(Event Player);
		Event Player.CrippleTime = 0;
		Event Player.SlowTime = 0;
		Event Player.DebuffFocusTime = 0;
	}
}

rule("Cleanse all debuffs")
{
	event
	{
		Subroutine;
		CleanseAllDebuffs;
	}

	actions
	{
		Call Subroutine(CleanseSomeDebuffs);
		Event Player.BleedTime = 0;
		Event Player.NewBurnInfo = Empty Array;
		Event Player.BurnTime = 0;
		Event Player.APTime = 0;
		Event Player.RecoveryTime = 0;
		Event Player.ArmourPiercingStacks[1] = 0;
		Event Player.ArmourModifiers[5] = 0;
		Event Player.MaxHealthReduction = Array(0, 0);
		Start Rule(UpdateDamageReceived, Restart Rule);
	}
}

rule("Crippled")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.CrippleTime > 0;
	}

	actions
	{
		Event Player.MoveSpeedDebuffs[2] = 50;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ArmourModifiers[2] = -20;
		Start Rule(UpdateDamageReceived, Restart Rule);
		Big Message(Event Player, Custom String("CRIPPLED"));
		Wait Until(Event Player.CrippleTime == 0, 9999);
		Event Player.MoveSpeedDebuffs[2] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ArmourModifiers[2] = 0;
		Start Rule(UpdateDamageReceived, Restart Rule);
	}
}

rule("Player knocked down")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		If(Team Of(Event Player) == Team 1);
			Clear Status(Event Player, Knocked Down);
		Else If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Clear Status(Event Player, Knocked Down);
		End;
	}
}

rule("Team 2 rooted")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Has Status(Event Player, Rooted) == True;
	}

	actions
	{
		Event Player.WispAcceleration = Vector(0, 0, 0);
		Start Rule(DetermineAcceleration, Restart Rule);
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Teleport(Event Player, World Vector Of(Normalize(Throttle Of(Event Player)) * 4, Event Player, Rotation And Translation));
		End;
	}
}

rule("Boss slept")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Has Status(Event Player, Asleep) == True;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Clear Status(Event Player, Asleep);
		End;
	}
}

rule("Boss frozen")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Has Status(Event Player, Frozen) == True;
	}

	actions
	{
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Clear Status(Event Player, Frozen);
		End;
	}
}

rule("Player hacked")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Hacked) == True;
	}

	actions
	{
		Event Player.IsHacked = True;
		Wait(1.500, Restart When True);
		Event Player.IsHacked = False;
	}
}

disabled rule("ITEM EFFECTS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Slowed")
{
	event
	{
		Subroutine;
		OnSlow;
	}
	
	actions
	{
		Event Player.MoveSpeedDebuffs[3] = 60;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Big Message(Event Player, Custom String("SLOWED"));
		Wait Until(Event Player.SlowTime == 0, 9999);
		Event Player.MoveSpeedDebuffs[3] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Not Focused")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DebuffFocusTime == 0;
	}

	actions
	{
		Abort If(Total Time Elapsed < 10);
		Start Rule(UpdateDamageReceived, Restart Rule);
	}
}

rule("No Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierInfo[1] != 0;
		Event Player.BarrierInfo[1] > Total Time Elapsed;
	}

	actions
	{
		Event Player.ArmourModifiers[6] = 0;
		Start Rule(UpdateDamageReceived, Restart Rule);
	}
}

rule("Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierInfo[0] == True;
		Event Player.BarrierInfo[1] < Total Time Elapsed;
	}

	actions
	{
		Event Player.ArmourModifiers[6] = 100 * Event Player.MyItemStackSizes[20];
		Start Rule(UpdateDamageReceived, Restart Rule);
	}
}

rule("No Barrier Health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierHealth == 0;
	}

	actions
	{
		If(Event Player.BarrierHealthDamageModification[1]);
			Stop Damage Modification(Event Player.BarrierHealthDamageModification[0]);
			Event Player.BarrierHealthDamageModification[1] = False;
		End;
	}
}

rule("Barrier Health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierHealth > 0;
		Event Player.BarrierHealthDamageModification[1] == False;
	}

	actions
	{
		Start Damage Modification(Event Player, All Players(All Teams), 100 * Health(Event Player) / (Health(Event Player)
			+ Event Player.BarrierHealth), Receivers Damagers and Damage Percent);
		Event Player.BarrierHealthDamageModification[0] = Last Damage Modification ID;
		Event Player.BarrierHealthDamageModification[1] = True;
		Chase Player Variable At Rate(Event Player, BarrierHealth, 0, (Max Health(Event Player) - Max Health Of Type(Event Player, Armor)
			* 0.300 - Event Player.BarrierHealth) / 30, Destination and Rate);
	}
}

rule("Recover")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.RecoveryTime == 0;
	}

	actions
	{
		Abort If(!Event Player.MyItemStackSizes[11]);
		Heal(Event Player, Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Event Player))], Min(Max Health(Event Player) * (1 - Event Player.MaxHealthReduction[1]) - Health(Event Player), Min(Max Health Of Type(
			Event Player, Health) + Max Health Of Type(Event Player, Armor) - (Health Of Type(Event Player, Health) + Health Of Type(
			Event Player, Armor)), Event Player.HealthScale[0] * 20 + (Max Health Of Type(Event Player, Health) + Max Health Of Type(
			Event Player, Armor)) * 0.050 * Event Player.MyItemStackSizes[11])) * Event Player.HealingModifiers[1]);
	}
}

rule("Debuff Shield on cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DebuffShield[1] > 0;
		Event Player.DebuffShield[0] == 0;
	}

	actions
	{
		Event Player.DebuffShield[2] = Total Time Elapsed + 5;
	}
}

rule("Debuff Shield off cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DebuffShield[2] > 0;
		Total Time Elapsed > Event Player.DebuffShield[2];
	}

	actions
	{
		Event Player.DebuffShield[2] = 0;
		Event Player.DebuffShield[0] = Event Player.DebuffShield[1];
	}
}

rule("Debuff Shield increase barrier health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DebuffShield[3] > 0;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Event Player.DebuffShield[4] = Event Player.DebuffShield[3];
		Event Player.DebuffShield[5] = Min(Max Health(Event Player) - Max Health Of Type(Event Player, Armor)
			* 0.300 - 2 * Event Player.BarrierHealth, Event Player.DebuffShield[4] * 0.100 * (Max Health(Event Player)
			- Max Health Of Type(Event Player, Armor) * 0.300 - Event Player.BarrierHealth));
		Event Player.BarrierHealth += Event Player.DebuffShield[5];
		Wait(0.100, Ignore Condition);
		Event Player.DebuffShield[3] -= Event Player.DebuffShield[4];
		Loop If Condition Is True;
	}
}

rule("Allow double jump if > 0.8 altitude & have double jumps")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.IsBoss || Altitude Of(Event Player) > 0.800) == True;
		Event Player.DoubleJumps[0] - Event Player.DoubleJumps[1] > 0;
	}

	actions
	{
		Event Player.DoubleJumps[3] = True;
	}
}

rule("Disallow double jump")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DoubleJumps[1] >= Event Player.DoubleJumps[0];
	}

	actions
	{
		Event Player.DoubleJumps[3] = False;
	}
}

rule("Double jump?")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Abort If(!Event Player.DoubleJumps[3] || Is Dead(Event Player) || Has Status(Event Player, Rooted) || Has Status(Event Player,
			Stunned));
		Event Player.DoubleJumps[2] += 1;
		Abort If((Event Player.Hero[0] == Hero(Genji) && Event Player.DoubleJumps[2] == 1) || (Event Player.Hero[0] == Hero(Hanzo)
			&& Mapped Array(Ability Cooldown(Event Player, Button(Jump)), Current Array Element == 0 || Current Array Element > 4.900)
			[0]));
		Event Player.DoubleJumps[1] += 1;
		Apply Impulse(Event Player, Up, 10, To World, Cancel Contrary Motion);
	}
}

rule("Bleeding")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BleedTime > 0;
	}

	actions
	{
		Event Player.CauseOfDeath = Array(Event Player.BleedInfo[2], Custom String("Bleed"));
		Damage(Event Player, Global.NullPlayer[Index Of Array Value(Array(Team 2, Team 1), Team Of(Event Player))],
			0.200 * Event Player.BleedInfo[0] * Event Player.BleedInfo[1]);
		Wait(0.250, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Not Bleeding")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BleedTime == 0;
	}

	actions
	{
		Event Player.BleedInfo = Array(0, 0, Null, False);
	}
}

rule("Burning")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BurnTime > 0;
	}

	actions
	{
		Set Status(Event Player, Event Player.BurnInfo[1], Burning, 0.300);
		Event Player.CauseOfDeath = Array(Event Player.BurnInfo[1], Custom String("Fire"));
		Damage(Event Player, Global.NullPlayer[Index Of Array Value(Array(Team 2, Team 1), Team Of(Event Player))],
			0.250 * Event Player.BurnInfo[0]);
		Wait(0.250, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Not Burning")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BurnTime == 0;
	}

	actions
	{
		Event Player.BurnInfo = Array(0, Null);
	}
}

rule("Not AP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.APTime == 0;
	}

	actions
	{
		If(Event Player.ArmourPiercingStacks[0] == 5);
			Event Player.ArmourModifiers[4] = 0;
			Start Rule(UpdateDamageReceived, Restart Rule);
		End;
		Event Player.ArmourPiercingStacks[0] = 0;
	}
}

rule("Reprieve")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.MyItemStackSizes[15] > 0;
		Normalized Health(Event Player) < 0.250;
		Is Alive(Event Player) == True;
		Event Player.StealthTime[0] == 0;
		Event Player.StealthTime[1] == 0;
	}

	actions
	{
		Event Player.StealthTime[0] = Total Time Elapsed + 5;
		Event Player.StealthTime[1] = Event Player.StealthTime[0] + 30 * 0.500 ^ Max(0, Event Player.MyItemStackSizes[15] - 1);
		Set Invisible(Event Player, All);
		Event Player.MoveSpeedBuffs[4] = 40;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Is Using Invisibility")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.StealthTime[0] != 0 || (Event Player.Hero[0] == Hero(Sombra) && Is Using Ability 1(Event Player))) == True;
	}

	actions
	{
		Event Player.Visibility[0] = False;
	}
}

rule("Is Not Using Invisibility")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.StealthTime[0] != 0 || (Event Player.Hero[0] == Hero(Sombra) && Is Using Ability 1(Event Player))) == False;
	}

	actions
	{
		Event Player.Visibility[0] = True;
	}
}

rule("Is Detected")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Has Status(Event Player, Hacked) || Is True For Any(Players On Hero(Hero(Widowmaker), Opposite Team Of(Team Of(Event Player))), Current Array Element.IsUsingUltimate) || Total Time Elapsed < Event Player.Visibility[2]) == True;
	}

	actions
	{
		Event Player.Visibility[1] = True;
	}
}

rule("Is Not Detected")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Has Status(Event Player, Hacked) || Is True For Any(Players On Hero(Hero(Widowmaker), Opposite Team Of(Team Of(Event Player))), Current Array Element.IsUsingUltimate) || Total Time Elapsed < Event Player.Visibility[2]) == False;
	}

	actions
	{
		Event Player.Visibility[1] = False;
	}
}

rule("Invisible ping")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Visibility[0] == False;
	}

	actions
	{
		Wait(2, Abort When False);
		Play Effect(Remove From Array(All Players(All Teams), Event Player), Tracer Recall Reappear Effect, Team Of(Event Player), Eye Position(Event Player), 2);
		Loop If Condition Is True;
	}
}

rule("Uncloak")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.StealthTime[0] != 0;
		Total Time Elapsed > Event Player.StealthTime[0];
	}

	actions
	{
		Set Invisible(Event Player, None);
		Event Player.MoveSpeedBuffs[4] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.StealthTime[0] = 0;
	}
}

rule("Reprieve becomes available")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.StealthTime[1] != 0;
		Total Time Elapsed > Event Player.StealthTime[1];
	}

	actions
	{
		Event Player.StealthTime[1] = 0;
	}
}

rule("Start Big Explosion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Normalized Health(Event Player) < 0.250;
		Event Player.MyItemStackSizes[17] > 0;
		Event Player.BoomTime[0] == 0;
		Event Player.BoomTime[1] == 0;
	}

	actions
	{
		Event Player.BoomTime[0] = Total Time Elapsed + 3;
		Event Player.BoomTime[1] = Total Time Elapsed + 30 / (1 + Event Player.MyItemStackSizes[17]);
	}
}

rule("Big Explosion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BoomTime[0] != 0;
		Total Time Elapsed > Event Player.BoomTime[0];
	}

	actions
	{
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Color(White), Eye Position(Event Player), 100);
		Play Effect(All Players(All Teams), Bad Explosion, Color(White), Eye Position(Event Player), 30);
		Filtered Array(Players Within Radius(Eye Position(Event Player), 30, Opposite Team Of(Team Of(Event Player)),
			Surfaces And Enemy Barriers), Is Alive(Current Array Element)).CauseOfDeath = Array(Event Player, Custom String("Big Explosion"));
		Damage(Players Within Radius(Eye Position(Event Player), 30, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers),
			Event Player, 60 * Event Player.BaseDamageMultiplier[2]);
		Event Player.BoomTime[0] = 0;
	}
}

rule("Big explosion becomes available")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BoomTime[1] != 0;
		Total Time Elapsed > Event Player.BoomTime[1];
	}

	actions
	{
		Event Player.BoomTime[1] = 0;
	}
}

rule("Destroy Flame Tornado")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FlameTornado != Null;
		Total Time Elapsed > Event Player.FlameTornadoExpirationTime;
	}

	actions
	{
		Destroy Effect(Event Player.FlameTornado);
		Event Player.FlameTornadoPosition = Null;
		Event Player.FlameTornado = Null;
		Wait(0.016, Ignore Condition);
		Event Player.FlameTornadoExpirationTime = Null;
	}
}

rule("Flame Tornado Damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FlameTornado != Null;
	}

	actions
	{
		Event Player.Victims = Filtered Array(Players Within Radius(Event Player.FlameTornadoPosition, 5, Opposite Team Of(Team Of(
			Event Player)), Off), Is Alive(Current Array Element) && !Has Status(Current Array Element, Phased Out) && (!Event Player.IsMook || Is On Ground(
			Current Array Element)));
		If(Event Player.IsMook);
			Set Status(Event Player.Victims, Event Player, Burning, 0.350);
		End;
		Event Player.Victims.CauseOfDeath = Array(Event Player, Custom String("Flame Blast"));
		Damage(Event Player.Victims, Event Player.IsMook ? Event Player : Global.NullPlayer[Index Of Array Value(Array(Team 1,
			Team 2), Team Of(Event Player))], Event Player.FlameTornadoDamage * 0.304);
		Wait(0.304, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Lightning Strike Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.LightningStrikes) > 0;
		Total Time Elapsed > Global.LightningStrikes[0];
	}

	actions
	{
		Global.StrikeVictims = Filtered Array(All Living Players(Opposite Team Of(Team Of(Global.LightningStrikes[2]))), !Has Status(Current Array Element, Phased Out) && Distance Between(
			Eye Position(Current Array Element), Global.LightningStrikes[1]) < 3);
		Global.StrikeVictims.CauseOfDeath[1] = Custom String("Lightning");
		Damage(Global.StrikeVictims, Global.LightningStrikes[2],
			Global.LightningStrikes[3] / Global.LightningStrikes[2].BaseDamageMultiplier[0]);
		Apply Impulse(Global.StrikeVictims, Down, 70 * Global.LightningStrikes[4], To World, Cancel Contrary Motion);
		Wait(0.080, Ignore Condition);
		Global.LightningStrikes = Array Slice(Global.LightningStrikes, 5, 1000);
		Loop If Condition Is True;
	}
}

rule("New Burn Loop")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.NewBurnInfo[0] != Null;
	}

	actions
	{
		Event Player.BurnInfo = Array(((Event Player.NewBurnInfo[0] * 3) + Event Player.BurnInfo[0] * Event Player.BurnTime) / 3, Event Player.NewBurnInfo[1]);
		Event Player.BurnTime = 3;
		Event Player.NewBurnInfo = Array Slice(Event Player.NewBurnInfo, 2, 1000);
		Loop If Condition Is True;
	}
}

rule("Damage Beam Loop 1")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Array Contains(Global.DamageBeamInfo, Custom String("0%END")) == True;
	}

	actions
	{
		Global.DamageBeamIndex = 4;
		While(Global.DamageBeamInfo[Global.DamageBeamIndex] != Custom String("0%END"));
			Call Subroutine(CreateDamageBeam);
			Global.DamageBeamIndex += 1;
		End;
		If(Global.DamageBeamIndex > 4);
			If(Global.DamageBeamInfo[0] == Custom String("Chain Lightning"));
				Modify Global Variable(ChainLightningBans, Append To Array, Array(Total Time Elapsed + 0.500, Global.DamageBeamInfo[1]));
			End;
		End;
		Global.DamageBeamInfo = Array Slice(Global.DamageBeamInfo, Global.DamageBeamIndex + 1, 1000);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Create Damage Beam")
{
	event
	{
		Subroutine;
		CreateDamageBeam;
	}

	actions
	{
		If(Global.DamageBeamInfo[0] == Custom String("Chain Lightning"));
			Create Beam Effect(All Players(All Teams), Winston Tesla Cannon Beam, Eye Position(Evaluate Once(
				Global.DamageBeamInfo[Global.DamageBeamIndex - 1])), Eye Position(Evaluate Once(
				Global.DamageBeamInfo[Global.DamageBeamIndex])), Team Of(Global.DamageBeamInfo[0]),
				Visible To Position and Radius);
		Else If(Global.DamageBeamInfo[0] == Custom String("Retaliation"));
			Create Beam Effect(All Players(All Teams), Mercy Boost Beam, Position Of(Evaluate Once(Global.DamageBeamInfo[3]))
				* 0.333 + Eye Position(Evaluate Once(Global.DamageBeamInfo[3])) * 0.667, Eye Position(Evaluate Once(
				Global.DamageBeamInfo[Global.DamageBeamIndex])), Color(White), Visible To Position and Radius);
		Else;
			Abort;
		End;
		"Damage Time, Beam Type, Attacker.Master[0], 0.8 * original damage, victim, effect"
		Modify Global Variable(DamageBeamInstances, Append To Array, Array(Total Time Elapsed + 0.160, Global.DamageBeamInfo[0],
			Global.DamageBeamInfo[1], Global.DamageBeamInfo[2], Global.DamageBeamInfo[Global.DamageBeamIndex], Last Created Entity));
	}
}

rule("Damage Beam Loop 2")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.DamageBeamInstances) > 5;
	}

	actions
	{
		While(Count Of(Global.DamageBeamInstances) > 5 && Total Time Elapsed > Global.DamageBeamInstances[0]);
			If(Is Alive(Global.DamageBeamInstances[4]));
				Global.DamageBeamInstances[4].CauseOfDeath[1] = Global.DamageBeamInstances[1];
				Damage(Global.DamageBeamInstances[4], Global.DamageBeamInstances[2], Global.DamageBeamInstances[3]);
			End;
			Destroy Effect(Global.DamageBeamInstances[5]);
			Global.DamageBeamInstances = Array Slice(Global.DamageBeamInstances, 6, 1000);
		End;
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Chain Lightning Loop 3")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.ChainLightningBans) > 1;
		Total Time Elapsed > Global.ChainLightningBans[0];
	}

	actions
	{
		Global.ChainLightningBans = Array Slice(Global.ChainLightningBans, 2, 1000);
		Loop If Condition Is True;
	}
}

rule("Ult becomes charged")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Abort If(Is Duplicating(Event Player));
		If(Event Player.UltCharges[3] == Null);
			Event Player.UltCharges[3] = Total Time Elapsed - Event Player.UltCharges[2];
		End;
		If(Event Player.UltCharges[0] == 0);
			Event Player.UltCharges[0] += 1;
			If(Event Player.UltCharges[0] < Event Player.UltCharges[1]);
				Event Player.UltCharges[4] = Total Time Elapsed + Event Player.UltCharges[3];
			End;
		End;
	}
}

rule("Is using ultimate")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsUsingUltimate == True;
	}

	actions
	{
		If(Event Player.UltCharges[3] == Null);
			Event Player.UltCharges[3] = Total Time Elapsed - Event Player.UltCharges[2];
		End;
	}
}

rule("Not Using Ultimate")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.UltCharges[2] != Null;
		Event Player.IsUsingUltimate == False;
	}

	actions
	{
		Log To Inspector(Custom String("Is using ultimate"));
		If(Event Player.UltCharges[0] > 0);
			Event Player.UltCharges[0] -= 1;
			If(Event Player.UltCharges[0] > 0);
				Set Ultimate Charge(Event Player, 100);
				Log To Inspector(Custom String("Set ult charge to 100 because I have more than 0 ult charges"));
				If(Event Player.UltCharges[4] == Null && Event Player.UltCharges[0] < Event Player.UltCharges[1]);
					Event Player.UltCharges[4] = Total Time Elapsed + Event Player.UltCharges[3];
				End;
			Else If(Event Player.UltCharges[4] != Null);
				Set Ultimate Charge(Event Player, Min(99, 100 * (1 - (1 - Event Player.UltCharges[5]) * (
					Event Player.UltCharges[4] - Total Time Elapsed) / Event Player.UltCharges[3])));
				Log To Inspector(Custom String("Set ult charge to represent the cooldown"));
				Log To Inspector(Custom String("{0} - {1}", Custom String("100 * (1 - (1 - {0}) * ({1}", Event Player.UltCharges[5],
					Event Player.UltCharges[4]), Custom String("{0}) / {1})", Total Time Elapsed, Event Player.UltCharges[3])));
				Event Player.UltCharges[4] = Null;
			End;
		Else;
			Wait Until(Event Player.UltCharges[5] != Null, 20);
			Set Ultimate Charge(Event Player, Min(99, 100 * Event Player.UltCharges[5]));
		End;
	}
}

rule("Ult is already charged and another charge is earned")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.UltCharges[4] > 0;
		Total Time Elapsed > Event Player.UltCharges[4];
	}

	actions
	{
		Event Player.UltCharges[0] += 1;
		If(Event Player.UltCharges[0] < Event Player.UltCharges[1]);
			Event Player.UltCharges[4] = Total Time Elapsed + Event Player.UltCharges[3];
		Else;
			Event Player.UltCharges[4] = Null;
		End;
	}
}

disabled rule("PHASE 0")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter State: Buy")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Buy");
	}

	actions
	{
		Global.ItemShops = Append To Array(Global.Items, Array(Custom String("?"), Custom String("??"), Custom String("???"),
			Ability Icon String(Hero(Soldier: 76), Button(Melee)), Ability Icon String(Hero(Kiriko), Button(Primary Fire)),
			Ability Icon String(Hero(Genji), Button(Ability 1)), Ability Icon String(Hero(Soldier: 76), Button(Melee)),
			Ability Icon String(Hero(Kiriko), Button(Primary Fire)), Ability Icon String(Hero(Genji), Button(Ability 1))));
		Global.ItemShopRarities = Append To Array(Global.ItemRarities, Array(1, 2, 3, 1, 1, 1, 2, 2, 2));
		Global.ItemShopDescriptions = Append To Array(Global.ItemDescriptions, Array(Custom String("A random common item"), Custom String(
			"A random rare item"), Custom String("A random legendary item"), Custom String("A random damage item\n(common)"),
			Custom String("A random healing item\n(common)"), Custom String("A random utility item\n(common)"), Custom String(
			"A random damage item\n(rare)"), Custom String("A random healing item\n(rare)"), Custom String(
			"A random utility item\n(rare)")));
		Global.ItemShopPrices = Append To Array(Mapped Array(Global.Items, Array(50, 75, 500, Custom String("∞"))
			[Global.ItemRarities[Current Array Index] - 1]), Array(25, 50, 400, 30, 30, 30, 60, 60, 60));
		Global.ItemShopPrices = Sorted Array(Global.ItemShopPrices, Global.ItemShopRarities[Current Array Index] + (Index Of Array Value(
			Global.Items, Global.ItemShops[Current Array Index]) + Current Array Index / Count Of(Global.ItemShopPrices)) / Count Of(
			Global.Items));
		Global.ItemShopDescriptions = Sorted Array(Global.ItemShopDescriptions, Global.ItemShopRarities[Current Array Index] + (
			Index Of Array Value(Global.Items, Global.ItemShops[Current Array Index]) + Current Array Index / Count Of(
			Global.ItemShopDescriptions)) / Count Of(Global.Items));
		Global.ItemShops = Sorted Array(Global.ItemShops, Global.ItemShopRarities[Current Array Index] + (Index Of Array Value(
			Global.Items, Current Array Element) + Current Array Index / Count Of(Global.ItemShops)) / Count Of(Global.Items));
		Global.ItemShopRarities = Sorted Array(Global.ItemShopRarities, Current Array Element);
		"Largest shop radius, Shop radius, Cumulative radius, shop radius..."
		Global.ItemShopRadii = Array(0);
		For Global Variable(ShopIndex, 1, 5, 1);
			Global.ItemShopRadii[Global.ShopIndex * 2 - 1] = 4.250 * (Max(Count Of(Filtered Array(Global.ItemShopRarities,
				Current Array Element == Global.ShopIndex)), 5) - 1) / 6.283;
			Global.ItemShopRadii[Global.ShopIndex * 2] = Global.ItemShopRadii[Global.ShopIndex * 2 - 2] + Global.ItemShopRadii[Global.ShopIndex * 2 - 1] * 2 + (
				Global.ShopIndex > 1 ? 5 : 0);
			Modify Global Variable At Index(ItemShopRadii, 0, Max, Global.ItemShopRadii[Global.ShopIndex * 2 - 1]);
		End;
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			If(Global.ItemShopRarities[Global.ItemShopIndex - 1] != Global.ItemShopRarities[Global.ItemShopIndex]);
				Global.ShopIndex = Global.ItemShopIndex;
			End;
			Global.ItemShopPositions[Global.ItemShopIndex] = Vector(90 + Global.ItemShopRadii[0], 0, Last Of(Global.ItemShopRadii)
				/ 2 - Global.ItemShopRadii[Global.ItemShopRarities[Global.ItemShopIndex] * 2] + Global.ItemShopRadii[Global.ItemShopRarities[Global.ItemShopIndex] * 2 - 1]);
			Global.ItemShopPositions[Global.ItemShopIndex] += Global.ItemShopRadii[Global.ItemShopRarities[Global.ItemShopIndex] * 2 - 1] * Direction From Angles(
				180 / (1 - Max(Count Of(Filtered Array(Global.ItemShopRarities,
				Current Array Element == Global.ItemShopRarities[Global.ItemShopIndex])), 5)) * (Global.ItemShopIndex - Global.ShopIndex - (
				Count Of(Filtered Array(Global.ItemShopRarities, Current Array Element == Global.ItemShopRarities[Global.ItemShopIndex])) - 1)
				/ 2) - 90, 0);
		End;
		disabled Global.ItemShopPositions = Mapped Array(Global.ItemShops, Vector(95, 0, ((Count Of(Global.ItemShops) - 1)
			/ 2 - Current Array Index) * 3));
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			Create In-World Text(All Players(Team 1), Mapped Array(Evaluate Once(Mapped Array(Index Of Array Value(Global.Items,
				Global.ItemShops[Global.ItemShopIndex]),
				Current Array Element == -1 ? Global.ItemShops[Global.ItemShopIndex] : Global.ItemSymbols[Current Array Element])),
				Current Array Element == Custom String("Ult") ? Custom String("[{0}]", Input Binding String(Button(Ultimate)))
				: Current Array Element), Global.ItemShopPositions[Global.ItemShopIndex] + Up, Array Contains(Global.Items,
				Global.ItemShops[Global.ItemShopIndex]) || String Contains(Global.ItemShops[Global.ItemShopIndex], Custom String("?")) ? 4 : 2,
				Clip Against Surfaces, Visible To and String, Mapped Array(Index Of Array Value(Global.Items,
				Global.ItemShops[Global.ItemShopIndex]), Current Array Element == -1 ? Color(White)
				: Global.ItemColours[Current Array Element]), Default Visibility);
			Global.ItemShopEffects1[Global.ItemShopIndex] = Last Text ID;
			Create Effect(All Players(All Teams), Orb, Array(Color(White), Color(Green), Color(Red), Color(Yellow))
				[Global.ItemShopRarities[Global.ItemShopIndex] - 1], Global.ItemShopPositions[Global.ItemShopIndex], 1, Visible To);
			Global.ItemShopEffects2[Global.ItemShopIndex] = Last Created Entity;
			Wait(0.016, Ignore Condition);
		End;
		If(Global.BuyPhaseSettings[1]);
			Wait Until(Is True For Any(All Players(Team 1), Current Array Element.IsHero && Has Spawned(Current Array Element)), 9999);
		End;
		Global.BuyPhaseSettings[2] = Total Time Elapsed + Global.BuyPhaseSettings[0];
		Wait(10, Abort When False);
		Wait Until(Is True For All(All Players(Team 1), !Current Array Element.IsHero || (
			Current Array Element.State == Custom String("Ready") && (X Component Of(Position Of(Current Array Element))
			< 80 || Current Array Element.Currency < 25))), Global.BuyPhaseSettings[3] ? Global.BuyPhaseSettings[0] - 10 : 99999);
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			Destroy In-World Text(Global.ItemShopEffects1[Global.ItemShopIndex]);
			Destroy Effect(Global.ItemShopEffects2[Global.ItemShopIndex]);
			Wait(0.016, Ignore Condition);
		End;
		Global.State = Custom String("Waiting");
	}
}

rule("Buy (with interact)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Global.State == Custom String("Buy");
		Is True For Any(Global.ItemShopPositions, Distance Between(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(
			Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False), Current Array Element) < 1.500) == True;
	}

	actions
	{
		Event Player.BuyIndex = Sorted Array(Mapped Array(Global.ItemShopPositions, Current Array Index), Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Global.ItemShopPositions[Current Array Element]))[0];
		Start Rule(Buy, Do Nothing);
	}
}

rule("Random Buy")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.TestMode[0] == True;
		Global.State == Custom String("Buy");
		(!Array Contains(All Players(Team 1), Host Player) || Is Button Held(Host Player, Button(Interact))) == True;
		Event Player.IsHero == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(1.250, Abort When False);
		While(True);
			Wait(0.250, Abort When False);
			Event Player.BuyIndex = Random Integer(0, Count Of(Global.ItemShops) - 1);
			Call Subroutine(Buy);
		End;
	}
}

rule("Buy subroutine")
{
	event
	{
		Subroutine;
		Buy;
	}

	actions
	{
		If(Event Player.Currency >= Global.ItemShopPrices[Event Player.BuyIndex] || (
			Global.TestMode[0] && Event Player == Host Player && Global.ItemShopPrices[Event Player.BuyIndex] == Custom String("∞")));
			Event Player.Currency -= Global.ItemShopPrices[Event Player.BuyIndex];
			If(Array Contains(Global.Items, Global.ItemShops[Event Player.BuyIndex]));
				Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Global.ItemShops[Event Player.BuyIndex], Event Player, 1));
			Else;
				If(Global.ItemShops[Event Player.BuyIndex] == Custom String("??") && Random Real(0, 1) < 0.150 * Min(1, Global.StagesCompleted / (
					Event Player.EvenRarityItemsCount + 1)));
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == 4)), Event Player, 1));
				Else If(String Contains(Global.ItemShops[Event Player.BuyIndex], Custom String("?")));
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == Global.ItemShopRarities[Event Player.BuyIndex])), Event Player, 1));
				Else If(Global.ItemShops[Event Player.BuyIndex] == Ability Icon String(Hero(Soldier: 76), Button(Melee)));
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == Global.ItemShopRarities[Event Player.BuyIndex] && X Component Of(
						Global.ItemCategories[Current Array Index]) == 1)), Event Player, 1));
				Else If(Global.ItemShops[Event Player.BuyIndex] == Ability Icon String(Hero(Kiriko), Button(Primary Fire)));
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == Global.ItemShopRarities[Event Player.BuyIndex] && Y Component Of(
						Global.ItemCategories[Current Array Index]) == 1)), Event Player, 1));
				Else If(Global.ItemShops[Event Player.BuyIndex] == Ability Icon String(Hero(Genji), Button(Ability 1)));
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == Global.ItemShopRarities[Event Player.BuyIndex] && Z Component Of(
						Global.ItemCategories[Current Array Index]) == 1)), Event Player, 1));
				End;
			End;
			Play Effect(All Players(All Teams), Brigitte Repair Pack Armor Sound, Color(White),
				Global.ItemShopPositions[Event Player.BuyIndex], 100);
		Else;
			Play Effect(Event Player, Sombra Translocator Reappear Sound, Color(White), Global.ItemShopPositions[Event Player.BuyIndex], 50);
		End;
	}
}

rule("On Enter State: Waiting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Waiting");
	}

	actions
	{
		Set Invisible(Event Player, All);
		Start Forcing Player Position(Event Player, Vector(1, 2.500, 0), False);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Status(Event Player, Null, Unkillable, 9999);
		Event Player.CanSwing = False;
	}
}

rule("Enter State: OnTheWay")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Waiting");
		Is True For Any(All Living Players(Team 1), Has Spawned(Current Array Element) && ((Global.TestMode[0] && Team Of(Host Player) != Team 1) || Distance Between(Current Array Element, Vector(0,
			0, 0)) < 70)) == True;
		Is True For Any(Players On Hero(Hero(Reinhardt), Team 2), Has Spawned(Current Array Element)) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.BuyPhaseSettings[2] = Total Time Elapsed;
		Respawn(All Dead Players(All Teams));
		Global.Heroes = Filtered Array(All Players(All Teams), Current Array Element.IsHero);
		Wait Until(Is True For All(Global.Heroes, Is Alive(Current Array Element)), 9999);
		Global.Bosses = Filtered Array(All Players(All Teams), Current Array Element.IsBoss);
		Disable Built-In Game Mode Respawning(All Players(All Teams));
		Global.PlayerCount = Count Of(Global.Heroes);
		Global.BossCount = Count Of(Global.Bosses);
		Global.PlayerFactor = 1 + 0.300 * (Global.PlayerCount - 1);
		Global.TimeFactor = 0.051 * Global.Difficulty[0] * Global.PlayerCount ^ 0.200;
		Call Subroutine(SetCoefficient);
		Global.Difficulty[3] = (1 + Global.Difficulty[1] / 2.500) * Square Root(Count Of(Filtered Array(Global.Heroes, Is Alive(Current Array Element))));
		Global.Difficulty[4] = 1 + Global.Difficulty[1] / 30;
		Global.State = Custom String("OnTheWay");
		Log To Inspector(Custom String("BroadcastState: OnTheWay"));
		If(Global.MusicMode == 1);
			Disable Built-In Game Mode Music;
		End;
		Wait(2, Ignore Condition);
		Log To Inspector(Custom String("BroadcastState: Phase 1"));
		Global.State = Custom String("Cutscene");
		Wait(Global.MusicMode == 2 ? 4.350 : 2.850, Ignore Condition);
		Global.Bosses.State = Custom String("Cutscene");
		Destroy Effect(Global.BossSpawnEffect);
		Wait Until(Is True For All(Global.Bosses, Current Array Element.State == Custom String("Ready")), 99999);
		Global.State = Custom String("BossFight");
		Global.Phase = 1;
		Global.ShowBossAbilityInfo[0] = True;
		If(Global.Dialogue[0]);
			Modify Global Variable(Dialogue, Append To Array, Array(Null, Custom String("BossSpawn")));
		End;
	}
}

rule("On Enter State: On The Way (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.State == Custom String("OnTheWay");
	}

	actions
	{
		Call Subroutine(UpdateStats);
	}
}

rule("On Enter State: Cutscene (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Cutscene");
	}

	actions
	{
		Start Facing(Event Player, Left, 10000, To World, None);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Stop Forcing Player Position(Event Player);
		Clear Status(Event Player, Phased Out);
		Apply Impulse(Event Player, Down, 70, To World, Cancel Contrary Motion);
		Set Invisible(Event Player, None);
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is On Ground(Event Player), 99999);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Color(White), Position Of(Event Player), 100);
		Wait(1.500, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1.500, Ignore Condition);
		Event Player.State = Custom String("Ready");
	}
}

rule("On Enter State: Cutscene (Team 1)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.State == Custom String("Cutscene");
		Event Player.IsHero == True;
	}

	actions
	{
		Event Player.ShowItemNames = False;
		Event Player.CameraPosition = Eye Position(Event Player) + World Vector Of(Forward, Event Player, Rotation);
		Disable Hero HUD(Event Player);
		Start Rule(PrepareSounds, Do Nothing);
		Set Status(Event Player, Null, Rooted, 9999);
		Set Ability 1 Enabled(Event Player, False);
		Set Ability 2 Enabled(Event Player, False);
		Set Primary Fire Enabled(Event Player, False);
		Set Secondary Fire Enabled(Event Player, False);
		Set Ultimate Ability Enabled(Event Player, False);
		Disallow Button(Event Player, Button(Interact));
		Set Melee Enabled(Event Player, False);
		Set Reload Enabled(Event Player, False);
		Event Player.Target[0] = Global.Bosses[Slot Of(Event Player) % Count Of(Global.Bosses)];
		Wait(0.050, Abort When False);
		Start Camera(Event Player, Event Player.CameraPosition, World Vector Of(2 * Up, Event Player.Target[0], Rotation And Translation),
			60);
		Start Rule(SoundCue, Restart Rule);
		If(Distance Between(Event Player.Target[0], Event Player.CameraPosition) < Distance Between(Event Player.Target[0],
			World Vector Of(Vector(0, 2, 35), Event Player.Target[0], Rotation And Translation)));
			Chase Player Variable At Rate(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 6), Event Player.Target[0],
				Rotation And Translation), 10, Destination and Rate);
		Else;
			Chase Player Variable Over Time(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 35), Event Player.Target[0],
				Rotation And Translation), Global.MusicMode == 2 ? 2.500 : 1, Destination and Duration);
			Wait(1, Abort When False);
			Chase Player Variable At Rate(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 6), Event Player.Target[0],
				Rotation And Translation), 15, Destination and Rate);
		End;
		Wait Until(Global.State != Custom String("Cutscene"), 9999);
		If(Global.Difficulty[2] >= 1);
			Set Player Health(Event Player, Min(Health(Event Player), (Max Health(Event Player) - Max Health Of Type(Event Player, Shields)) / 2 + Max Health Of Type(Event Player, Shields)));
		End;
		Clear Status(Event Player, Rooted);
		Set Ability 1 Enabled(Event Player, True);
		Set Ability 2 Enabled(Event Player, True);
		Set Primary Fire Enabled(Event Player, True);
		Set Secondary Fire Enabled(Event Player, True);
		Set Ultimate Ability Enabled(Event Player, True);
		Event Player.UltCharges[2] = Total Time Elapsed;
		Allow Button(Event Player, Button(Interact));
		Set Melee Enabled(Event Player, True);
		Set Reload Enabled(Event Player, True);
		Chase Player Variable At Rate(Event Player, CameraPosition, Eye Position(Event Player) + World Vector Of(Forward, Event Player,
			Rotation), 60, Destination and Rate);
		Enable Hero HUD(Event Player);
		Wait Until(Distance Between(Event Player.CameraPosition, Eye Position(Event Player)) < 1.500, 1);
		Stop Camera(Event Player);
		Stop Chasing Player Variable(Event Player, CameraPosition);
		Event Player.CameraPosition = Null;
	}
}

rule("Prepare Sound Cue")
{
	event
	{
		Subroutine;
		PrepareSounds;
	}

	actions
	{
		Abort If(Global.MusicMode != 1);
		Event Player.Sounds = Array(False, False, False, False, False);
		Create Effect(Event Player.Sounds[0] || Event Player.Sounds[1] || Event Player.Sounds[4] ? Event Player : Null, Energy Sound,
			Color(White), Event Player, 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Echo Focusing Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] ? Event Player : Null, Zarya Particle Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Create Effect(Event Player.Sounds[4] ? Event Player : Null, Decal Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Echo Focusing Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] ? Event Player : Null, Zarya Particle Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Create Effect(Event Player.Sounds[4] ? Event Player : Null, Decal Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Echo Focusing Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] ? Event Player : Null, Zarya Particle Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Create Effect(Event Player.Sounds[4] ? Event Player : Null, Decal Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Beacon Sound, Color(White), Event Player, 100,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[2] || Event Player.Sounds[0] ? Event Player : Null, Bad Aura Sound, Color(White), Event Player,
			100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] || Event Player.Sounds[4] ? Event Player : Null, Echo Cloning Sound, Color(White),
			Event Player, 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[2] ? Event Player : Null, Omnic Slicer Beam Sound, Color(White), Event Player, 100,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[3] ? Event Player : Null, Baptiste Immortality Field Protected Sound, Color(White), Event Player,
			Event Player.Sounds[2] ? 100 : 40, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
	}
}

rule("Sound Cue")
{
	event
	{
		Subroutine;
		SoundCue;
	}

	actions
	{
		Abort If(Global.MusicMode != 1);
		Wait(0.300, Ignore Condition);
		Call Subroutine(Call);
		If(Global.Phase < 2);
			Event Player.Sounds[3] = True;
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
		Else;
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
			Wait(0.188, Ignore Condition);
			Call Subroutine(Call);
			Wait(0.375, Ignore Condition);
			Call Subroutine(Call);
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
			Wait(0.188, Ignore Condition);
			Call Subroutine(Call);
			Wait(0.375, Ignore Condition);
			Call Subroutine(Call);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[0] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[0] = False;
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[3] = True;
			Event Player.Sounds[4] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[4] = False;
		End;
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = True;
		Event Player.Sounds[2] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(2.820, Ignore Condition);
		Event Player.Sounds[2] = False;
		Event Player.Sounds[3] = False;
		Destroy Effect(Array Slice(Event Player.Sounds, 5, 1000));
	}
}

rule("Motif")
{
	event
	{
		Subroutine;
		Call;
	}

	actions
	{
		Event Player.Sounds[0] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(0.375, Ignore Condition);
		Event Player.Sounds[0] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(0.188, Ignore Condition);
	}
}

disabled rule("PHASE 1")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reset Shockwave")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.ShockwaveRadius == 55;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, ShockwaveRadius);
		Event Player.ShockwaveRadius = -1;
		Destroy Effect(Event Player.ShockwaveEffect);
	}
}

rule("On Phase 1 Start")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 1;
	}

	actions
	{
		Global.Bosses.HasLostThisPhase = False;
		Global.Bosses.CanTakeOff = False;
		Global.Bosses.BaseMoveSpeedModifier = 100;
		Global.Bosses.ShouldUpdateMoveSpeed = True;
		Global.Bosses.ShowBossInfo[0] = True;
		Global.Bosses.ShowBossInfo[1] = 1;
		Stop Facing(Global.Bosses);
		Wait(1, Abort When False);
		Chase Player Variable At Rate(Global.Bosses, TakeoffCooldown, 0, 1, None);
		Global.Bosses.State = Custom String("ClosingIn");
	}
}

rule("On Enter State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("ClosingIn");
	}

	actions
	{
		Event Player.CanSprint = True;
		Event Player.CanNeedle[1] = Event Player.CanNeedle[0];
		Event Player.MoveSpeedBuffs[2] = 200;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Start Forcing Throttle(Event Player, 1, 1, 0, 0, 0, 0.010);
	}
}

rule("Exit State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("ClosingIn");
		(Has Status(Event Player, Stunned) || Event Player.IsHacked || Is True For Any(All Living Players(Team 1), Distance Between(
			Event Player, Current Array Element) < 2)) == True;
	}

	actions
	{
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("On Exit State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
	}

	actions
	{
		Event Player.CanNeedle[1] = False;
		Event Player.MoveSpeedBuffs[2] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("On Enter State: Becoming Idle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("BecomingIdle");
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Crouch));
		Stop Forcing Throttle(Event Player);
		If(Event Player.PizzaIndex == Custom String("ASAP") && !Event Player.IsHacked && Is On Ground(Event Player));
			Event Player.State = Custom String("Pizza");
		Else If(Global.TestMode[1] && Array Contains(Array(1, 3), Global.Phase) && Is On Ground(Event Player) && Normalized Health(Event Player)
				< 0.750 && Event Player.TakeoffCooldown == 0 && !Event Player.IsHacked);
			Event Player.State = Custom String("StartingTakeoff");
		Else;
			Stop Forcing Throttle(Event Player);
			If(Global.Phase == 4);
				Event Player.CanNeedle = Array(True, True);
			End;
			Event Player.State = Custom String("Idle");
		End;
	}
}

rule("Enable Sprint")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Idle");
		Is True For Any(All Living Players(Team 1), Distance Between(Position Of(Current Array Element) - Y Component Of(Position Of(
			Current Array Element)) * Up, Event Player) < 13) == False;
		Event Player.IsHacked == False;
	}

	actions
	{
		Event Player.CanSprint = True;
	}
}

rule("Disable Sprint")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
		(Event Player.State == Custom String("Idle") && !Is True For Any(All Living Players(Team 1), Distance Between(Position Of(
			Current Array Element) - Y Component Of(Position Of(Current Array Element)) * Up, Event Player) < 13)
			&& !Event Player.IsHacked) == False;
	}

	actions
	{
		Event Player.CanSprint = False;
	}
}

rule("Enter State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
		Event Player.CanSprint == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		Event Player.State = Custom String("ClosingIn");
	}
}

rule("Enable Takeoff (cooldown & state etc permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Normalized Health(Event Player) < 0.750;
	}

	actions
	{
		If(!Event Player.CanTakeOff && Array Contains(Array(1, 3), Global.Phase));
			Event Player.CanTakeOff = True;
		End;
	}
}

rule("Takeoff Enabled")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanTakeOff == True;
		Event Player.TakeoffCooldown == 0;
	}

	actions
	{
		If(Array Contains(Array(1, 3), Global.Phase));
			Big Message(Event Player, Custom String("Hold [{0}] to use ultimate (Takeoff) {1}!", Input Binding String(Button(Crouch)), Ability Icon String(Hero(Doomfist), Button(Ultimate))));
			While(Event Player.CanTakeOff && Event Player.TakeoffCooldown == 0 && Array Contains(Array(1, 3), Global.Phase));
				Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
				Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
				Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
				Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
				Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
				Wait(1, Abort When False);
			End;
		End;
	}
}

rule("Enter State: StartingTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanTakeOff == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
		"Maybe add an extra requirement - either a manual keypress or taking 2 instances of damage for each takeoff or something?"
		Event Player.TakeoffCooldown == 0;
		Is On Ground(Event Player) == True;
		"don't initiate takeoff just before hammer hits the ground"
		Ultimate Charge Percent(Event Player) > 95;
		Has Status(Event Player, Stunned) == False;
		Event Player.IsHacked == False;
		(Global.TestMode[1] || Is Crouching(Event Player)) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is Crouching(Event Player), 99999);
		Abort If Condition Is False;
		Event Player.State = Custom String("StartingTakeoff");
	}
}

rule("On Enter State: StartingTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingTakeoff");
	}

	actions
	{
		Event Player.State = Custom String("Takeoff");
	}
}

rule("On Enter State: FinishingFullTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("FinishingFullTakeoff");
	}

	actions
	{
		Event Player.BleedTime = 0;
		Event Player.BurnTime = 0;
		If(Global.Phase == 3);
			Stop Chasing Player Variable(Event Player, TakeoffCooldown);
		End;
		Event Player.TakeoffCooldown = Global.Difficulty[2] >= 6 ? 15 : 30;
		If(Global.Phase == 3);
			Event Player.PizzaIndex = Custom String("Soon");
		End;
		Event Player.CachedHealth[0] = True;
		Call Subroutine(UpdateStats);
		Wait(3, Abort When False);
		Event Player.State = Custom String("Landing");
	}
}

rule("On Enter State: Landing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Landing");
	}

	actions
	{
		Event Player.ShowBossInfo[1] = 1;
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Stop Forcing Player Position(Event Player);
		Clear Status(Event Player, Phased Out);
		Apply Impulse(Event Player, Down, 70, To World, Cancel Contrary Motion);
		Set Invisible(Event Player, None);
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is On Ground(Event Player), 99999);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Color(White), Position Of(Event Player), 100);
		If(Global.Phase == 1 || Event Player.PizzaIndex == Custom String("Soon"));
			Create Effect(All Players(All Teams), Ring, Color(Sky Blue), Vector(0, 0, 0), Event Player.ShockwaveRadius + 2,
				Visible To Position and Radius);
			Event Player.ShockwaveEffect = Last Created Entity;
			Event Player.ShockwaveRadius = 0;
			Chase Player Variable At Rate(Event Player, ShockwaveRadius, 55, 10, None);
			Event Player.CanNeedle = Array(True, False);
		End;
		Wait(1, Abort When False);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1, Abort When False);
		"Remove Armour Boost"
		Event Player.ArmourModifiers[1] = 0;
		Start Rule(UpdateDamageReceived, Restart Rule);
		Clear Status(Event Player, Rooted);
		Call Subroutine(ChooseState);
		Abort If(Event Player.PizzaIndex != Custom String("Soon"));
		Event Player.PizzaTime[0] = Total Time Elapsed + Random Real(5, 8.500);
	}
}

rule("Choose State (Closing In / Becoming Idle)")
{
	event
	{
		Subroutine;
		ChooseState;
	}

	actions
	{
		If(Has Status(Event Player, Stunned) || Event Player.IsHacked || Is True For Any(All Living Players(Team 1), Distance Between(
			Event Player, Current Array Element) < 2));
			Event Player.State = Custom String("BecomingIdle");
		Else;
			Event Player.State = Custom String("ClosingIn");
		End;
	}
}

rule("Shockwave Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsHero == True;
		Is True For Any(Global.Bosses, Current Array Element.ShockwaveRadius > 0 && Distance Between(Event Player,
			Current Array Element.ShockwaveRadius * Direction From Angles(Horizontal Angle From Direction(Position Of(Event Player)), 0))
			< 0.500) == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Phased Out) == False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.CauseOfDeath = Array(Null, Custom String("Shockwave"));
		Damage(Event Player, Global.NullPlayer[1], 4 * Last Of(Sorted Array(Mapped Array(Global.Bosses, Current Array Element.BaseDamageMultiplier[1]), Current Array Element)));
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
		Else;
			Modify Player Variable(Event Player, CrippleTime, Max, 3);
		End;
	}
}

rule("Low health")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Health(Event Player) < 2;
		Event Player.CachedHealth[1] == False;
	}

	actions
	{
		Abort If(Event Player.HasLostThisPhase);
		Abort If(Health(Event Player) == Null);
		Log To Inspector(Custom String("\"death\""));
		"probably need a bunch more caveats"
		If(Global.Phase == 1);
			Event Player.HasLostThisPhase = True;
			If(Event Player.State == Custom String("Takeoff"));
				Event Player.State = Custom String("Takeoff2");
			Else If(Event Player.State == Custom String("FullTakeoff"));
				Event Player.State = Custom String("FullTakeoff2");
			Else If(Event Player.State == Custom String("FinishingFullTakeoff"));
				Event Player.State = Custom String("FinishingFullTakeoff2");
			Else;
				Event Player.State = Custom String("StartingTakeoff2");
			End;
		Else If(Global.Phase == 3);
			Event Player.HasLostThisPhase = True;
			Play Effect(All Players(All Teams), Sombra EMP Explosion Sound, Color(White), Event Player, 100);
			Event Player.CanSwing = False;
			Event Player.CanSlam[0] = False;
			Cancel Primary Action(Event Player);
			Set Status(Event Player, Null, Phased Out, 9999);
			Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
			Set Invisible(Event Player, All);
			Event Player.ShowBossInfo[0] = False;
			Event Player.ShowBossInfo[1] = 0;
			Call Subroutine(CleanseAllDebuffs);
			Event Player.State = Custom String("Absent");
		End;
	}
}

rule("On Enter State: StartingTakeoff2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingTakeoff2");
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Event Player.State = Custom String("Takeoff2");
	}
}

rule("TakeOff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(Custom String("Takeoff"), Custom String("Takeoff2")), Event Player.State) == True;
	}

	actions
	{
		"Add Armour Boost"
		Event Player.ArmourModifiers[1] = 200;
		Start Rule(UpdateDamageReceived, Restart Rule);
		Event Player.CanSwing = False;
		Event Player.CanSlam[0] = False;
		Start Holding Button(Event Player, Button(Crouch));
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Wait(1, Abort When False);
		Event Player.State = Mapped Array(Event Player.State, String Contains(Current Array Element, Custom String("Takeoff"))
			? Custom String("Full{0}", Current Array Element) : Current Array Element)[0];
		Abort If(!String Contains(Event Player.State, Custom String("Takeoff")));
		Apply Impulse(Event Player, Up, 70, To World, Cancel Contrary Motion);
		Wait(0.250, Ignore Condition);
		Set Invisible(Event Player, All);
		If(Event Player.State == Custom String("FullTakeoff"));
			Event Player.ShowBossInfo[1] = 2;
		End;
		Start Forcing Player Position(Event Player, Vector(1, 50, 0), False);
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.State = Custom String("Finishing{0}", Event Player.State);
	}
}

rule("Stunned/hacked during takeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Takeoff");
		(Has Status(Event Player, Stunned) || Event Player.IsHacked) == True;
	}

	actions
	{
		Event Player.State = Custom String("AbortingTakeoff");
		Event Player.TakeoffCooldown = Global.Difficulty[2] >= 6 ? 15 : 30;
		"Remove Armour Boost"
		Event Player.ArmourModifiers[1] = 0;
		Event Player.ShouldUpdateDamageReceived = True;
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("On Enter State: FinishingFullTakeoff2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("FinishingFullTakeoff2");
	}

	actions
	{
		Event Player.ShowBossInfo[0] = False;
		Event Player.ShowBossInfo[1] = 0;
		Event Player.CanTakeOff = False;
		Event Player.TakeoffCooldown = 0;
		Call Subroutine(CleanseAllDebuffs);
		Event Player.State = Custom String("Absent");
	}
}

rule("Enter Phase: 2/4")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.Bosses) > 0;
		Is True For All(Global.Bosses, Current Array Element.State == Custom String("Absent")) == True;
	}

	actions
	{
		If(Global.Phase == 1);
			Global.Phase = 2;
		Else If(Global.Phase == 3);
			Global.Phase = 4;
		End;
	}
}

disabled rule("SWING")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Disable Swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Event Player.CanSwing && Event Player.SwingCooldown == 0) == False;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
	}
}

rule("Enable swing (cooldown permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
	}

	actions
	{
		Event Player.CanSwing = True;
	}
}

rule("Enable swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanSwing == True;
		Event Player.SwingCooldown == 0;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("Enter State: StartingSwing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		If(Event Player.CanSwing);
			Event Player.State = Custom String("StartingSwing");
			Disable Movement Collision With Players(Event Player);
			"only allow 1 swing"
			Event Player.CanSwing = False;
			Event Player.CanSlam[0] = False;
			Event Player.SwingCooldown = Global.Difficulty[2] >= 6 ? 2.500 : 5;
			Wait(0.200, Abort When False);
			Abort If(Event Player.State != Custom String("StartingSwing"));
			Start Forcing Throttle(Event Player, 0, 1, 0, 1, 0, 0);
			Wait Until(Is On Ground(Event Player), 1);
			Abort If(Event Player.State != Custom String("StartingSwing"));
			Set Aim Speed(Event Player, 30);
			Event Player.DashAngles[0] = Horizontal Facing Angle Of(Event Player);
			Event Player.DashVector = Direction From Angles(Event Player.DashAngles[0], 0) * 31.881 * (1 + Event Player.MoveSpeedBuffs[5] / 100) / Event Player.MoveSpeedDebuffs[0] + 2.758 * Up;
			Event Player.DashAngles[1] = Vertical Angle From Direction(Event Player.DashVector);
			Set Gravity(Event Player, 63);
			Event Player.DashSpeed = Magnitude Of(Event Player.DashVector);
			Call Subroutine(Dash);
			Event Player.State = Custom String("Swinging");
		Else;
			Cancel Primary Action(Event Player);
		End;
	}
}

rule("Stunned during swing start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingSwing");
		Has Status(Event Player, Stunned) == True;
	}

	actions
	{
		Event Player.State = Custom String("BecomingIdle");
	}
}

disabled rule("SLAM")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Disable Slam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Event Player.CanSlam[0] && Event Player.SlamCooldown == 0) == False;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, False);
	}
}

rule("Enable slam (cooldown permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
	}

	actions
	{
		Event Player.CanSlam[0] = True;
	}
}

rule("Enable slam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanSlam[0] == True;
		Event Player.SlamCooldown == 0;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		Set Ultimate Ability Enabled(Event Player, True);
	}
}

rule("Ultimate Button Pressed")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		Set Aim Speed(Event Player, 30);
		Event Player.CanSlam[1] = Total Time Elapsed + 0.450;
	}
}

rule("Enter State: Slamming")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.IsUsingUltimate == True;
	}

	actions
	{
		Abort If(String Contains(Event Player.State, Custom String("Pizza")));
		Event Player.State = Custom String("Slamming");
	}
}

rule("On Enter State: Slamming")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Slamming");
	}

	actions
	{
		Event Player.SlamCooldown = Global.Difficulty[2] >= 6 ? 2 : 4;
		Event Player.CanSwing = False;
		Event Player.CanDash[0] = False;
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		If(Global.Phase == 3);
			Modify Global Variable(FlamePillarPositions, Append To Array, World Vector Of(3 * Forward, Event Player,
				Rotation And Translation));
			Modify Global Variable(FlamePillarExpirationTimes, Append To Array, Total Time Elapsed + 45);
			Create Effect(All Players(All Teams), Light Shaft, Color(Blue), Last Of(Global.FlamePillarPositions), 1, Visible To);
			Modify Global Variable(FlamePillars, Append To Array, Last Created Entity);
		End;
		Wait(Random Real(0, 3), Abort When False);
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("Augmented slam")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		If(Event Was Critical Hit);
			Damage(Victim, Null, 4 * Attacker.BaseDamageMultiplier[1] * (Global.Difficulty[0] - 1));
		End;
		Abort If(Global.Phase < 3);
		Damage(Victim, Null, 0.824 * Attacker.BaseDamageMultiplier[1]);
		If(Victim.DebuffShield[0] > 0);
			Victim.DebuffShield[0] -= 1;
			Victim.DebuffShield[3] += 1;
		Else;
			Modify Player Variable(Victim, CrippleTime, Max, 3);
		End;
	}
}

disabled rule("DASH")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Enable Dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
		Global.Phase != 4;
	}

	actions
	{
		Event Player.CanDash[0] = True;
	}
}

rule("Disable Dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Is On Ground(Event Player) && Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State)
			&& Global.Phase != 4) == False;
	}

	actions
	{
		Event Player.CanDash[0] = False;
	}
}

rule("Replenish all dashes")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanDash[2] > 0;
		Total Time Elapsed > Event Player.CanDash[2];
	}

	actions
	{
		Event Player.CanDash[1] = 2;
	}
}

rule("Enter State: Dashing (with jump button)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanDash[0] == True;
		Event Player.CanDash[1] > 0;
		Event Player.DashCooldown == 0;
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Event Player.State = Custom String("Dashing");
		Start Rule(SpaceDash, Do Nothing);
	}
}

rule("Enter State: Dashing (with sideways movement)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanDash[1] > 0;
		Event Player.DashCooldown == 0;
		Absolute Value(X Component Of(Throttle Of(Event Player))) > 0.005;
	}

	actions
	{
		Abort If(!Event Player.CanDash[0] || Event Player.State != Custom String("ClosingIn"));
		Event Player.State = Custom String("Dashing");
		Start Rule(SpaceDash, Do Nothing);
	}
}

rule("On Enter State: Dashing")
{
	event
	{
		Subroutine;
		SpaceDash;
	}
	
	actions
	{
		Event Player.CanDash[1] -= 1;
		Event Player.CanDash[2] = Total Time Elapsed + 3.400;
		If(Event Player.CanDash[1] == 0);
			Event Player.DashCooldown = Global.Difficulty[2] >= 6 ? 1.700 : 3.400;
		Else;
			Event Player.DashCooldown = Global.Difficulty[2] >= 6 ? 1 : 2;
		End;
		Call Subroutine(CleanseSomeDebuffs);
		Disable Movement Collision With Players(Event Player);
		Event Player.CanSlam[0] = False;
		Event Player.DashAngles[0] = Horizontal Angle From Direction(World Vector Of(Mapped Array(Throttle Of(Event Player), 
			X Component Of(Current Array Element) == 0 ? (Z Component Of(Current Array Element) == 0 ? Forward : Backward) : Vector(
			X Component Of(Current Array Element) * 100, 0, Z Component Of(Current Array Element))), Event Player, Rotation));
		Event Player.DashVector = Direction From Angles(Event Player.DashAngles[0], 0) * 30.813 * (1 + Event Player.MoveSpeedBuffs[5] / 100) + 3.402 * Up;
		Event Player.DashAngles[1] = Vertical Angle From Direction(Event Player.DashVector);
		Set Gravity(Event Player, 175);
		Event Player.DashSpeed = Magnitude Of(Event Player.DashVector);
		Call Subroutine(Dash);
	}
}

rule("Is On Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.DoubleJumps[1] = 0;
		Event Player.DoubleJumps[2] = 0;
		If(!Event Player.IsBoss);
			Event Player.DoubleJumps[3] = False;
		Else If(Array Contains(Array(Custom String("Dashing"), Custom String("Swinging")), Event Player.State));
			Log To Inspector(Custom String("S: {0} T: {1}", Distance Between(Event Player, Event Player.DashStartPosition),
				Total Time Elapsed - Event Player.DashStartTime));
			Event Player.State = Custom String("BecomingIdle");
		End;
		If(Event Player.FallDamage[0] && !(Event Player.Hero[0] == Hero(Cassidy) && Is Using Ability 1(Event Player)));
			Event Player.FallDamage[2] = Event Player.FallDamage[1] - 13.15;
			If(Event Player.FallDamage[2] > 0);
				Event Player.FallDamage[3] = Event Player.FallDamage[2] / 23;
				Log To Inspector(Custom String("Health Fraction: {0}", Event Player.FallDamage[3]));
				If(Is Alive(Event Player));
					Event Player.CauseOfDeath = Array(Null, Custom String("Gravity"));
					Damage(Event Player, Global.NullPlayer[1], Mapped Array(Event Player.FallDamage[0] * Event Player.FallDamage[3] * (Max Health Of Type(Event Player, Health) + Max Health Of Type(Event Player, Armor)) * Event Player.DamageReceivedMultiplier[0], Global.Difficulty[2] >= 2 ? Current Array Element : Min(Health(Event Player) - 1, Current Array Element))[0] / (Event Player.DamageReceivedMultiplier[1]));
				End;
			End;
		End;
		Event Player.FallDamage[1] = 0;
	}
}

rule("Low Altitude")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FallDamage[0] > 0;
		Y Component Of(Position Of(Event Player)) < 1;
		Vertical Speed Of(Event Player) <= 0;
	}

	actions
	{
		If((Event Player.IsBoss && Array Contains(Array(Custom String("Landing"), Custom String("Cutscene")), Event Player.State)) || (Is Using Ability 1(Event Player) && Array Contains(Array(Hero(Doomfist), Hero(Winston), Hero(Wrecking Ball), Hero(Genji)), Event Player.Hero[0])));
			Event Player.FallDamage[1] = 0;
		Else;
			Event Player.FallDamage[1] = -1 * Vertical Speed Of(Event Player);
			Log To Inspector(Custom String("Impact Velocity: {0}", Event Player.FallDamage[1]));
		End;
		Abort If(Is On Ground(Event Player));
		Wait(0.100, Abort When False);
		Loop If Condition Is True;
	}
}

rule("On Exit State: Dash/Swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("Dashing");
		Event Player.State != Custom String("Swinging");
		Event Player.State != Custom String("StartingSwing");
	}

	actions
	{
		Enable Movement Collision With Players(Event Player);
		Set Gravity(Event Player, 100);
	}
}

rule("Restore aim speed")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("Swinging");
		Event Player.State != Custom String("StartingSwing");
		Total Time Elapsed > Event Player.CanSlam[1];
	}

	actions
	{
		Set Aim Speed(Event Player, 100);
	}
}

rule("Dash subroutine")
{
	event
	{
		Subroutine;
		Dash;
	}

	actions
	{
		Event Player.DashStartPosition = Position Of(Event Player);
		Event Player.DashStartTime = Total Time Elapsed;
		Apply Impulse(Event Player, Direction From Angles(Event Player.DashAngles[0], Is On Ground(Event Player)
			? Event Player.DashAngles[1] : Max(Event Player.DashAngles[1], Vertical Facing Angle Of(Event Player))),
			Event Player.DashSpeed, To World, Cancel Contrary Motion);
	}
}

disabled rule("SHOOT")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Needler Bot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.Role == Custom String("Needler");
	}

	actions
	{
		Event Player.Master[0].Bots[0] = Event Player;
		Event Player.Master[1] = Event Player.Master[0];
		Wait(0.250, Ignore Condition);
		Start Forcing Dummy Bot Name(Event Player, Event Player.Master[0]);
		Set Gravity(Event Player, 0);
		Disable Movement Collision With Environment(Event Player, True);
		Attach Players(Event Player, Event Player.Master[0], Vector Towards(Local Vector Of(Eye Position(Event Player), Event Player,
			Rotation And Translation), Local Vector Of(Eye Position(Event Player.Master[0]), Event Player.Master[0],
			Rotation And Translation)));
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Invisible(Event Player, All);
		Start Facing(Event Player, Facing Direction Of(Event Player.Master[0]), 900, To World, Direction and Turn Rate);
		Start Modifying Hero Voice Lines(Event Player, 0.500, False);
		Event Player.Hero[0] = Hero Of(Event Player);
		Event Player.Hero[1] = Index Of Array Value(Global.AllHeroes, Event Player.Hero[0]);
		Event Player.IsSetup = True;
	}
}

rule("Replenish needle ammo")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.NeedleCooldown == 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, NeedleAmmo);
		Event Player.NeedleAmmo = 12;
	}
}

rule("Start Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.NeedleCooldown == 0;
		Event Player.NeedleAmmo > 0;
		Event Player.CanNeedle[1] == True;
	}

	actions
	{
		Event Player.NeedleCooldown = Global.Difficulty[2] >= 6 ? 3 : 6;
		Start Holding Button(Event Player.Bots[0], Button(Primary Fire));
		Chase Player Variable At Rate(Event Player, NeedleAmmo, 0, 10, None);
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.NeedleAmmo == 0;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanNeedle[1] == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
	}
}

disabled rule("PHASE 2")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter Phase: 2 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 2;
	}

	actions
	{
		Log To Inspector(Custom String("BroadcastState: Phase 2"));
		Global.ShowBossAbilityInfo[0] = False;
		Call Subroutine(SetCoefficient);
		For Global Variable(BossIndex, 0, Min(2, Global.BossCount) * 2, 1);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Tracer), Team 2));
			Wait(0.016, Abort When False);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Tracer), Team 2));
			Wait(0.016, Abort When False);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Zenyatta), Team 2));
			Wait(0.016, Abort When False);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Wrecking Ball), Team 2));
			Wait(0.016, Abort When False);
		End;
		Start Heal Over Time(Global.Bosses, Null, 16, 10000);
	}
}

rule("Enter Phase: 3")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 2;
		Count Of(Global.BotCreationQueue) == 0;
		Is True For Any(All Living Players(Team 2), Current Array Element.IsMook) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Call Subroutine(SetCoefficient);
		Global.Difficulty[3] = (1 + Global.Difficulty[1] / 2.500) * Square Root(Count Of(Filtered Array(Global.Heroes, Is Alive(Current Array Element))));
		Global.Difficulty[4] = 1 + Global.Difficulty[1] / 30;
		Global.Phase = 3;
	}
}

rule("AI Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For Any(All Living Players(Team 2), Current Array Element.IsMook) == True;
	}

	actions
	{
		Global.Adds = Filtered Array(All Living Players(Team 2), Current Array Element.IsMook && Current Array Element.Master[1] == Null && Current Array Element.IsSetup);
		For Global Variable(AiIndex, 0, Count Of(Global.Adds), 1);
			Global.Add = Global.Adds[Global.AiIndex];
			Call Subroutine(AiStep);
			Wait(0.080, Ignore Condition);
		End;
		Wait(0.080, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AiStep")
{
	event
	{
		Subroutine;
		AiStep;
	}

	actions
	{
		Abort If(Global.Add.Master[1] != Null);
		Call Subroutine(ChooseHThrottle);
		If(Hero Of(Global.Add) == Hero(Tracer));
			Call Subroutine(ChooseVThrottle);
		End;
		If(Global.Add.Target);
			If(!Array Contains(All Living Players(Team 1), Global.Add.Target[0]));
				Global.Add.Target = Null;
				Call Subroutine(LoseTarget);
				Abort;
			End;
			If(Total Time Elapsed > Global.Add.Target[2]);
				Global.Add.Target[1] = Eye Position(Global.Add.Target[0]);
				Global.Add.Target[2] = Total Time Elapsed + 2;
			End;
			If(Global.Add.State == Custom String("Idle"));
				Call Subroutine(TryShoot);
				disabled Else If(Global.Add.State == Custom String("Shoot"));
			End;
			If(Hero Of(Global.Add) == Hero(Zenyatta) && Global.Add.State == Custom String("Idle"));
				Press Button(Global.Add, Button(Ability 1));
			End;
		Else;
			If(Global.Add.State == Custom String("Rise"));
				If(Y Component Of(Position Of(Global.Add)) > 15);
					If(!Global.TestMode[0] || Array Contains(Global.Bosses, Host Player));
						Global.Add.Master[2] = True;
					End;
					Global.Add.State = Custom String("Idle");
				Else;
					Abort;
				End;
			End;
			"Try choose target"
			Global.Add.Target[0] = Sorted Array(Filtered Array(All Living Players(Team 1), !Has Status(Current Array Element, Phased Out) && (
				Current Array Element.Visibility[0] || Current Array Element.Visibility[1])
				&& Current Array Element.Master[0] == Current Array Element), Distance Between(Global.Add, Current Array Element))[0];
			If(Global.Add.Target[0]);
				Global.Add.Target[1] = Eye Position(Global.Add.Target[0]);
				Global.Add.Target[2] = Total Time Elapsed + 2;
				If(Hero Of(Global.Add) == Hero(Wrecking Ball));
					Start Facing(Global.Add, Direction Towards(Eye Position(Evaluate Once(Global.Add)), Evaluate Once(Global.Add).Target[1]),
						Is In Alternate Form(Evaluate Once(Global.Add)) ? 35 : 12.600, To World, Direction and Turn Rate);
				Else If(Hero Of(Global.Add) == Hero(Zenyatta));
					Start Facing(Global.Add, Direction Towards(Eye Position(Evaluate Once(Global.Add)), Evaluate Once(Global.Add).Target[1]), 900 - 4.75 * Absolute Value(Horizontal Angle Towards(Global.Add, Global.Add.Target[1])),
						To World, Direction and Turn Rate);
				Else If(Hero Of(Global.Add) == Hero(Tracer));
					Start Facing(Global.Add, Direction Towards(Eye Position(Evaluate Once(Global.Add)), Evaluate Once(Global.Add).Target[1]),
						Is Firing Primary(Evaluate Once(Global.Add)) ? 12.600 : 45, To World, Direction and Turn Rate);
				End;
			End;
		End;
	}
}

rule("Evaluate add horizontal throttle")
{
	event
	{
		Subroutine;
		ChooseHThrottle;
	}

	actions
	{
		If(Global.Add.Target[1] == Null);
			Global.Add.AI[2] = 0;
		"Add move forward"
		Else If(Magnitude Of(Mapped Array(Vector Towards(Eye Position(Global.Add), Global.Add.Target[1]), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) > 15 && Absolute Value(Horizontal Angle Towards(Global.Add, Global.Add.Target[1])) < 45);
			Global.Add.AI[2] = Hero Of(Global.Add) == Hero(Wrecking Ball) ? 1 : 3;
		"Tracer stop moving forward/backward"
		Else If(Hero Of(Global.Add) == Hero(Tracer) && Absolute Value(Magnitude Of(Mapped Array(Vector Towards(Eye Position(Global.Add), Global.Add.Target[1]), Vector(X Component Of(
			Current Array Element), 0, Z Component Of(Current Array Element)))) - 10.500) < 2.500);
			Global.Add.AI[2] = 2;
		"Tracer move backward"
		Else If(Hero Of(Global.Add) == Hero(Tracer) && Magnitude Of(Mapped Array(Vector Towards(Eye Position(Global.Add), Global.Add.Target[1]), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 6);
			Global.Add.AI[2] = 4;
		"Zen stop moving forward"
		Else If(Hero Of(Global.Add) == Hero(Zenyatta) && Magnitude Of(Mapped Array(Vector Towards(Eye Position(Global.Add), Global.Add.Target[1]), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 11);
			Global.Add.AI[2] = 2;
		"Ball stop moving forward"
		Else If(Hero Of(Global.Add) == Hero(Wrecking Ball) && Magnitude Of(Mapped Array(Vector Towards(Eye Position(Global.Add), Global.Add.Target[1]), Vector(X Component Of(Current Array 	
			Element), 0, Z Component Of(Current Array Element)))) < 4.500);
			Global.Add.AI[2] = 2;
		"Tracer stop moving forward until facing vaguely the right direction"
		Else If(Hero Of(Global.Add) == Hero(Tracer) && Magnitude Of(Mapped Array(Vector Towards(Eye Position(Global.Add), Global.Add.Target[1]), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) > 15 && Absolute Value(Horizontal Angle Towards(Global.Add, Global.Add.Target[1])) > 50);
			Global.Add.AI[2] = 5;
		End;
		If(Global.Add.AI[2] != Global.Add.AI[3] || Total Time Elapsed > Global.Add.AI[0]);
			Global.Add.AI[3] = Global.Add.AI[2];
			If(Global.Add.AI[3] == 1);
				Global.Add.AI[4] = Forward;
			Else If(Global.Add.AI[3] == 2);
				Global.Add.AI[4] = Vector(Random Integer(-1,1),0,0);
			Else If(Global.Add.AI[3] == 3);
				Global.Add.AI[4] = Vector(Random Integer(-1,1),0,1);
			Else If(Global.Add.AI[3] == 4);
				Global.Add.AI[4] = Vector(Random Integer(-1,1),0,-1);
			Else If(Global.Add.AI[3] == 5);
				Global.Add.AI[4] = Vector(Mapped Array(Horizontal Angle Towards(Global.Add, Global.Add.Target[1]), Current Array Element > 0 ? 1 : Current Array Element ? -1 : 0)[0],0,0);
			Else If(Global.Add.AI[3] == 6);
				Global.Add.AI[4] = Vector(Mapped Array(Horizontal Angle Towards(Global.Add, Global.Add.Target[1]), Current Array Element > 0 ? -1 : Current Array Element ? 1 : 0)[0],0,0);
			Else;
				Global.Add.AI[4] = Vector(0,0,0);
			End;
			Global.Add.AI[0] = Total Time Elapsed + Random Real(0.500, 4);
		End;
		Log To Inspector(Custom String("{0}: {1}m {2} deg", Global.Add.Ids[0], Magnitude Of(Mapped Array(Vector Towards(Eye Position(Global.Add), Global.Add.Target[1]), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))), Absolute Value(Horizontal Angle Towards(Global.Add, Global.Add.Target[1]))));
	}
}

rule("Evaluate wisp vertical throttle")
{
	event
	{
		Subroutine;
		ChooseVThrottle;
	}

	actions
	{
		If(Global.Add.Target[1]);
			If(Vertical Angle Towards(Global.Add, Global.Add.Target[1]) > -10 && Vertical Speed Of(Global.Add) > -1 && Is Button Held(
				Global.Add, Button(Jump)));
				Stop Holding Button(Global.Add, Button(Jump));
			End;
			If(Vertical Angle Towards(Global.Add, Global.Add.Target[1]) < 35 && Vertical Speed Of(Global.Add) < 1 && Is Button Held(Global.Add,
				Button(Crouch)));
				Stop Holding Button(Global.Add, Button(Crouch));
			End;
			If(Vertical Angle Towards(Global.Add, Global.Add.Target[1]) < 0 || (Vertical Angle Towards(Global.Add, Global.Add.Target[1])
				< 35 && Vertical Speed Of(Global.Add) < -1));
				Start Holding Button(Global.Add, Button(Jump));
			Else If(Vertical Angle Towards(Global.Add, Global.Add.Target[1]) > 50 || (Vertical Angle Towards(Global.Add, Global.Add.Target[1])
					> -10 && Vertical Speed Of(Global.Add) > 1));
				Start Holding Button(Global.Add, Button(Crouch));
			End;
		Else;
			If(Y Component Of(Position Of(Global.Add)) > 20 && Vertical Speed Of(Global.Add) > -1 && Is Button Held(Global.Add, Button(Jump)));
				Stop Holding Button(Global.Add, Button(Jump));
			End;
			If(Y Component Of(Position Of(Global.Add)) < 20 && Vertical Speed Of(Global.Add) < 1 && Is Button Held(Global.Add, Button(
				Crouch)));
				Stop Holding Button(Global.Add, Button(Crouch));
			End;
			If(Y Component Of(Position Of(Global.Add)) < 15 || (Y Component Of(Position Of(Global.Add)) < 20 && Vertical Speed Of(Global.Add)
				< -1));
				Start Holding Button(Global.Add, Button(Jump));
			Else If(Y Component Of(Position Of(Global.Add)) > 25 || (Y Component Of(Position Of(Global.Add)) > 20 && Vertical Speed Of(
					Global.Add) > 1));
				Start Holding Button(Global.Add, Button(Crouch));
			End;
		End;
	}
}

rule("Add. has no target")
{
	event
	{
		Subroutine;
		LoseTarget;
	}

	actions
	{
		(Event Player != Null ? Event Player : Global.Add).Target = Null;
		Stop Facing(Event Player != Null ? Event Player : Global.Add);
		(Event Player != Null ? Event Player : Global.Add).State = Custom String("Idle");
	}
}

rule("TryShoot")
{
	event
	{
		Subroutine;
		TryShoot;
	}

	actions
	{
		Abort If(Distance Between(Eye Position(Global.Add), Global.Add.Target[1]) > (Hero Of(Global.Add) == Hero(Wrecking Ball) ? 18 : 25));
		Abort If(Distance Between(Eye Position(Global.Add), Global.Add.Target[1]) < 15 && Ultimate Charge Percent(Global.Add) == 100);
		Abort If(Hero Of(Global.Add) == Hero(Tracer) && !Is In View Angle(Global.Add, Global.Add.Target[1], 35));
		Abort If(Hero Of(Global.Add) == Hero(Wrecking Ball) && Ammo(Global.Add, 0) < Max Ammo(Global.Add, 0));
		Abort If(Hero Of(Global.Add) == Hero(Wrecking Ball) && !Is In View Angle(Global.Add, Global.Add.Target[1], 40));
		Global.Add.State = Custom String("Shoot");
		If(Hero Of(Global.Add) == Hero(Wrecking Ball));
			Start Holding Button(Global.Add, Button(Primary Fire));
		End;
	}
}

rule("Add. enter state: idle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.IsMook == True;
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
		Distance Between(Eye Position(Event Player), Event Player.Target[1]) > (Hero Of(Event Player) == Hero(Wrecking Ball) ? 18 : 25);
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Event Player.State = Custom String("Idle");
	}
}

rule("Add. on exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.IsMook == True;
		Event Player.Master[1] == Null;
		Event Player.State != Custom String("Shoot");
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Primary Fire));
		Stop Holding Button(Event Player, Button(Secondary Fire));
	}
}

disabled rule("EXPLODER")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Add. Setup")
{
	event
	{
		Subroutine;
		AddSetup;
	}

	actions
	{
		Set Crouch Enabled(Event Player, False);
		Event Player.WispAcceleration = Vector(0, 0, 0);
		If(Hero Of(Event Player) == Hero(Wrecking Ball));
			Call Subroutine(UpdateStats);
			Event Player.FlameTornadoDamage = 3 * Event Player.BaseDamageMultiplier[2];
			Event Player.BaseMoveSpeedModifier = 55;
			Event Player.ShouldUpdateMoveSpeed = True;
			Start Scaling Player(Event Player, 0.400, False);
			If(Global.Phase == 2);
				Teleport(Event Player, Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0));
			Else;
				Teleport(Event Player, Mapped Array(Mapped Array(Random Value In Array(Filtered Array(All Living Players(Team 1),
					Current Array Element.IsHero)), Current Array Element ? Position Of(Current Array Element)
					- Y Component Of(Position Of(Current Array Element)) * Up + Random Real(10, 30) * Direction From Angles(Random Integer(-179,
					179), 0) : Random Real(0, Global.ArenaRadius - 10) * Direction From Angles(Random Integer(-179, 179), 0)), Min(
					Global.ArenaRadius - 1, Magnitude Of(Current Array Element)) * Normalize(Current Array Element))[0]);
			End;
			Event Player.Ids[0] = Random Value In Array(Remove From Array(Global.BallNames, Mapped Array(All Players(Team 2),
				Current Array Element.Ids[0])));
			If(Event Player.Ids[0] == Null);
				Event Player.Ids[0] = Random Value In Array(Global.BallNames);
			End;
			Start Forcing Dummy Bot Name(Event Player, Event Player.Ids[0]);
			Play Effect(All Players(All Teams), Reaper Wraith Form Sound, Color(White), Position Of(Event Player), 100);
			If(!Global.TestMode[0] || Array Contains(Global.Bosses, Host Player));
				Event Player.Master[2] = True;
			End;
			Event Player.State = Custom String("Idle");
		Else If(Hero Of(Event Player) == Hero(Zenyatta));
			Set Knockback Received(Event Player, 55);
			Chase Player Variable At Rate(Event Player, DashCooldown, 0, 1, None);
			Call Subroutine(UpdateStats);
			Start Scaling Player(Event Player, 1.150, False);
			If(Global.Phase == 2);
				Teleport(Event Player, 2.500 * Up + Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0));
			Else;
				Teleport(Event Player, 2.500 * Up + Mapped Array(Mapped Array(Random Value In Array(Filtered Array(All Living Players(Team 1),
					Current Array Element.IsHero)), Current Array Element ? Position Of(Current Array Element)
					- Y Component Of(Position Of(Current Array Element)) * Up + Random Real(10, 30) * Direction From Angles(Random Integer(-179,
					179), 0) : Random Real(0, Global.ArenaRadius - 10) * Direction From Angles(Random Integer(-179, 179), 0)), Min(
					Global.ArenaRadius - 1, Magnitude Of(Current Array Element)) * Normalize(Current Array Element))[0]);
			End;
			Set Max Ammo(Event Player, 0, 1);
			Event Player.Ids[0] = Random Value In Array(Remove From Array(Global.ZenyattaNames, Mapped Array(All Players(Team 2),
				Current Array Element.Ids[0])));
			If(Event Player.Ids[0] == Null);
				Event Player.Ids[0] = Random Value In Array(Global.ZenyattaNames);
			End;
			Start Forcing Dummy Bot Name(Event Player, Event Player.Ids[0]);
			Play Effect(All Players(All Teams), Pharah Barrage Explosion Sound, Color(White), Position Of(Event Player), 100);
			If(!Global.TestMode[0] || Array Contains(Global.Bosses, Host Player));
				Event Player.Master[2] = True;
			End;
			Event Player.State = Custom String("Idle");
		Else If(Hero Of(Event Player) == Hero(Tracer));
			Set Knockback Received(Event Player, 70);
			Call Subroutine(UpdateStats);
			Set Jump Enabled(Event Player, False);
			Start Scaling Player(Event Player, 1.150, False);
			Teleport(Event Player, Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0) + Random Real(10, 13) * Up);
			If(Global.TestMode[0]);
				disabled Create HUD Text(Global.Phase == 2 ? All Players(All Teams) : Null, Slot Of(Event Player), Null, Absolute Value(
					Horizontal Angle Towards(Event Player, Event Player.Target[1])), Left, 0, Color(White), Color(White), Color(White),
					Visible To and String, Default Visibility);
			End;
			Event Player.Ids[0] = Random Value In Array(Remove From Array(Global.TracerNames, Mapped Array(All Players(Team 2),
				Current Array Element.Ids[0])));
			If(Event Player.Ids[0] == Null);
				Event Player.Ids[0] = Random Value In Array(Global.TracerNames);
			End;
			Start Forcing Dummy Bot Name(Event Player, Event Player.Ids[0]);
			If(Global.Difficulty[2] >= 6);
				Set Ultimate Charge(Event Player, 50);
			End;
			Event Player.State = Custom String("Rise");
		End;
		Event Player.IsSetup = True;
	}
}

rule("Exploder exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Target[1] != Null;
		Event Player.State == Custom String("Shoot");
		Ammo(Event Player, 0) == 0;
		Is In View Angle(Event Player, Event Player.Target[1], 40) == False;
	}

	actions
	{
		Wait(0.150, Abort When False);
		Event Player.State = Custom String("Idle");
	}
}

rule("Exploder go into ball form")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Idle");
		Is In Alternate Form(Event Player) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Ability 1));
		Wait Until(Is In Alternate Form(Event Player), 3);
		Stop Holding Button(Event Player, Button(Ability 1));
		Wait(0.500, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Exploder jump")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Target[1] != Null;
		Is On Ground(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
		Magnitude Of(Throttle Of(Event Player)) > 0.200;
	}

	actions
	{
		Press Button(Event Player, Button(Jump));
	}
}

disabled rule("GOLEM")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Golem slow")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Shoot");
		Event Player.BaseMoveSpeedModifier = 60;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Golem normal speed")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.State != Custom String("Dashing");
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 100;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Golem dash cooldown")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.State != Custom String("Dashing");
	}

	actions
	{
		Event Player.DashCooldown = Global.Difficulty[2] >= 6 ? 1 : 2;
	}
}

rule("Golem fast")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.State == Custom String("Dashing");
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 260;
		Event Player.ShouldUpdateMoveSpeed = True;
		Start Throttle In Direction(Event Player, Mapped Array(Throttle Of(Event Player), Magnitude Of(Current Array Element)
			== 0 ? Forward : Current Array Element), 1, To Player, Replace existing throttle, None);
		Log To Inspector(Custom String("{0}: dash throttle", Event Player.Ids[0]));
		Wait(1.200, Abort When False);
		Event Player.State = Custom String("Idle");
	}
}

rule("Golem dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Is Firing Secondary(Event Player) == False;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
		Event Player.State != Custom String("Dashing");
		Event Player.DashCooldown == 0;
	}

	actions
	{
		Event Player.State = Custom String("Dashing");
	}
}

rule("On enter state: shoot (Golem)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Start Holding Button(Event Player, Button(Secondary Fire));
		Loop;
	}
}

disabled rule("WISP")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Wisp gravity on")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) > 45;
	}

	actions
	{
		Set Gravity(Event Player, 100);
	}
}

rule("Wisp gravity off")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < 25;
	}

	actions
	{
		Set Gravity(Event Player, 0);
	}
}

rule("Wisp on enter state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
	}

	actions
	{
		Wait(2, Abort When False);
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Wisp exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Target[1] != Null;
		Event Player.State == Custom String("Shoot");
		Is In View Angle(Event Player, Event Player.Target[1], 35) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Event Player.State = Custom String("Idle");
	}
}

rule("Wisp is shooting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		If(Magnitude Of(Event Player.WispAcceleration));
			Event Player.WispAcceleration = 4 * Normalize(Event Player.WispAcceleration);
		End;
		Event Player.BaseMoveSpeedModifier = 40;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Wisp is not shooting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Is Firing Primary(Event Player) == False;
	}

	actions
	{
		If(Magnitude Of(Event Player.WispAcceleration));
			Event Player.WispAcceleration = 10 * Normalize(Event Player.WispAcceleration);
		End;
		"Was 115, but nerfed slightly to make them grouping up take longer"
		Event Player.BaseMoveSpeedModifier = 100;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Wisp descent")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Stunned) == False;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Event Player.WispAcceleration = Down * (Is Firing Primary(Event Player) ? 4 : 10);
		Start Rule(DetermineAcceleration, Restart Rule);
	}
}

rule("Wisp ascent")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Stunned) == False;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Event Player.WispAcceleration = Up * (Is Firing Primary(Event Player) ? 4 : 10);
		Start Rule(DetermineAcceleration, Restart Rule);
	}
}

rule("Wisp enter state: ult")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Array Contains(Array(Custom String("Idle"), Custom String("Shoot")), Event Player.State) == True;
		Event Player.Target[1] != Null;
		Distance Between(Eye Position(Event Player), Event Player.Target[1]) < 15;
		Is In View Angle(Event Player, Event Player.Target[1], 40) == True;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Event Player.State = Custom String("Ult");
	}
}

rule("Wisp on enter state: ult")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Ult");
	}

	actions
	{
		Start Holding Button(Event Player, Button(Ultimate));
		Wait Until(Ultimate Charge Percent(Event Player) < 75, 5);
		Stop Holding Button(Event Player, Button(Ultimate));
		Wait Until(!Event Player.IsUsingUltimate, 5);
		Event Player.State = Custom String("Idle");
	}
}

rule("Wisp extra hard mode")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Ultimate Charge Percent(Event Player) < 50;
		Global.Difficulty[2] >= 6;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 50);
	}
}

rule("Wisp stop accelerating")
{
	event
	{
		Ongoing - Each Player;
		All;
		Tracer;
	}

	conditions
	{
		(Has Status(Event Player, Stunned) || !(Is Button Held(Event Player, Button(Crouch)) || Is Button Held(Event Player, Button(
			Jump)))) == True;
	}

	actions
	{
		Event Player.WispAcceleration = Vector(0, 0, 0);
		Start Rule(DetermineAcceleration, Restart Rule);
	}
}

rule("On enter Phase 2 (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 2;
		(Event Player.Target == Null || Is Dead(Event Player.Target) || Is Button Held(Event Player, Button(Interact))) == True;
	}

	actions
	{
		Wait(1.800, Abort When False);
		Start Rule(ChooseAdd, Do Nothing);
	}
}

rule("Choose Target Subroutine")
{
	event
	{
		Subroutine;
		ChooseAdd;
	}

	actions
	{
		Event Player.Target.Master[1] = Null;
		Event Player.Target = Null;
		While(Event Player.Target == Null && Global.Phase == 2);
			Random Value In Array(Filtered Array(All Living Players(Team 2), Current Array Element.IsMook
				&& Current Array Element.Master[1] == Null && Current Array Element.Master[2])).Master[1] = Event Player;
			Event Player.Target = Filtered Array(All Players(Team 2), Current Array Element.Master[1] == Event Player)[0];
			Wait(0.500, Ignore Condition);
		End;
		If(Event Player.Target == Null);
			Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Else;
			Start Camera(Event Player, Eye Position(Event Player.Target) + (Is In Alternate Form(Event Player.Target) ? -1 : 1) * Facing Direction Of(Event Player.Target), Eye Position(
				Event Player.Target) + 5 * Facing Direction Of(Event Player.Target), 30);
			Stop Forcing Throttle(Event Player);
			Event Player.Target.AI[4] = Vector(0, 0, 0);
			If(!Is Button Held(Event Player, Button(Primary Fire)));
				Stop Holding Button(Event Player.Target, Button(Primary Fire));
			End;
			If(!Is Button Held(Event Player, Button(Secondary Fire)));
				Stop Holding Button(Event Player.Target, Button(Secondary Fire));
			End;
			If(!Is Button Held(Event Player, Button(Ability 1)));
				Stop Holding Button(Event Player.Target, Button(Ability 1));
			End;
			If(!Is Button Held(Event Player, Button(Ultimate)));
				Stop Holding Button(Event Player.Target, Button(Ultimate));
			End;
			If(!Is Button Held(Event Player, Button(Jump)) && Hero Of(Event Player.Target) != Hero(Wrecking Ball));
				Stop Holding Button(Event Player.Target, Button(Jump));
			End;
			If(!Is Button Held(Event Player, Button(Crouch)));
				Stop Holding Button(Event Player.Target, Button(Crouch));
			End;
			If(!Is Button Held(Event Player, Button(Reload)));
				Stop Holding Button(Event Player.Target, Button(Reload));
			End;
		End;
	}
}

rule("Add stunned")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Has Status(Event Player.Target, Stunned) == True;
	}

	actions
	{
		Big Message(Event Player, String("Stunned"));
	}
}

rule("Add Start Facing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[1] != Null;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Start Facing(Event Player, Facing Direction Of(Event Player.Master[1]), 2000, To World, Direction and Turn Rate);
	}
}

rule("Master controlled throttle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[1] != Null;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
		Event Player.State != Custom String("Dashing");
	}

	actions
	{
		Start Throttle In Direction(Event Player, Throttle Of(Event Player.Master[1]), Magnitude Of(Throttle Of(Event Player.Master[1])),
			To Player, Replace existing throttle, Direction and Magnitude);
		Log To Inspector(Custom String("{0}: controlled throttle", Event Player.Ids[0]));
	}
}

rule("AI Throttle")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
		Event Player.State != Custom String("Dashing");
		Magnitude Of(Event Player.AI[4]) != 0;
	}

	actions
	{
		Start Throttle In Direction(Event Player, Event Player.AI[4], 1, To Player, Replace existing throttle, Direction and Magnitude);
		Log To Inspector(Custom String("{0}: ai throttle", Event Player.Ids[0]));
	}
}

rule("Stop Throttle in direction")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
		Event Player.State != Custom String("Dashing");
		Magnitude Of(Event Player.AI[4]) == 0;
	}

	actions
	{
		Stop Throttle In Direction(Event Player);
		Log To Inspector(Custom String("{0}: stop throttle", Event Player.Ids[0]));
	}
}

rule("Add Stop Facing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		(Event Player.Master[1] == Null || Has Status(Event Player, Stunned)) == True;
	}

	actions
	{
		Stop Facing(Event Player);
	}
}

rule("Add Start Holding Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Primary Fire));
	}
}

rule("Add Stop Holding Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Primary Fire));
	}
}

rule("Add Start Holding Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Secondary Fire));
	}
}

rule("Add Stop Holding Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Secondary Fire));
	}
}

rule("Add Start Holding Ability 1")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Ability 1));
	}
}

rule("Add Stop Holding Ability 1")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Ability 1));
	}
}

rule("Add Start Holding Ultimate button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Ultimate));
	}
}

rule("Add Stop Holding Ultimate button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ultimate)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Ultimate));
	}
}

rule("Add Start Holding Jump button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Hero Of(Event Player.Target) != Hero(Wrecking Ball);
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Jump));
	}
}

rule("Add Stop Holding Jump button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Hero Of(Event Player.Target) != Hero(Wrecking Ball);
		Is Button Held(Event Player, Button(Jump)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Jump));
	}
}

rule("Add Start Holding Crouch button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Crouch));
	}
}

rule("Add Stop Holding Crouch button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Crouch)) == False;
		Is Button Held(Event Player.Target, Button(Crouch)) == True;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Crouch));
	}
}

rule("Add Start Holding Reload button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Reload));
	}
}

rule("Add Stop Holding Reload button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Reload)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Reload));
	}
}

rule("Stop Phase 2 camera")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Global.Phase == 2 && Event Player.Target) == False;
	}

	actions
	{
		Stop Camera(Event Player);
	}
}

disabled rule("PHASE 3")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Phase 3 Start (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 3;
	}

	actions
	{
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Orisa), Event Player));
		Stop All Heal Over Time(Event Player);
		Event Player.Target = Null;
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Stop Chasing Player Variable(Event Player, TakeoffCooldown);
		Event Player.CanNeedle = Array(False, False);
		Call Subroutine(CleanseAllDebuffs);
		Call Subroutine(UpdateStats);
		Wait(3, Abort When False);
		Event Player.ShowBossInfo[0] = True;
		Event Player.State = Custom String("Landing");
	}
}

rule("On Phase 3 Start (Team 1)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.Phase == 3;
	}

	actions
	{
		Abort If(!Event Player.IsHero);
		Start Rule(PrepareSounds, Do Nothing);
		Wait(0.200, Abort When False);
		Start Rule(SoundCue, Restart Rule);
	}
}

rule("On Enter Phase: 3 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 3;
	}

	actions
	{
		Log To Inspector(Custom String("BroadcastState: Phase 3"));
		Global.ShowBossAbilityInfo[0] = True;
		Wait(4, Abort When False);
		Global.Director[0] = 300;
		Call Subroutine(SetCoefficient);
		While(True);
			Call Subroutine(TrySpawn);
			Wait(Global.Director[1], Abort When False);
			Global.Director[0] += Global.Director[1] * (1 + 0.400 * Global.Difficulty[1]) * (Global.PlayerCount + 1) / 2;
		End;
	}
}

rule("Try Spawn")
{
	event
	{
		Subroutine;
		TrySpawn;
	}

	actions
	{
		If(!Is True For Any(Global.AvailableBotSlots, X Component Of(Current Array Element) == 2));
			Global.Director[5] = False;
		Else;
			If(!Global.Director[5]);
				If(Random Real(0, 1) < 0.200);
					Global.Director[2] = 0;
				Else If(Random Real(0, 1) < 0.750);
					Global.Director[2] = 1;
				Else;
					Global.Director[2] = 2;
				End;
				Global.Director[3] = Array(80, 350, 550)[Global.Director[2]];
				Global.Director[7] = 0;
			End;
			If(Global.Director[0] < Global.Director[3] || (Global.Director[0] >= 36 * Global.Director[3] && Global.Director[2] < 2)
				|| Global.Director[7] > 5);
				Global.Director[5] = False;
			Else;
				Global.Director[5] = True;
				Global.Director[0] -= Global.Director[3];
				Global.Director[6] = Global.BossCount;
				While(Global.Director[6] > 0);
					Modify Global Variable(BotCreationQueue, Append To Array, Array(Array(Hero(Wrecking Ball), Hero(Zenyatta), Hero(Tracer))
						[Global.Director[2]], Team 2));
					Global.Director[6] -= 1;
				End;
				Global.Director[7] += 1;
			End;
		End;
		If(Global.Director[5]);
			Global.Director[1] = Random Real(0.100, 1);
		Else;
			Global.Director[1] = Random Real(4.500, 9);
			Call Subroutine(SetCoefficient);
		End;
	}
}

rule("Pizza Time")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.PizzaIndex == Custom String("Soon");
		Event Player.PizzaTime[0] != Null;
		Total Time Elapsed > Event Player.PizzaTime[0];
	}

	actions
	{
		If(Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) && Ultimate Charge Percent(
			Event Player) > 95 && !Has Status(Event Player, Stunned) && !Event Player.IsHacked && Is On Ground(Event Player));
			Event Player.State = Custom String("Pizza");
		Else;
			Event Player.PizzaIndex = Custom String("ASAP");
		End;
		Event Player.PizzaTime[0] = Null;
	}
}

rule("Enter State: Pizza")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.PizzaIndex == Custom String("ASAP");
		Event Player.State == Custom String("Idle");
		Has Status(Event Player, Stunned) == False;
		Event Player.IsHacked == False;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Pizza");
	}
}

rule("On Enter State: Pizza")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage"), Custom String("PizzaWait")), Event Player.State)
			== True;
		Event Player.HasLostThisPhase == False;
	}

	actions
	{
		Event Player.CanSwing = False;
		Event Player.CanSlam[0] = False;
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Start Holding Button(Event Player, Button(Crouch));
		For Player Variable(Event Player, PizzaIndex, 0, 5, 1);
			Abort If Condition Is False;
			Event Player.State = Custom String("Pizza");
			Chase Player Variable At Rate(Event Player, PizzaAngle, Event Player.PizzaAngle + 10 * Event Player.PizzaAngularVelocity,
				Absolute Value(Event Player.PizzaAngularVelocity), Destination and Rate);
			Event Player.PizzaAngularVelocity = Random Value In Array(Array(1, -1)) * 50;
			Event Player.PizzaAngle = Random Integer(0, 180);
			Event Player.PizzaTime[1] = Total Time Elapsed + 0.700;
			Wait(0.700, Abort When False);
			Stop Chasing Player Variable(Event Player, PizzaAngle);
			"doesn't dynamically update with NumDeathLines"
			Event Player.Victims = Remove From Array(Filtered Array(All Living Players(Team 1), !Has Status(Current Array Element, Phased Out) && Absolute Value(Cosine From Degrees(
				Event Player.PizzaAngle) * X Component Of(Vector Towards(Current Array Element, Event Player)) - Sine From Degrees(
				Event Player.PizzaAngle) * Z Component Of(Vector Towards(Current Array Element, Event Player)))
				< Global.DeathLineRadius || Absolute Value(Cosine From Degrees(Event Player.PizzaAngle + 45) * X Component Of(Vector Towards(
				Current Array Element, Event Player)) - Sine From Degrees(Event Player.PizzaAngle + 45) * Z Component Of(Vector Towards(
				Current Array Element, Event Player))) < Global.DeathLineRadius || Absolute Value(Cosine From Degrees(
				Event Player.PizzaAngle + 90) * X Component Of(Vector Towards(Current Array Element, Event Player)) - Sine From Degrees(
				Event Player.PizzaAngle + 90) * Z Component Of(Vector Towards(Current Array Element, Event Player)))
				< Global.DeathLineRadius || Absolute Value(Cosine From Degrees(Event Player.PizzaAngle + 135) * X Component Of(Vector Towards(
				Current Array Element, Event Player)) - Sine From Degrees(Event Player.PizzaAngle + 135) * Z Component Of(Vector Towards(
				Current Array Element, Event Player))) < Global.DeathLineRadius), Global.NullPlayer);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player), 100);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player) + 49.497 * Direction From Angles(Event Player.PizzaAngle, -45), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player)+ 49.497 * Direction From Angles(Event Player.PizzaAngle, -45), 100);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player) + 49.497 * Direction From Angles(Event Player.PizzaAngle + 60, -45), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player)+ 49.497 * Direction From Angles(Event Player.PizzaAngle + 60, -45), 100);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player) + 49.497 * Direction From Angles(Event Player.PizzaAngle + 120, -45), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player)+ 49.497 * Direction From Angles(Event Player.PizzaAngle + 120, -45), 100);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player) + 49.497 * Direction From Angles(Event Player.PizzaAngle + 180, -45), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player)+ 49.497 * Direction From Angles(Event Player.PizzaAngle + 180, -45), 100);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player) + 49.497 * Direction From Angles(Event Player.PizzaAngle + 240, -45), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player)+ 49.497 * Direction From Angles(Event Player.PizzaAngle + 240, -45), 100);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player) + 49.497 * Direction From Angles(Event Player.PizzaAngle + 300, -45), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player)+ 49.497 * Direction From Angles(Event Player.PizzaAngle + 300, -45), 100);
			Event Player.Victims.CauseOfDeath[1] = Custom String("Spinning lines of death");
			Damage(Event Player.Victims, Event Player, 9 * Event Player.BaseDamageMultiplier[2]);
			Apply Impulse(Event Player.Victims, Up, 8, To World, Incorporate Contrary Motion);
			Event Player.State = Custom String("PizzaDamage");
			Wait(0.100, Ignore Condition);
			Modify Player Variable(Filtered Array(Event Player.Victims, Current Array Element.DebuffShield[0] <= 0), CrippleTime, Max, 3);
			Filtered Array(Event Player.Victims, Current Array Element.DebuffShield[0] > 0).DebuffShield[3] += 1;
			Filtered Array(Event Player.Victims, Current Array Element.DebuffShield[0] > 0).DebuffShield[0] -= 1;
			Wait(0.100, Abort When False);
			Event Player.State = Custom String("PizzaWait");
			Wait(1.200, Abort When False);
		End;
		Event Player.PizzaIndex = Custom String("Dormant");
		Stop Holding Button(Event Player, Button(Crouch));
		Chase Player Variable At Rate(Event Player, TakeoffCooldown, 0, 1, None);
		Call Subroutine(ChooseState);
	}
}

rule("Destroy Flame Pillar")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.FlamePillars) > 0;
		Total Time Elapsed > Global.FlamePillarExpirationTimes[0];
	}

	actions
	{
		Destroy Effect(Global.FlamePillars[0]);
		Modify Global Variable(FlamePillarPositions, Remove From Array By Index, 0);
		Modify Global Variable(FlamePillarExpirationTimes, Remove From Array By Index, 0);
		Modify Global Variable(FlamePillars, Remove From Array By Index, 0);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Flame Pillar Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsHero == True;
		Is True For Any(Global.FlamePillarPositions, Distance Between(Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(
			Position Of(Event Player))), Vector(X Component Of(Current Array Element), 0, Z Component Of(Current Array Element))) < 1)
			== True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Set Status(Event Player, Global.NullPlayer[1], Burning, 0.250);
		Event Player.CauseOfDeath[1] = Array(Null, Custom String("Flame Pillar"));
		Damage(Event Player, Global.NullPlayer[1], 0.625 * Last Of(Sorted Array(Mapped Array(Global.Bosses, Current Array Element.BaseDamageMultiplier[1]), Current Array Element)));
		Wait(0.200, Abort When False);
		Loop If Condition Is True;
	}
}

disabled rule("PHASE 4")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter Phase: 4 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 4;
	}

	actions
	{
		Log To Inspector(Custom String("BroadcastState: Phase 4"));
		Global.ShowBossAbilityInfo[0] = False;
		Wait(0.500, Ignore Condition);
		Kill(Filtered Array(All Players(Team 2), Current Array Element.IsMook), Global.NullPlayer[0]);
		Wait Until(Is True For All(Global.Bosses, Current Array Element.State == Custom String("Stealing")), 9999);
		Global.Stealees = Filtered Array(Global.Heroes, !Current Array Element.IsDead);
		Global.BossIndex = 0;
		While(Count Of(Global.Stealees) > 0);
			Global.Stealer = Global.Bosses[Global.BossIndex];
			Global.CurrentStealee = Global.Stealees[Global.StealeeIndex];
			Wait Until(Count Of(Global.ItemStackUpdateInfos) == 0, 3);
			If(Count Of(Global.CurrentStealee.MyItemStacks) == 0);
				Modify Global Variable(Stealees, Remove From Array By Index, Global.StealeeIndex);
			Else;
				Global.ItemStackBeingStolenIndex = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
					Global.ItemStacks[Current Array Element] == Global.CurrentStealee.MyItemStacks[0] && Global.ItemStackOwners[Current Array Element] == Global.CurrentStealee);
				If(Count Of(Global.ItemStackBeingStolenIndex) == 0);
					Small Message(Host Player, Custom String("Item Steal Error"));
					Modify Global Variable(Stealees, Remove From Array By Index, Global.StealeeIndex);
				Else;
					Global.ItemStackBeingStolenIndex = Global.ItemStackBeingStolenIndex[0];
					Call Subroutine(Steal);
					Global.StealeeIndex += 1;
				End;
				Global.BossIndex = (Global.BossIndex + 1) % Count Of(Global.Bosses);
			End;
			Global.StealeeIndex %= Count Of(Global.Stealees);
			Wait(0.250, Abort When False);
		End;
		Wait Until(Is True For All(Global.ItemStackNewOwners, Current Array Element == Null), 99999);
		Global.Bosses.State = Custom String("StealingFinished");
	}
}

rule("On Enter Phase: 4 (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 4;
	}

	actions
	{
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 55;
		Event Player.ShouldUpdateMoveSpeed = True;
		Event Player.CanNeedle = Array(True, False);
		Clear Status(Event Player, Unkillable);
		Teleport(Event Player, Vector(0, 0, 0));
		"Add Armour Boost"
		Event Player.ArmourModifiers[1] = 200;
		Event Player.ShouldUpdateDamageReceived = True;
		Call Subroutine(CleanseAllDebuffs);
		Call Subroutine(UpdateStats);
		Set Invisible(Event Player, None);
		Event Player.PizzaIndex = Custom String("Dormant");
		Start Facing(Event Player, Vector(0, -0.999, 0.035), 1000, To Player, None);
		Wait(5.750, Abort When False);
		Start Holding Button(Event Player, Button(Crouch));
		Wait(0.250, Abort When False);
		Start Facing(Event Player, Vector(0, 0.999, 0.035), 1000, To Player, None);
		Disallow Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Crouch));
		Event Player.CanUseOrbs = False;
		Event Player.ShowBossInfo[0] = True;
		Event Player.ShowBossInfo[1] = 1;
		Event Player.State = Custom String("Stealing");
		Wait Until(Event Player.State == Custom String("StealingFinished"), 9999);
		Event Player.HealthPerItemStack = 1 / (Count Of(Event Player.ItemStackReturnInfo) / 2);
		Clear Status(Event Player, Phased Out);
		Allow Button(Event Player, Button(Crouch));
		Start Holding Button(Event Player, Button(Crouch));
		Start Facing(Event Player, Vector(0, -0.999, 0.035), 1000, To Player, None);
		Wait(4, Abort When False);
		Stop Facing(Event Player);
		Disallow Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Crouch));
		Abort If(Event Player.IsDead);
		Wait(1, Abort When False);
		Allow Button(Event Player, Button(Crouch));
		"Remove Armour Boost (as late as possible)"
		Event Player.ArmourModifiers[1] = 0;
		Start Rule(UpdateDamageReceived, Restart Rule);
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("On Enter Phase: 4 (Team 1)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.Phase == 4;
	}

	actions
	{
		Call Subroutine(PrepareForDebuffs);
	}
}


rule("Press Orb Button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 4;
		Global.TestMode[0] == True;
		Is Button Held(Host Player, Button(Interact)) == True;
	}

	actions
	{
		Press Button(Event Player, Button(Ability 2));
	}
}

rule("Enter State: Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 4;
		Event Player.CanUseOrbs == True;
		Event Player.State == Custom String("Idle");
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Orbs");
		Event Player.CanNeedle[1] = False;
		Start Facing(Event Player, Vector(0, -1, 1), 120, To Player, None);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Start Holding Button(Event Player, Button(Crouch));
		Event Player.OrbCreationIndex = Array(0);
		"May want to do more to ensure two bosses simultaneously creating orbs doesn't break this"
		While(Event Player.OrbCreationIndex[0] < 8);
			Event Player.NewOrbGlobalIndex = Remove From Array(Mapped Array(Global.OrbCreators,
				Current Array Element == Null ? Current Array Index + 1 : 0), 0)[0];
			If(Event Player.NewOrbGlobalIndex == 0);
				Modify Global Variable(OrbCreators, Append To Array, Null);
				Event Player.NewOrbGlobalIndex = Remove From Array(Mapped Array(Global.OrbCreators,
				Current Array Element == Null ? Current Array Index + 1 : 0), 0)[0];
			End;
			Event Player.NewOrbGlobalIndex -= 1;
			Global.OrbCreators[Event Player.NewOrbGlobalIndex] = Event Player;
			Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex] = Mapped Array(Position Of(Event Player),
				Current Array Element - Y Component Of(Current Array Element) * Up)[0];
			Global.OrbDisplayPositions[Event Player.NewOrbGlobalIndex] = Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex] + Up;
			Global.OrbInitialAngles[Event Player.NewOrbGlobalIndex] = Horizontal Facing Angle Of(Event Player) + (
				0.500 - Event Player.OrbCreationIndex[0]) * 45;
			Wait(0.032, Ignore Condition);
			Create Effect(All Players(All Teams), Orb, Color(White), Global.OrbDisplayPositions[Evaluate Once(Event Player.NewOrbGlobalIndex)],
				0.750, Visible To Position and Radius);
			Global.OrbEffects[Event Player.NewOrbGlobalIndex * 2] = Last Created Entity;
			Create Effect(All Players(All Teams), Orisa Amplifier Sound, Color(White), Global.OrbDisplayPositions[Evaluate Once(
				Event Player.NewOrbGlobalIndex)], 100, Visible To Position and Radius);
			Global.OrbSounds[Event Player.NewOrbGlobalIndex] = Last Created Entity;
			Modify Player Variable(Event Player, OrbCreationIndex, Append To Array, Event Player.NewOrbGlobalIndex);
			Event Player.OrbCreationIndex[0] += 1;
		End;
		Wait Until(Is Dead(Event Player), 1.250);
		Abort If(Is Dead(Event Player));
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 100);
		Event Player.CauseOfDeath = Array(Null, Custom String("Your own stupidity"));
		Damage(Event Player, Global.NullPlayer[0], 0.080 * Health(Event Player) / (Event Player.HealthScale[2] * Event Player.HealthScale[5]));
		Event Player.OrbCreationIndex[0] = 1;
		"May want to do more to ensure two bosses simultaneously creating orbs doesn't break this"
		While(Event Player.OrbCreationIndex[0] < Count Of(Event Player.OrbCreationIndex));
			Wait(0.016, Ignore Condition);
			Event Player.NewOrbGlobalIndex = Event Player.OrbCreationIndex[Event Player.OrbCreationIndex[0]];
			Global.OrbCreationTimes[Event Player.NewOrbGlobalIndex] = Total Time Elapsed;
			Global.OrbDisplayPositions[Event Player.NewOrbGlobalIndex] = Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex];
			Global.PreviousOrbPositions[Event Player.NewOrbGlobalIndex] = Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex];
			Global.OrbPositions[Event Player.NewOrbGlobalIndex] = Global.PreviousOrbPositions[Event Player.NewOrbGlobalIndex];
			Create Effect(All Players(All Teams), Ring, Color(Blue), Global.OrbDisplayPositions[Evaluate Once(Event Player.NewOrbGlobalIndex)],
				2, Visible To Position and Radius);
			Global.OrbEffects[Event Player.NewOrbGlobalIndex * 2 + 1] = Last Created Entity;
			Event Player.OrbCreationIndex[0] += 1;
		End;
		Stop Facing(Event Player);
		Wait Until(Is Dead(Event Player), 1.500);
		Stop Holding Button(Event Player, Button(Crouch));
		Abort If(Is Dead(Event Player));
		Wait Until(Is Dead(Event Player), 1);
		Abort If(Is Dead(Event Player));
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("Orb Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For Any(Global.OrbPositions, Current Array Element != Null) == True;
	}

	actions
	{
		While(Is True For Any(Global.OrbPositions, Current Array Element != Null));
			For Global Variable(OrbEvaluationIndex, 0, Count Of(Global.OrbPositions), 1);
				Wait(0.016, Ignore Condition);
				Call Subroutine(HandleOrb);
				Global.OrbDisplayPositions = Mapped Array(Mapped Array(Global.OrbCreationTimes, 0.800 * (Total Time Elapsed - Current Array Element)),
					Global.OrbPositions[Current Array Index] ? Global.OrbInitialPositions[Current Array Index] + 50 * Square Root(3.250 / (
					1 + Absolute Value(1.500 * Sine From Radians(0.524 * Current Array Element)) ^ 2)) * Sine From Radians(
					0.524 * Current Array Element) * Direction From Angles(
					Global.OrbInitialAngles[Current Array Index] - 22.500 * Current Array Element, 0) : Null);
			End;
		End;
	}
}

rule("Handle Orb")
{
	event
	{
		Subroutine;
		HandleOrb;
	}

	actions
	{
		Abort If(Global.OrbPositions[Global.OrbEvaluationIndex] == Null);
		Global.PreviousOrbPositions[Global.OrbEvaluationIndex] = Global.OrbPositions[Global.OrbEvaluationIndex];
		Global.OrbPositions[Global.OrbEvaluationIndex] = Global.OrbDisplayPositions[Global.OrbEvaluationIndex];
		Global.OrbPositionDeltas[Global.OrbEvaluationIndex] = Global.OrbPositions[Global.OrbEvaluationIndex] - Global.PreviousOrbPositions[Global.OrbEvaluationIndex];
		Global.OrbVictims = Filtered Array(Remove From Array(All Living Players(Team 1), Global.NullPlayer[0]), !Has Status(Current Array Element, Phased Out) && Distance Between(Current Array Element,
			Global.OrbPositions[Global.OrbEvaluationIndex]) < 1.500 || Distance Between(Current Array Element,
			Global.PreviousOrbPositions[Global.OrbEvaluationIndex]) < 1.500 || (Absolute Value(Dot Product(Vector Towards((Global.PreviousOrbPositions[Global.OrbEvaluationIndex] + Global.OrbPositions[Global.OrbEvaluationIndex]) / 2, Current Array Element), Normalize(Global.OrbPositionDeltas[Global.OrbEvaluationIndex]))) < Magnitude Of(Global.OrbPositionDeltas[Global.OrbEvaluationIndex]) / 2 && Magnitude Of(Cross Product(Vector Towards(Global.PreviousOrbPositions[Global.OrbEvaluationIndex], Current Array Element), Vector Towards(Global.OrbPositions[Global.OrbEvaluationIndex], Current Array Element))) / Magnitude Of(Global.OrbPositionDeltas[Global.OrbEvaluationIndex]) < 1.500));
		If(Count Of(Global.OrbVictims) > 0);
			Apply Impulse(Global.OrbVictims, Direction From Angles(Horizontal Angle From Direction(Global.OrbPositions[Global.OrbEvaluationIndex] - Global.PreviousOrbPositions[Global.OrbEvaluationIndex]), -25), 10, To World, Cancel Contrary Motion);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Blue), Global.OrbDisplayPositions[Global.OrbEvaluationIndex], 2);
			Global.OrbVictims.CauseOfDeath[1] = Custom String("Orb");
			Damage(Global.OrbVictims, Global.OrbCreators[Global.OrbEvaluationIndex], 4 * Global.OrbCreators[Global.OrbEvaluationIndex].BaseDamageMultiplier[2]);
			"Don't set effect to null, to ensure this is definitely destroyed."
			Call Subroutine(DestroyOrb);
		Else If(Total Time Elapsed > Global.OrbCreationTimes[Global.OrbEvaluationIndex] + 9 / 0.800);
			"Don't set effect to null, to ensure this is definitely destroyed."
			Call Subroutine(DestroyOrb);
		End;
	}
}

rule("Destroy Orb")
{
	event
	{
		Subroutine;
		DestroyOrb;
	}

	actions
	{
		"Don't set effect to null, to ensure this is definitely destroyed."
		Destroy Effect(Global.OrbEffects[Global.OrbEvaluationIndex * 2]);
		Destroy Effect(Global.OrbEffects[Global.OrbEvaluationIndex * 2 + 1]);
		Destroy Effect(Global.OrbSounds[Global.OrbEvaluationIndex]);
		Global.OrbPositions[Global.OrbEvaluationIndex] = Null;
		Global.OrbCreators[Global.OrbEvaluationIndex] = Null;
	}
}

rule("Enable Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Normalized Health(Event Player) < 0.900;
	}

	actions
	{
		If(Global.Phase == 4 && !Event Player.CanUseOrbs);
			Event Player.CanUseOrbs = True;
			Big Message(Event Player, Custom String("Press [{0}] to use special ability (Orbs) {1}.", Input Binding String(Button(Ability 2)), Ability Icon String(Hero(Echo), Button(Secondary Fire))));
			Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
			Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
			Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
			Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
			Play Effect(Event Player, Hanzo Sonic Arrow Initial Pulse Sound, Color(Team 2), Eye Position(Event Player), 100);
		End;
	}
}

rule("Return Items")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.HealthPerItemStack > 0;
		Count Of(Event Player.ItemStackReturnInfo) > 0;
		(Is Dead(Event Player) || Event Player.Phase4DamageReceived >= (Event Player.NumberOfStacksReturned + 1)
			* Event Player.HealthPerItemStack) == True;
	}

	actions
	{
		Play Effect(Event Player, Moira Fade Disappear Sound, Color(White), Event Player, 100);
		Play Effect(Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex], Moira Fade Reappear Sound, Color(White),
			Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex], 100);
		While(True);
			Abort If Condition Is False;
			Event Player.StackBeingReturnedIndex = Event Player.ItemStackReturnInfo[0];
			Event Player.RemainingMatchingStacks = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
				Global.ItemStacks[Current Array Element] == Global.ItemStacks[Event Player.StackBeingReturnedIndex] && Global.ItemStackOwners[Current Array Element] == Event Player);
			Global.ItemStackOwners[Event Player.StackBeingReturnedIndex] = Null;
			If(Count Of(Event Player.RemainingMatchingStacks) == 1);
				Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingReturnedIndex, 2,
					-1 * Global.ItemStackSizes[Event Player.StackBeingReturnedIndex], Event Player, False));
			Else;
				Event Player.StackBeingDepletedIndex = Filtered Array(Event Player.RemainingMatchingStacks,
					Global.ItemStackSizes[Current Array Element] > 0)[0];
				If(Event Player.StackBeingReturnedIndex == Event Player.StackBeingDepletedIndex);
					Global.ItemStackSizes[Remove From Array(Event Player.RemainingMatchingStacks, Event Player.StackBeingDepletedIndex)
						[0]] += Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] - Event Player.ItemStackReturnInfo[1];
					Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] = Event Player.ItemStackReturnInfo[1];
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingReturnedIndex, 2,
						-1 * Event Player.ItemStackReturnInfo[1], Event Player, False));
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Remove From Array(Event Player.RemainingMatchingStacks,
						Event Player.StackBeingDepletedIndex)[0], 1, Global.ItemStackSizes[Remove From Array(Event Player.RemainingMatchingStacks,
						Event Player.StackBeingDepletedIndex)[0]], Event Player, False));
				Else;
					Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] -= Event Player.ItemStackReturnInfo[1];
					Global.ItemStackSizes[Event Player.StackBeingReturnedIndex] += Event Player.ItemStackReturnInfo[1];
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingDepletedIndex, 0,
						-1 * Event Player.ItemStackReturnInfo[1], Event Player, False));
				End;
			End;
			Global.ItemStackNewOwners[Event Player.StackBeingReturnedIndex] = Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex];
			Event Player.NumberOfStacksReturned += 1;
			Modify Player Variable(Event Player, ItemStackReturnInfo, Remove From Array By Index, 0);
			Modify Player Variable(Event Player, ItemStackReturnInfo, Remove From Array By Index, 0);
			Wait(0.100, Abort When False);
		End;
	}
}

disabled rule("PHASE X")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Player Died")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.IsDead == False;
	}

	actions
	{
		Log To Inspector(Custom String("{0} died", Event Player.Ids[0]));
		If(Event Player.BleedInfo[3]);
			Log To Inspector(Custom String("Bleed Time: {0} / 1000", Event Player.BleedTime * 1000));
			Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Eye Position(Event Player), 16);
			Filtered Array(Players Within Radius(Eye Position(Event Player), 16, Team Of(Event Player), Surfaces And Enemy Barriers), Is Alive(
				Current Array Element) && !Has Status(Current Array Element, Phased Out)).CauseOfDeath[1] = Custom String("Insides");
			Damage(Players Within Radius(Eye Position(Event Player), 16, Team Of(Event Player), Surfaces And Enemy Barriers),
				Event Player.BleedInfo[3], Event Player.BleedInfo[3].MyItemStackSizes[27] * (4 * Event Player.BleedInfo[3].BaseDamageMultiplier[1] + 0.150 * Max Health(Event Player) / (Event Player.HealthScale[2] * Event Player.HealthScale[5])) / Event Player.BleedInfo[3].BaseDamageMultiplier[0]);
		End;
		If(Event Player.CauseOfDeath[0].MyItemStackSizes[30]);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Effect, Team Of(Event Player.CauseOfDeath[0]), Eye Position(Event Player), 6.500 + 3.500 * Event Player.CauseOfDeath[0].MyItemStackSizes[30]);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Team Of(Event Player.CauseOfDeath[0]), Eye Position(Event Player), 100);
			Filtered Array(Players Within Radius(Eye Position(Event Player), 5.500 + 3.500 * Event Player.CauseOfDeath[0].MyItemStackSizes[30], Opposite Team Of(Team Of(Event Player.CauseOfDeath[0])), Surfaces And Enemy Barriers), Is Alive(Current Array Element) && !Has Status(Current Array Element, Phased Out)).CauseOfDeath = Array(Event Player.CauseOfDeath[0], Custom String("Fire"));
			Damage(Filtered Array(Players Within Radius(Eye Position(Event Player), 5.500 + 3.500 * Event Player.CauseOfDeath[0].MyItemStackSizes[30], Opposite Team Of(Team Of(Event Player.CauseOfDeath[0])), Surfaces And Enemy Barriers), Is Alive(Current Array Element)), Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Event Player.CauseOfDeath[0]))], 1.500 * Event Player.CauseOfDeath[0].BaseDamageMultiplier[1]);
			Modify Player Variable(Filtered Array(Players Within Radius(Eye Position(Event Player), 6.500 + 3.500 * Event Player.CauseOfDeath[0].MyItemStackSizes[30], Opposite Team Of(Team Of(Event Player.CauseOfDeath[0])), Surfaces And Enemy Barriers), Is Alive(Current Array Element) && !Has Status(Current Array Element, Phased Out)), NewBurnInfo, Append To Array, Array(Event Player.CauseOfDeath[0].BaseDamageMultiplier[1] * 0.250 * (Event Player.CauseOfDeath[0].MyItemStackSizes[30] + 1), Event Player.CauseOfDeath[0]));
		End;
		Event Player.BarrierHealth = 0;
		Event Player.BoomTime[0] = 0;
		Call Subroutine(CleanseAllDebuffs);
		Event Player.WispAcceleration = Vector(0, 0, 0);
		Start Rule(DetermineAcceleration, Restart Rule);
		If(Event Player.IsMook);
			Call Subroutine(LoseTarget);
		Else If(Event Player.IsHero && Global.Dialogue[0]);
			If(Global.Phase == 1 || Global.Phase == 3);
				Modify Global Variable(Dialogue, Append To Array, Array(Attacker.Master[0].IsBoss
					? Attacker.Master[0] : Null, Custom String("EarlyHeroDeath")));
			Else If(Global.Phase == 4);
				Modify Global Variable(Dialogue, Append To Array, Array(Attacker.Master[0].IsBoss
					? Attacker.Master[0] : Null, Custom String("LateHeroDeath")));
			End;
		End;
		If(Event Player.MyItemStackSizes[5]);
			Wait(2, Ignore Condition);
			Abort If(Is Alive(Event Player));
			If(Team Of(Event Player) != Team 2);
				Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
					Global.ItemStackSizes[Current Array Element] > 0 && Global.ItemStacks[Current Array Element] == Custom String("Extra Life")
					&& Global.ItemStackOwners[Current Array Element] == Event Player)[0], 0, -1, Event Player, True));
			End;
			Resurrect(Event Player);
			Set Status(Event Player, Null, Invincible, 3);
			Wait(0.100, Ignore Condition);
			Set Player Health(Event Player, Max Health(Event Player));
		Else;
			Event Player.IsDead = True;
			If(Event Player.IsMook);
				If(Hero Of(Event Player) == Hero(Wrecking Ball));
					Wait(1.350, Ignore Condition);
					Play Effect(All Players(All Teams), Good Explosion, Color(White), Position Of(Event Player) + Up, 1);
					Play Effect(All Players(All Teams), Echo Sticky Bomb Explosion Sound, Color(Team 2), Position Of(Event Player) + Up, 100);
					Event Player.FlameTornadoPosition = Position Of(Event Player);
					Event Player.FlameTornadoExpirationTime = Total Time Elapsed + 7;
					Create Effect(All Players(All Teams), Ring, Color(Sky Blue), Event Player.FlameTornadoPosition, 5, Visible To);
					Event Player.FlameTornado = Last Created Entity;
					Wait(7.650, Ignore Condition);
				Else;
					Wait(9, Ignore Condition);
				End;
				Call Subroutine(DestroyMe);
			End;
		End;
	}
}

rule("Player Is Alive")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.CauseOfDeath = Null;
		Event Player.ExtraDeathInfo = Null;
		Event Player.IsDead = False;
		If(Global.State != Custom String("Buy") && Global.Difficulty[2] >= 1 && Team Of(Event Player) == Team 1);
			Wait(0.300, Abort When False);
			Set Player Health(Event Player, (Max Health(Event Player) - Max Health Of Type(Event Player, Shields)) / 2 + Max Health Of Type(Event Player, Shields));
		End;
	}
}

rule("Player Died Permanently")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.IsDead == True;
	}

	actions
	{
		If(Event Player.IsBoss);
			Event Player.HasLostThisPhase = True;
			Event Player.ShowBossInfo[0] = False;
			Event Player.ShowBossInfo[1] = 0;
			Play Effect(All Players(All Teams), Sombra EMP Explosion Sound, Color(White), Event Player, 100);
			If(Global.Dialogue[0]);
				Modify Global Variable(Dialogue, Append To Array, Array(Event Player, Custom String("BossDeath")));
			End;
		End;
		Wait(2, Abort When False);
		Event Player.ExtraDeathInfo[0] = True;
	}
}

rule("Destroy Needler Bot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		(Global.Phase == 2 || !Array Contains(Filtered Array(All Players(Team 2), !Current Array Element.IsDead), Event Player.Master[0]) || Is Match Complete)
			== True;
	}

	actions
	{
		Call Subroutine(DestroyMe);
	}
}

rule("Hide Null Players from victory screen")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Match Complete == True;
		Event Player.IsNullPlayer == True;
	}

	actions
	{
		Call Subroutine(DestroyMe);
	}
}

rule("All Bosses Gone")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Is True For All(Global.Bosses, Current Array Element.IsDead) == True;
	}

	actions
	{
		Global.State = Custom String("PlayerVictory");
		Global.Phase = Custom String("X");
		Global.ShowBossAbilityInfo[0] = False;
		If(Current Game Mode == Game Mode(Skirmish));
			Wait(2, Ignore Condition);
			Log To Inspector(Custom String("BroadcastState: PlayerVictory"));
			Wait(11, Ignore Condition);
			Declare Team Victory(Team 1);
		End;
	}
}

rule("All Heroes Gone")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Is True For All(Global.Heroes, Current Array Element.IsDead) == True;
	}

	actions
	{
		If(Current Game Mode == Game Mode(Skirmish));
			Wait(2, Ignore Condition);
			Log To Inspector(Custom String("BroadcastState: BossVictory"));
			Wait(11, Ignore Condition);
			Declare Team Victory(Team 2);
		End;
	}
}