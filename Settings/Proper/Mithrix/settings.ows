settings
{
	lobby
	{
		Max Team 1 Players: 3
		Max Team 2 Players: 2
	}

	modes
	{
		Elimination
		{
			Hero Selection: Limited
			Score To Win: 5

			enabled maps
			{
			}
		}

		Skirmish
		{
			enabled maps
			{
				Workshop Expanse 0
			}
		}

		General
		{
			Hero Limit: Off
		}
	}

	heroes
	{
		Team 1
		{
			Ultimate Generation - Combat: 0%
			Ultimate Generation - Passive: 380%
			
			disabled heroes
			{
				D.Va
				Echo
			}
		}

		Team 2
		{
			Ramattra
			{
				No Ammunition Requirement: On
				Ultimate Ability Annihilation: Off
			}

			Reinhardt
			{
				Barrier Field: Off
				Charge: Off
				Fire Strike: Off
				Ultimate Generation - Combat Earthshatter: 0%
				Ultimate Generation - Passive Earthshatter: 0%
			}

			Tracer
			{
				Blink: Off
				No Ammunition Requirement: On
				Projectile Gravity: 0%
				Projectile Speed: 70%
				Quick Melee: Off
				Recall: Off
				Ultimate Generation - Passive Pulse Bomb: 500%
				Ultimate Generation Pulse Bomb: 200%
			}

			Wrecking Ball
			{
				Adaptive Shield: Off
				Grappling Claw: Off
				Piledriver: Off
				Quick Melee: Off
				Ultimate Ability Minefield: Off
			}

			Zenyatta
			{
				Orb of Discord: Off
				Orb of Harmony: Off
				Primary Fire: Off
				Projectile Speed: 25%
				Quick Melee: Off
				Ultimate Ability Transcendence: Off
			}

			enabled heroes
			{
				Reinhardt
			}
		}
	}

	workshop
	{
		Difficulty: 3
		Player Level: 20
		Test Mode: On
	}

	extensions
	{
		Beam Effects
		Beam Sounds
		Buff and Debuff Sounds
		Energy Explosion Effects
		Explosion Sounds
		Play More Effects
		Spawn More Dummy Bots
	}
}

variables
{
	global:
		0: State
		1: Phase
		2: Heroes
		3: Bosses
		4: TestMode
		5: DeathLineRadius
		6: OverallBossLevel
		7: OverallPlayerLevel
		8: PlayerCount
		9: PlayerFactor
		10: DifficultyValue
		11: TimeFactor
		12: StagesCompleted
		13: DifficultyCoefficient
		14: BossCount
		15: Items
		16: ItemSymbols
		17: ItemRarities
		18: ItemColours
		19: ItemDistributionQueue
		20: ItemDistributionInfo
		21: ItemStacks
		22: ItemStackOwners
		23: ItemStackNewOwners
		24: ItemStackOriginalOwners
		25: ItemStackSizes
		26: ItemStackIndex
		27: NewItemStackIndex
		28: ItemStackHUDs
		29: ItemStackEffects
		30: ItemStackUpdateInfos
		31: ItemStackUpdateInfo
		32: ExistingMatchingItemStacks
		33: CurrentItemStackSize
		34: ItemShops
		35: ItemShopPositions
		36: ItemShopPrices
		37: ItemShopEffects1
		38: ItemShopEffects2
		39: ItemShopIndex
		40: Stealees
		41: BossIndex
		42: CurrentStealee
		43: StealeeIndex
		44: Stealer
		45: ItemStackBeingStolenIndex
		46: BossSpawnEffect
		47: FlamePillars
		48: FlamePillarPositions
		49: FlamePillarExpirationTimes
		50: OrbCreationTimes
		51: OrbEffects
		52: OrbInitialAngles
		53: OrbPositions
		54: OrbCreators
		55: OrbEvaluationIndex
		56: OrbVictims
		57: OrbInitialPositions
		58: OrbSounds
		59: BotCreationQueue
		60: AvailableBotSlots
		61: TracerNames
		62: ZenyattaNames
		63: BallNames
		64: ArenaRadius
		65: StrikeVictims
		66: LightningStrikes
		67: NullPlayer
		68: ItemShopRadii
		69: ShopIndex
		70: ItemShopRarities
		71: Director
		72: AiIndex
		73: Adds
		74: Add
		75: Dialogue
		76: UsedDialogue
		77: EarlyHeroDeathDialogue
		78: LateHeroDeathDialogue
		79: BossDeathDialogue

	player:
		0: Master
		1: IsDead
		2: MyItemStacks
		3: BaseDamageMultiplier
		4: Armour
		5: ShouldUpdateArmour
		6: ArmourModifiers
		7: ArmourIndex
		8: DamageReceivedNewAmount
		9: BaseMoveSpeedModifier
		10: ShouldUpdateMoveSpeed
		11: MoveSpeedBuffs
		12: MoveSpeedDebuffs
		13: MoveSpeedIndex
		14: SlowTime
		15: BleedTime
		16: BleedInfo
		17: APTime
		18: ArmourPiercingStacks
		19: BlastCooldown
		20: FlameTornado
		21: FlameTornadoPosition
		22: FlameTornadoExpirationTime
		23: FlameTornadoDamage
		24: Currency
		25: BuyIndex
		26: CameraPosition
		27: CrippleTime
		28: State
		29: ShowBossBar
		30: HasLostThisPhase
		31: DefaultHealth
		32: BaseRegen
		33: NormalExtraHealth
		34: IntendedMaxHealth
		35: TotalHPUnits
		36: Bots
		37: CanSwing
		38: CanDash
		39: CanSlam
		40: CanSprint
		41: CanNeedle
		42: CanTakeOff
		43: CanUseOrbs
		44: SwingCooldown
		45: DashCooldown
		46: SlamCooldown
		47: NeedleCooldown
		48: TakeoffCooldown
		49: ShockwaveRadius
		50: ShockwaveEffect
		51: DashStartTime
		52: DashStartPosition
		53: DashAngles
		54: DashSpeed
		55: NumPizzaLines
		56: PizzaIndex
		57: PizzaAngle
		58: PizzaAngularVelocity
		59: PizzaRadius
		60: Victims
		61: PizzaTime
		62: Phase4DamageReceived
		63: HealthPerItemStack
		64: NumberOfStacksReturned
		65: ItemStackReturnInfo
		66: StackBeingReturnedIndex
		67: StackBeingDepletedIndex
		68: RemainingMatchingStacks
		69: OrbCreationIndex
		70: NewOrbGlobalIndex
		71: Role
		72: Target
		73: DoubleJumps
		74: RecoveryTime
		75: Name
		76: WispAcceleration
		77: WallAcceleration
		78: EvenRarityItemsCount
		79: StealthTime
		80: BoomTime
		81: Level
		82: ShouldUpdateHealing
		83: HealingModifiers
		84: HealingIndex
		85: HealthScale
		86: BarrierInfo
		87: Sounds
		88: NormalExtraHealthPools
		89: HealthPoolIndex
		90: DebuffShield
		91: BarrierHealth
		92: BarrierHealthDamageModification
		93: NeedleAmmo
		94: NoBlastReason
		95: CachedHealth
}

subroutines
{
	1: Steal
	2: Acquire
	3: DistributeItem
	4: HandleItemInstance
	5: Dash
	6: UpdateMoveSpeed
	7: UpdateArmour
	8: DestroyOrb
	9: HandleOrb
	10: CreateItemStack
	11: SetCoefficient
	12: UpdateStats
	13: ChooseState
	14: UpdateItemStack_Add
	15: UpdateItemStack_Remove
	16: UpdateItemStack_Modify
	17: Settings
	18: CleanseSomeDebuffs
	19: CleanseAllDebuffs
	20: DestroyMe
	21: Buy
	22: UpdateHealing
	23: TrySpawn
	24: SoundCue
	25: PrepareSounds
	26: Call
	27: AiStep
	28: TryShoot
	29: BossSetup
	30: HeroSetup
	31: AddSetup
	32: LoseTarget
	33: ChooseVThrottle
	34: PlayerSetup
	35: DialogueStep
	36: CalculateStats
}

rule("Global setup")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.ArenaRadius = 80;
		Global.StagesCompleted = 5;
		Global.LightningStrikes = Empty Array;
		Global.BotCreationQueue = Empty Array;
		Global.AvailableBotSlots = Append To Array(Vector(1, 23, 0), Mapped Array(Array(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
			19, 20, 21, 22, 23), Vector(2, Current Array Element, 0)));
		Call Subroutine(Settings);
		Global.ItemStackUpdateInfos = Empty Array;
		Global.DeathLineRadius = 0.750;
		Create Effect(All Players(All Teams), Bad Aura, Color(Black), Vector(0, 0, 0), 3.500, Visible To Position and Radius);
		Global.BossSpawnEffect = Last Created Entity;
		Global.Items = Array(Custom String("Max HP"), Custom String("Speed"), Custom String("Slow"), Custom String("Bleed"), Custom String(
			"Armour Piercing"), Custom String("Extra Life"), Custom String("Close Range Damage"), Custom String("Ice Blast"),
			Custom String("Flame Blast"), Custom String("Lifesteal"), Custom String("Stun Chance"), Custom String("Recovery"),
			Custom String("Double Jump"), Custom String("Armour Reduction"), Custom String("Egg"), Custom String("Reprieve"),
			Custom String("Lightning"), Custom String("Big Explosion"), Custom String("Rock"), Custom String("Shields"), Custom String(
			"Barrier"), Custom String("Debuff Shield"));
		Global.ItemSymbols = Array(Custom String("♥"), Custom String("»"), Custom String("«"), Custom String("†"), Custom String("▲"),
			Custom String("+1"), Custom String("(•)"), Custom String("*"), Custom String("*"), Custom String("Ϣ"), Custom String("@"),
			Custom String("+"), Custom String("ニ"), Custom String("Ø"), Custom String("0"), Custom String("◌"), Icon String(Bolt),
			Icon String(Warning), Custom String("●"), Custom String("♥"), Custom String("○"), Custom String("Θ"));
		Global.ItemRarities = Array(1, 1, 2, 1, 3, 3, 1, 2, 2, 2, 1, 1, 2, 3, 4, 2, 4, 4, 4, 1, 1, 3);
		Global.ItemColours = Array(Custom Color(205, 83, 63, 255), Custom Color(189, 192, 159, 255), Custom Color(230, 225, 209, 255),
			Custom Color(171, 43, 43, 255), Custom Color(88, 100, 73, 255), Custom Color(189, 191, 206, 255), Custom Color(226, 40, 78,
			255), Custom Color(214, 229, 233, 255), Custom Color(165, 114, 106, 255), Custom Color(77, 34, 21, 255), Custom Color(62, 75,
			53, 255), Custom Color(25, 98, 10, 255), Custom Color(85, 188, 229, 255), Custom Color(230, 139, 142, 255), Custom Color(255,
			185, 148, 255), Custom Color(96, 71, 70, 200), Color(White), Color(White), Custom Color(13, 20, 59, 255), Custom Color(165,
			239, 246, 255), Custom Color(198, 193, 252, 200), Custom Color(239, 221, 23, 255));
		Global.Items = Sorted Array(Global.Items, Global.ItemRarities[Current Array Index]);
		Global.ItemSymbols = Sorted Array(Global.ItemSymbols, Global.ItemRarities[Current Array Index]);
		Global.ItemColours = Sorted Array(Global.ItemColours, Global.ItemRarities[Current Array Index]);
		Global.ItemRarities = Sorted Array(Global.ItemRarities, Current Array Element);
		Global.ItemDistributionQueue = Empty Array;
		Global.ItemStackOriginalOwners = Empty Array;
		Global.FlamePillarPositions = Empty Array;
		Global.FlamePillarExpirationTimes = Empty Array;
		Global.FlamePillars = Empty Array;
		Global.OrbCreators = Empty Array;
		Create HUD Text(All Players(Team 1), Custom String("{0} {1}", Array(Icon String(Happy), Icon String(Sad), Icon String(Skull))
			[Global.DifficultyValue - 1], Array(Custom String("Easy"), Custom String("Normal"), Custom String("Hard"))
			[Global.DifficultyValue - 1]), Null, Null, Right, 0, Array(Custom Color(102, 153, 102, 255), Custom Color(204, 153, 102, 255),
			Custom Color(153, 51, 51, 255))[Global.DifficultyValue - 1], Color(White), Color(White), Visible To, Default Visibility);
		Create HUD Text(All Players(Team 1), Null, Global.Phase > 0 ? Custom String("Objective: Defeat the boss") : Custom String(" "),
			Null, Right, 0.100, Array(Custom Color(102, 153, 102, 255), Custom Color(204, 153, 102, 255), Custom Color(153, 51, 51, 255))
			[Global.DifficultyValue - 1], Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 1, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 2, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 3, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 4, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		If(Global.TestMode);
			disabled Create HUD Text(All Players(All Teams), Global.State, Custom String("Global State"), Global.Phase, Left, 0, Color(White), Color(
				White), Color(White), Visible To and String, Default Visibility);
			Create HUD Text(All Players(All Teams), Server Load Average, Null, Null, Left, 0, Color(White), Color(White), Color(White),
				Visible To and String, Default Visibility);
		End;
		Global.BallNames = Array(Custom String("Interference"), Custom String("Locomotion"), Custom String("Destruction"));
		Global.TracerNames = Array(Custom String("Soul"), Custom String("Design"), Custom String("Wonder"), Custom String("Speed"),
			Custom String("Inspiration"), Custom String("Strength"), Custom String("Curiosity"), Custom String("Spirit"), Custom String(
			"Life"), Custom String("Power"));
		Global.ZenyattaNames = Array(Custom String("Stone"), Custom String("Silver"), Custom String("Speed"), Custom String("Volatility"),
			Custom String("Stability"), Custom String("Dance"), Custom String("Song"));
		Create Effect(All Players(All Teams), Light Shaft, Color(Sky Blue), Vector(0, 0, 0), 1.060 * Global.ArenaRadius, Visible To);
		Create Effect(All Players(All Teams), Ring, Color(Gray), Vector(0, 0, 0), 57, Visible To);
		Create Beam Effect(Count Of(Global.LightningStrikes) ? All Players(All Teams) : Null, Bad Beam, Update Every Frame(
			Global.LightningStrikes[1] + 30 * Up), Update Every Frame(Global.LightningStrikes[1] + Down), Color(White),
			Visible To Position Radius and Color);
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Sigma), Team 2));
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Soldier: 76), Team 1));
		Global.EarlyHeroDeathDialogue = Array(Custom String("Return to dirt."), Custom String("Submit, vermin."), Custom String("Die, vermin."), Custom String("Die, weakling."), Custom String("Become memories."));
		Global.LateHeroDeathDialogue = Array(Custom String("DIE."), Custom String("WEAK."), Custom String("USELESS."), Custom String("AS I THOUGHT…"), Custom String("VERMIN."));
		Global.BossDeathDialogue = Array(Custom String("NO… NOT NOW…"), Custom String("WHY… WHY NOW…?"), Custom String("NO… NO…!"), Custom String("BROTHER… HELP ME…!"), Custom String("THIS PLANE GROWS DARK… BROTHER… I CANNOT SEE YOU… WHERE ARE YOU…?"), Custom String("BROTHER… PERHAPS… WE WILL GET IT RIGHT… NEXT TIME…"));
		Global.UsedDialogue = Empty Array;
		Global.State = Custom String("Buy");
	}
}

rule("Settings")
{
	event
	{
		Subroutine;
		Settings;
	}

	actions
	{
		Global.TestMode = Workshop Setting Toggle(Custom String("Developer"), Custom String("Test Mode"), False, 0);
		Global.DifficultyValue = Workshop Setting Integer(Custom String("Difficulty"), Custom String("Difficulty"), 2, 1, 3, 0);
		Global.OverallPlayerLevel = Workshop Setting Integer(Custom String("Difficulty"), Custom String("Player Level"), 8, 1, 99, 0);
		Global.Dialogue = Array(Workshop Setting Toggle(Custom String("Customization"), Custom String("Enable Dialogue"), False, 0), 5, Null, Null, Null);
	}
}

rule("Dialogue")
{
	event
	{
		Ongoing - Global;
	}
	
	conditions
	{
		Count Of(Global.Dialogue) > 1 + Global.Dialogue[1];
	}

	actions
	{
		Call Subroutine(DialogueStep);
		Wait(0.200, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Dialogue Step")
{
	event
	{
		Subroutine;
		DialogueStep;
	}

	actions
	{
		Global.Dialogue[2] = Global.Dialogue[Global.Dialogue[1]];
		If(Global.Dialogue[2] == Null);
			Global.Dialogue[2] = Random Value In Array(Filtered Array(Global.Bosses, Is Alive(Current Array Element) && Current Array Element.State != Custom String("Absent")));
		End;
		If(Global.Dialogue[2].Name != Null && Array Contains(All Players(All Teams), Global.Dialogue[2]));
			Global.Dialogue[3] = Global.Dialogue[Global.Dialogue[1] + 1];
			If(Global.Dialogue[3] == Custom String("BossSpawn"));
				Global.Dialogue[4] = Random Value In Array(Array(Custom String("Pray."), Custom String("Beg."), Custom String("Die."), Custom String("Be slaughtered.")));
			Else If(Global.Dialogue[3] == Custom String("EarlyHeroDeath"));
				Global.Dialogue[4] = Random Value In Array(Remove From Array(Global.EarlyHeroDeathDialogue, Global.UsedDialogue));
				If(Global.Dialogue[4] == Null);
					Modify Global Variable(UsedDialogue, Remove From Array By Value, Global.EarlyHeroDeathDialogue);
					Global.Dialogue[4] = Random Value In Array(Global.EarlyHeroDeathDialogue);
				End;
			Else If(Global.Dialogue[3] == Custom String("LateHeroDeath"));
				Global.Dialogue[4] = Random Value In Array(Remove From Array(Global.LateHeroDeathDialogue, Global.UsedDialogue));
				If(Global.Dialogue[4] == Null);
					Modify Global Variable(UsedDialogue, Remove From Array By Value, Global.LateHeroDeathDialogue);
					Global.Dialogue[4] = Random Value In Array(Global.LateHeroDeathDialogue);
				End;
			Else If(Global.Dialogue[3] == Custom String("BossDeath"));
				Global.Dialogue[4] = Random Value In Array(Remove From Array(Global.BossDeathDialogue, Global.UsedDialogue));
				If(Global.Dialogue[4] == Null);
					Modify Global Variable(UsedDialogue, Remove From Array By Value, Global.BossDeathDialogue);
					Global.Dialogue[4] = Random Value In Array(Global.BossDeathDialogue);
				End;
			End;				
			If(Global.Dialogue[4] != Null);
				Small Message(All Players(All Teams), Custom String("[{0}]: {1}", Global.Dialogue[2].Name, Global.Dialogue[4]));
				Modify Global Variable(UsedDialogue, Append To Array, Global.Dialogue[4]);
			End;
		End;
		If(Count Of(Global.Dialogue) > 998);
			Global.Dialogue = Append To Array(Array Slice(Global.Dialogue, 0, 4), Array Slice(Global.Dialogue, 7, 1000));
		Else;
			Global.Dialogue[1] += 2;
		End;
	}
}

rule("Identify Boss")
{
	event
	{
		Player Joined Match;
		Team 2;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Log To Inspector(Custom String("boss joined"));
		Event Player.Role = Custom String("Boss");
		Event Player.Master[0] = Event Player;
		Start Rule(PlayerSetup, Do Nothing);
	}
}

rule("Boss Setup")
{
	event
	{
		Subroutine;
		BossSetup;
	}

	actions
	{
		Event Player.Name = Custom String("{0}", Event Player);
		Create HUD Text(Event Player.ShowBossBar ? All Players(Team 1) : Null, Null, Custom String("{0} {1}", Custom String("{0} {1} {2}",
			Custom String("{0} {1} {2}", Event Player.BlastCooldown ? Custom String("{0}×{1}", Icon String(Asterisk), Round To Integer(
			Event Player.BlastCooldown, Up)) : Custom String(" "),
			Event Player.BarrierInfo[0] && Event Player.BarrierInfo[1] < Total Time Elapsed ? Icon String(Ring Thick) : Custom String(" "),
			Event Player.DebuffShield[0] > 0 ? Custom String("Θ×{0}", Event Player.DebuffShield[0]) : Custom String(" ")),
			Event Player.RecoveryTime ? Icon String(Plus) : Custom String(" "), Event Player.StealthTime[1] ? Custom String("{0}{1}",
			Icon String(Eye), Event Player.StealthTime[0] ? Custom String("") : Max(1, Round To Integer(
			Event Player.StealthTime[1] - Total Time Elapsed, Up))) : Custom String(" ")), Custom String("{0} {1} {2}",
			Event Player.CrippleTime ? Icon String(Skull) : Custom String(" "), Event Player.SlowTime ? Icon String(Arrow: Down)
			: Custom String(" "), Custom String("{0} {1} {2}", Event Player.BleedInfo[0] ? Custom String("†×{0}",
			Event Player.BleedInfo[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[0] ? Custom String("Ѳ×{0}",
			Event Player.ArmourPiercingStacks[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[1] ? Custom String("Ø×{0}",
			Event Player.ArmourPiercingStacks[1]) : Custom String(" ")))), Null, Top, Slot Of(Event Player), Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create Progress Bar HUD Text(Event Player.ShowBossBar ? All Players(Team 1) : Empty Array, 100 * (Event Player.CachedHealth[1] ? Event Player.CachedHealth[2] : Health(Event Player) + Event Player.BarrierHealth) / (Event Player.CachedHealth[1] ? Event Player.CachedHealth[3] : Max Health(Event Player)),
			String("{0} / {1}", Max(1, Round To Integer((Event Player.CachedHealth[1] ? Event Player.CachedHealth[2] : Health(Event Player)) + Event Player.BarrierHealth, To Nearest)), Round To Integer(
			(Event Player.CachedHealth[1] ? Event Player.CachedHealth[3] : Max Health(Event Player)), To Nearest)), Top, Slot Of(Event Player) + 0.100, Color(Red), Color(White), Visible To and Values,
			Default Visibility);
		Create HUD Text(Event Player.ShowBossBar ? All Players(Team 1) : Null, Null, Null, Event Player, Top, Slot Of(Event Player)
			+ 0.200, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Event Player.PizzaRadius = 100;
		Chase Player Variable At Rate(Event Player, SwingCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, SlamCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, NeedleCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, DashCooldown, 0, 1, None);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Reinhardt), Button(
			Primary Fire)), Custom String("[{0}]", Input Binding String(Button(Primary Fire))),
			Event Player.SwingCooldown ? Round To Integer(Event Player.SwingCooldown, Up) : Custom String(" "), Right, 0,
			Event Player.CanSwing ? (Event Player.SwingCooldown > 0 ? Color(Orange) : Color(Gray)) : Color(Red), Color(White), Color(
			White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Soldier: 76), Button(
			Ability 1)), Custom String("[{0}]", Input Binding String(Button(Ability 1))), Null, Right, 0, Event Player.CanSprint ? (
			Event Player.State == Custom String("ClosingIn") ? Color(Orange) : Color(Gray)) : Color(Red), Color(White), Color(White),
			Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Tracer), Button(
			Ability 1)), Event Player.State == Custom String("ClosingIn") ? Custom String("←/↓/→") : Custom String("[{0}]",
			Input Binding String(Button(Jump))), Custom String("{0} • {1}", Event Player.DashCooldown > 0 ? Round To Integer(
			Event Player.DashCooldown, Up) : Custom String(" "), Event Player.CanDash[1]), Right, 0, Event Player.CanDash[0] ? (
			Event Player.DashCooldown > 0 || Event Player.State == Custom String("Dashing") ? Color(Orange) : Color(Gray)) : Color(Red),
			Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Reinhardt), Button(
			Ultimate)), Custom String("[{0}]", Input Binding String(Button(Ultimate))), Event Player.SlamCooldown ? Round To Integer(
			Event Player.SlamCooldown, Up) : Custom String(" "), Right, 0, Event Player.CanSlam ? (Event Player.SlamCooldown > 0 ? Color(
			Orange) : Color(Gray)) : Color(Red), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Doomfist), Button(
			Ultimate)), Null, Event Player.CanTakeOff && Event Player.TakeoffCooldown ? Round To Integer(Event Player.TakeoffCooldown, Up)
			: Custom String(" "), Right, 0, Event Player.CanTakeOff ? Color(Orange) : Color(Red), Color(White), Color(White),
			String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3, 4), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Ramattra), Button(
			Primary Fire)), Custom String("[{0}]", Input Binding String(Button(Secondary Fire))), 
			Event Player.NeedleCooldown > 0 ? Custom String("…") : Round To Integer(
			Event Player.NeedleAmmo, Up), Right, 0, Event Player.CanNeedle[1] ? (Event Player.NeedleCooldown > 0 ? Color(Orange) : Color(
			Gray)) : Color(Red), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(4), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Echo), Button(
			Secondary Fire)), Custom String("[{0}]", Input Binding String(Button(Ability 2))), Null, Right, 0, Event Player.CanUseOrbs ? (
			Event Player.State == Custom String("Orbs") ? Color(Orange) : Color(Gray)) : Color(Red), Color(White), Color(White),
			Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Orisa), Button(Ability 2)),
			Null, Event Player.PizzaIndex == Custom String("Dormant") ? Null : Max(0, Event Player.PizzaTime[0] - Total Time Elapsed),
			Right, 0, Event Player.PizzaIndex == Custom String("Dormant") ? Color(Red) : (Event Player.PizzaIndex == Custom String("Soon")
			? Color(Gray) : Color(Orange)), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Event Player.Target == Null ? Null : Event Player, Hero Icon String(Hero Of(Event Player.Target)),
			Event Player.Target.Name, Is Dead(Event Player.Target) ? Icon String(X) : Custom String("{0}{1}", Mapped Array(Custom String(
			"■■■■■■■■■■■■■■"), String Slice(Current Array Element, 0, Round To Integer(Normalized Health(Event Player.Target)
			* String Length(Current Array Element), Up))), Mapped Array(Custom String("□□□□□□□□□□□□□□"), String Slice(
			Current Array Element, 0, Round To Integer((1 - Normalized Health(Event Player.Target)) * String Length(Current Array Element),
			Down)))), Left, 3.100, Color(White), Color(White), Health Of Type(Event Player, Shields) > 0 ? (Normalized Health(
			Event Player.Target) > 0.900 ? Color(Blue) : Custom Color(46, 172, 246, 255)) : (Normalized Health(Event Player.Target)
			> 0.900 ? Color(Green) : Color(Lime Green)), Visible To String and Color, Default Visibility);
		Create HUD Text(Event Player.Target == Null || Hero Of(Event Player.Target) == Hero(Wrecking Ball) ? Null : Event Player, Hero Of(
			Event Player.Target) == Hero(Tracer) ? (Ultimate Charge Percent(Event Player.Target) == 100 ? Ability Icon String(Hero(Tracer),
			Button(Ultimate)) : String("{0}%", Ultimate Charge Percent(Event Player.Target))) : (
			Event Player.Target.DashCooldown == 0 ? Ability Icon String(Hero(Sojourn), Button(Ability 1)) : Round To Integer(
			Event Player.Target.DashCooldown, Up)), Custom String("[{0}]", Input Binding String(Hero Of(Event Player.Target) == Hero(
			Tracer) ? Button(Ultimate) : Button(Ability 1))), Null, Left, 3.200, (Hero Of(Event Player.Target) == Hero(Tracer) ? Is Using Ultimate(Event Player.Target) : Event Player.Target.State == Custom STring("Dashing")) ? Color(Orange) : Color(White), Color(White), Color(White),
			Visible To String and Color, Default Visibility);
		Create Effect(Is Alive(Event Player) && (Global.Phase == 1 || Global.Phase == 3) ? Remove From Array(All Players(All Teams),
			Event Player) : Null, Moira Coalescence Sound, Color(White), Event Player, 100, Visible To Position and Radius);
		Set Jump Enabled(Event Player, False);
		Event Player.ShockwaveRadius = -1;
		Event Player.PizzaIndex = Custom String("Dormant");
		Create Icon(Global.State == Custom String("BossFight") && Event Player.State != Custom String("Absent") ? Filtered Array(
			Global.Heroes, Current Array Element.CameraPosition == Null && Has Spawned(Event Player) && Is Alive(Event Player) && (
			!Is In View Angle(Current Array Element, Eye Position(Event Player), 52) || String Contains(Event Player.State, Custom String(
			"FullTakeoff")))) : Null, Event Player, Arrow: Down, Visible To and Position, Color(Red), True);
		Event Player.NumPizzaLines = 4;
		For Player Variable(Event Player, PizzaIndex, 0, Event Player.NumPizzaLines, 1);
			Create Beam Effect(Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage")), Event Player.State) ? All Players(
				All Teams) : Null, Bad Beam, Update Every Frame(Position Of(Event Player) + (Event Player.State == Custom String("Pizza")
				? 0 : (Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20) * Up + Event Player.PizzaRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0)
				+ Global.DeathLineRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)), Update Every Frame(Position Of(Event Player) + (
				Event Player.State == Custom String("Pizza") ? 0 : (Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20)
				* Up - Event Player.PizzaRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0) + Global.DeathLineRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)),
				Event Player.State == Custom String("Pizza") ? Color(Blue) : Color(White), Visible To Position Radius and Color);
			Create Beam Effect(Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage")), Event Player.State) ? All Players(
				All Teams) : Null, Bad Beam, Update Every Frame(Position Of(Event Player) + (Event Player.State == Custom String("Pizza")
				? 0 : (Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20) * Up + Event Player.PizzaRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0)
				- Global.DeathLineRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)), Update Every Frame(Position Of(Event Player) + (
				Event Player.State == Custom String("Pizza") ? 0 : (Total Time Elapsed + 0.800 - Event Player.PizzaTime[1]) * 20)
				* Up - Event Player.PizzaRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0) - Global.DeathLineRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)),
				Event Player.State == Custom String("Pizza") ? Color(Blue) : Color(White), Visible To Position Radius and Color);
		End;
		Create Icon(Event Player.ArmourModifiers[1] && Has Spawned(Event Player) && !Has Status(Event Player, Phased Out) ? All Players(
			All Teams) : Null, Event Player, Heart, Visible To and Position, Color(Yellow), False);
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Ramattra), Event Player));
		disabled Create HUD Text(Event Player, Update Every Frame(Horizontal Speed Of(Event Player)), Null, Null, Left, 0, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Set Knockback Received(Event Player, 0);
		Event Player.ItemStackReturnInfo = Empty Array;
		Event Player.CanDash[1] = 2;
		Event Player.State = Custom String("Waiting");
	}
}

rule("Player Setup")
{
	event
	{
		Subroutine;
		PlayerSetup;
	}

	actions
	{
		Wait Until(Array Contains(All Heroes, Hero Of(Event Player)) && Max Health(Event Player) > 0, 9999);
		If(Event Player.Role == Custom String("NullPlayer"));
			Set Invisible(Event Player, All);
			Set Status(Event Player, Null, Phased Out, 9999);
			If(Team Of(Event Player) == Team 2);
				Global.NullPlayer[1] = Event Player;
				Start Forcing Player Position(Event Player, Vector(-5, 300, 0), False);
				Start Forcing Dummy Bot Name(Event Player, Custom String("The Planet"));
			Else If(Team Of(Event Player) == Team 1);
				Global.NullPlayer[0] = Event Player;
				Start Forcing Player Position(Event Player, Vector(5, 300, 0), False);
				Start Forcing Dummy Bot Name(Event Player, Custom String("The Captain"));
			End;
			Abort;
		End;
		Disable Built-In Game Mode Respawning(Event Player);
		Event Player.MyItemStacks = Empty Array;
		Event Player.NormalExtraHealthPools = Empty Array;
		Chase Player Variable At Rate(Event Player, SlowTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, BleedTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, APTime, 0, 1, None);
		Event Player.WispAcceleration = Vector(0, 0, 0);
		Event Player.HealthScale[0] = Team Of(Event Player) == Team 2 ? 0.600 / 2.400 : 0.600;
		If(Array Contains(Array(Custom String("Hero"), Custom String("Boss")), Event Player.Role));
			Chase Player Variable At Rate(Event Player, RecoveryTime, 0, 1, None);
			Create HUD Text(Array Contains(Array(Null, Custom String("Buy")), Global.State) ? Null : Event Player, Null, Null, Custom String(
				"{0} {1}", Custom String("{0} {1} {2}", Custom String("{0} {1} {2}", Event Player.BlastCooldown ? Custom String("{0}×{1}",
				Icon String(Asterisk), Round To Integer(Event Player.BlastCooldown, Up)) : Custom String(" "),
				Event Player.BarrierInfo[0] && Event Player.BarrierInfo[1] < Total Time Elapsed ? Icon String(Ring Thick) : Custom String(" "),
				Event Player.DebuffShield[0] > 0 ? Custom String("Θ×{0}", Event Player.DebuffShield[0]) : Custom String(" ")),
				Event Player.RecoveryTime ? Icon String(Plus) : Custom String(" "), Event Player.StealthTime[1] ? Custom String("{0}{1}",
				Icon String(Eye), Event Player.StealthTime[0] ? Custom String("") : Max(1, Round To Integer(
				Event Player.StealthTime[1] - Total Time Elapsed, Up))) : Custom String(" ")), Custom String("{0} {1} {2}",
				Event Player.CrippleTime ? Icon String(Skull) : Custom String(" "), Event Player.SlowTime ? Icon String(Arrow: Down)
				: Custom String(" "), Custom String("{0} {1} {2}", Event Player.BleedInfo[0] ? Custom String("†×{0}",
				Event Player.BleedInfo[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[0] ? Custom String("Ѳ×{0}",
				Event Player.ArmourPiercingStacks[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[1] ? Custom String("Ø×{0}",
				Event Player.ArmourPiercingStacks[1]) : Custom String(" ")))), Left, 2.100, Color(White), Color(White), Color(White),
				Visible To and String, Default Visibility);
			Create HUD Text(Event Player.Role == Custom String("Boss") && Global.Phase == 2 ? Null : Remove From Array(All Players(Team Of(
				Event Player)), Event Player), Hero Icon String(Hero Of(Event Player)), Event Player, Is Dead(Event Player) ? Icon String(X)
				: Custom String("{0}{1}", Mapped Array(Custom String("■■■■■■■■■■■■■■"), String Slice(Current Array Element, 0,
				Round To Integer((Health(Event Player) + Event Player.BarrierHealth) / (2 * Max Health(Event Player)) * String Length(
				Current Array Element), Up))), Mapped Array(Custom String("□□□□□□□□□□□□□□"), String Slice(Current Array Element, 0,
				Round To Integer((1 - (Health(Event Player) + Event Player.BarrierHealth) / (2 * Max Health(Event Player))) * String Length(
				Current Array Element), Down)))), Left, 3.100, Color(White), Color(White), Event Player.BarrierHealth > 0 ? Custom Color(225,
				200, 70, 255) : (Health Of Type(Event Player, Shields) > 0 ? (Normalized Health(Event Player) > 0.900 ? Color(Blue)
				: Custom Color(46, 172, 246, 255)) : (Normalized Health(Event Player) > 0.900 ? Color(Green) : Color(Lime Green))),
				Visible To String and Color, Default Visibility);
		End;
		Disable Kill Feed(Event Player);
		Event Player.DefaultHealth = Array(Max Health(Event Player), Max Health Of Type(Event Player, Health), Max Health Of Type(
			Event Player, Armor), Max Health Of Type(Event Player, Shields));
		If(Event Player.Role == Custom String("Add"));
			Set Crouch Enabled(Event Player, False);
		End;
		Event Player.State = Custom String("IndividualSetup");
		If(Event Player.Role == Custom String("Boss"));
			Start Rule(BossSetup, Do Nothing);
		Else If(Event Player.Role == Custom String("Hero"));
			Start Rule(HeroSetup, Do Nothing);
		Else If(Event Player.Role == Custom String("Add"));
			Start Rule(AddSetup, Do Nothing);
		End;
	}
}

rule("Update Difficulty Coefficient (And Boss Level)")
{
	event
	{
		Subroutine;
		SetCoefficient;
	}

	actions
	{
		Global.DifficultyCoefficient = (Global.PlayerFactor + ((Global.OverallPlayerLevel - 2.270) / 0.394 + Total Time Elapsed / 60)
			* Global.TimeFactor) * 1.150 ^ Global.StagesCompleted;
		Global.OverallBossLevel = 1 + 3 * (Global.DifficultyCoefficient - Global.PlayerFactor);
		All Players(Team 2).Level = Global.OverallBossLevel;
	}
}

rule("Identify Heroes")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Log To Inspector(Custom String("hero joined"));
		Event Player.Role = Custom String("Hero");
		Event Player.Master[0] = Event Player;
		Start Rule(PlayerSetup, Do Nothing);
	}
}

rule("Team 1 Setup")
{
	event
	{
		Subroutine;
		HeroSetup;
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Chase Player Variable At Rate(Event Player, CrippleTime, 0, 1, None);
		disabled Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Global.Items), Event Player, 10));
		Call Subroutine(UpdateStats);
		Event Player.Currency = 150 * Round To Integer(Event Player.Level, To Nearest);
		Create Effect(Event Player.CrippleTime > 0 && Event Player.StealthTime[0] == 0 ? All Players(All Teams) : Null, Good Aura, Color(
			Sky Blue), Eye Position(Event Player), 1, Visible To Position and Radius);
		If(Global.DifficultyValue == 1);
			Event Player.ArmourModifiers[3] = 70;
		End;
		Create Effect(Global.State == Custom String("Buy") && Is True For Any(Global.ItemShopPositions, Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Current Array Element) < 1.500) ? Event Player : Null, Sphere, Color(Yellow), Sorted Array(
			Global.ItemShopPositions, Distance Between(Current Array Element, Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False)))[0], 0.600,
			Visible To Position Radius and Color);
		Create HUD Text(Global.State == Custom String("Buy") ? Event Player : Null, Custom String("£{0}", Event Player.Currency), Null,
			Max(0, Round To Integer(90 - Total Time Elapsed, Up)), Left, 1.100, Color(Yellow), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Global.State == Custom String("Buy") && Is True For Any(Global.ItemShopPositions, Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Current Array Element) < 1.500) ? Event Player : Null, Global.ItemShops[Sorted Array(Mapped Array(
			Global.ItemShopPositions, Current Array Index), Distance Between(Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False),
			Global.ItemShopPositions[Current Array Element]))[0]], Custom String("[{0}] Buy", Input Binding String(Button(Interact))), Custom String("£{0}", Global.ItemShopPrices[Sorted Array(
			Mapped Array(Global.ItemShopPositions, Current Array Index), Distance Between(Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False),
			Global.ItemShopPositions[Current Array Element]))[0]]), Top, 1, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Event Player.State = Custom String("Ready");
	}
}

rule("Team 1 Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Abort If(Is Dummy Bot(Event Player));
		Wait Until(Is Alive(Event Player), 9999);
		Teleport(Event Player, Vector(Random Real(105, 115), 0, Random Real(-19, 19)));
		disabled Teleport(Event Player, 80 * Direction From Angles(Random Integer(45, 135), 0));
		Set Facing(Event Player, Direction From Angles(Horizontal Angle Towards(Event Player, Vector(0, 0, 0)), 0), To Player);
	}
}

rule("Enable OSP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) > 0.900;
	}

	actions
	{
		Set Status(Event Player, Null, Unkillable, 9999);
	}
}

rule("Disable OSP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) <= 0.900;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Clear Status(Event Player, Unkillable);
	}
}

rule("Start accelerating")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Magnitude Of(Event Player.WispAcceleration) + Event Player.WallAcceleration > 0;
	}

	actions
	{
		Start Accelerating(Event Player, Event Player.WispAcceleration - Event Player.WallAcceleration * Direction From Angles(
			Horizontal Angle From Direction(Position Of(Event Player)), 0), Magnitude Of(
			Event Player.WispAcceleration - Event Player.WallAcceleration * Direction From Angles(Horizontal Angle From Direction(
			Position Of(Event Player)), 0)), 60, To World, Direction Rate and Max Speed);
	}
}

rule("Stop accelerating")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Magnitude Of(Event Player.WispAcceleration) + Event Player.WallAcceleration == 0;
	}

	actions
	{
		Stop Accelerating(Event Player);
	}
}

rule("Inwards")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 1 > Global.ArenaRadius;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, WallAcceleration, (Is On Ground(Event Player) ? 400 : 0) + Max(0,
			18 * Speed Of In Direction(Event Player, Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 81 * (
			Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 1 - Global.ArenaRadius)),
			1000000000, Destination and Rate);
		Start Throttle In Direction(Event Player, Direction Towards(Event Player, Vector(0, 0, 0)), 2 * Max(0, Dot Product(World Vector Of(
			Throttle Of(Event Player), Event Player, Rotation), Direction From Angles(Horizontal Angle From Direction(Position Of(
			Event Player)), 0))), To World, Add to existing throttle, Direction and Magnitude);
	}
}

rule("Not Inwards")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, WallAcceleration);
		Event Player.WallAcceleration = 0;
	}
}

rule("Update Move Speed (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateMoveSpeed == True;
	}

	actions
	{
		Wait(0.050, Ignore Condition);
		Event Player.ShouldUpdateMoveSpeed = False;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Update Move Speed")
{
	event
	{
		Subroutine;
		UpdateMoveSpeed;
	}

	actions
	{
		Event Player.MoveSpeedBuffs[1] = 1;
		Event Player.MoveSpeedDebuffs[1] = 1;
		For Player Variable(Event Player, MoveSpeedIndex, 2, Count Of(Event Player.MoveSpeedBuffs), 1);
			"2: Sprint, 3: Speed Item, 4: Stealth bonus"
			Event Player.MoveSpeedBuffs[1] += Event Player.MoveSpeedBuffs[Event Player.MoveSpeedIndex] / 100;
		End;
		For Player Variable(Event Player, MoveSpeedIndex, 2, Count Of(Event Player.MoveSpeedDebuffs), 1);
			"2: Cripple, 3: Slow"
			Event Player.MoveSpeedDebuffs[1] += Event Player.MoveSpeedDebuffs[Event Player.MoveSpeedIndex] / 100;
		End;
		Event Player.MoveSpeedBuffs[0] = Event Player.MoveSpeedBuffs[1];
		Event Player.MoveSpeedDebuffs[0] = Event Player.MoveSpeedDebuffs[1];
		disabled Log To Inspector(Custom String("Updating move speed for {0}", Event Player));
		Set Move Speed(Event Player, Event Player.BaseMoveSpeedModifier * (
			Event Player.MoveSpeedBuffs[0] / Event Player.MoveSpeedDebuffs[0]));
		disabled Log To Inspector(Custom String("Updated move speed for {0}", Event Player));
	}
}

rule("Update Armour (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateArmour == True;
	}

	actions
	{
		Wait(0.050, Ignore Condition);
		Event Player.ShouldUpdateArmour = False;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Update Armour")
{
	event
	{
		Subroutine;
		UpdateArmour;
	}

	actions
	{
		Event Player.ArmourModifiers[0] = 0;
		For Player Variable(Event Player, ArmourIndex, 1, Count Of(Event Player.ArmourModifiers), 1);
			"1: Armour Boost, 2: Cripple, 3: Easy Mode, 4: Armour Piercing, 5: Armour Reduction, 6: Barrier"
			Event Player.ArmourModifiers[0] += Event Player.ArmourModifiers[Event Player.ArmourIndex];
		End;
		Event Player.Armour = Event Player.ArmourModifiers[0];
		Event Player.DamageReceivedNewAmount = 1 - Event Player.Armour / (100 + Absolute Value(Event Player.Armour));
		Set Damage Received(Event Player, 100 * Event Player.DamageReceivedNewAmount);
	}
}

rule("Update Healing (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateHealing == True;
	}

	actions
	{
		Wait(0.050, Ignore Condition);
		Event Player.ShouldUpdateHealing = False;
		Start Rule(UpdateHealing, Restart Rule);
	}
}

rule("Update Healing")
{
	event
	{
		Subroutine;
		UpdateHealing;
	}

	actions
	{
		Event Player.HealingModifiers[1] = 0;
		For Player Variable(Event Player, HealingIndex, 2, Count Of(Event Player.HealingModifiers), 1);
			"2: Rock"
			Event Player.HealingModifiers[1] += Event Player.HealingModifiers[Event Player.HealingIndex];
		End;
		Event Player.HealingModifiers[1] *= 1 + 0.200 * (Event Player.Level - 1);
		Event Player.HealingModifiers[1] += Event Player.BaseRegen;
		disabled Log To Inspector(Custom String("Updating healing for {0}", Event Player));
		Event Player.HealingModifiers[0] = Event Player.HealingModifiers[1] * Array(1.500, 1, 0.600)[Global.DifficultyValue - 1] / (
			15 / Event Player.HealthScale[0]);
		Set Healing Received(Event Player, Event Player.HealingModifiers[0] * 100);
		disabled Log To Inspector(Custom String("Updated healing for {0}", Event Player));
	}
}

rule("Calculate Max HP")
{
	event
	{
		Subroutine;
		CalculateStats;
	}
	
	actions
	{
		If(Event Player.Role == Custom String("Hero"));
			Event Player.Level = Round To Integer(Global.OverallPlayerLevel, Down);
			Event Player.TotalHPUnits = Event Player.HealthScale[0] * Event Player.DefaultHealth[0] * (90 / 150) * (1 + 0.300 * (
			Event Player.Level - 1)) / 25;
			Event Player.BaseDamageMultiplier = (1 + 0.200 * (Event Player.Level - 1)) / 2.400;
			Event Player.BaseRegen = 15 / Event Player.HealthScale[0] * (5 + (Event Player.Level - 1)) / 24;
		Else If(Event Player.Role == Custom String("Boss"));
			Call Subroutine(SetCoefficient);
			Event Player.Level = Round To Integer(Global.OverallBossLevel, Down);
			If(Global.Phase < 2);
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[0] * (1000 + 300 * (Event Player.Level - 1)) * (
					1 + Global.DifficultyCoefficient) * Square Root(Count Of(Filtered Array(Global.Heroes, Is Alive(Current Array Element))))
					/ Global.BossCount / 25;
				Event Player.BaseDamageMultiplier = 2 * (16 + 3.200 * (Event Player.Level - 1)) * 0.600 / 85;
				Event Player.BaseRegen = 15 / Event Player.HealthScale[0] * (5 + (Event Player.Level - 1)) / 24;
			Else If(Global.Phase == 3);
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[0] * (1000 + 300 * (Event Player.Level - 1)) * (
					1 + Global.DifficultyCoefficient) * Square Root(Count Of(Filtered Array(Global.Heroes, Is Alive(Current Array Element))))
					/ Global.BossCount / 25;
				Event Player.BaseDamageMultiplier = 2 * (16 + 3.200 * (Event Player.Level - 1)) * 0.600 / 85;
				Event Player.BaseRegen = 15 / Event Player.HealthScale[0] * (5 + (Event Player.Level - 1)) / 24;
			Else If(Global.Phase == 4);
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[0] * (1400 + 420 * (Event Player.Level - 1)) / Global.BossCount / 25;
				Event Player.BaseDamageMultiplier = 2 * (16 + 3.200 * (Event Player.Level - 1)) * 0.600 / 85;
				Event Player.BaseRegen = 15 / Event Player.HealthScale[0] * (5 + (Event Player.Level - 1)) / 24;
			End;
		Else If(Event Player.Role == Custom String("Add"));
			Event Player.Level = Round To Integer(Global.OverallBossLevel, Down);
			Event Player.BaseRegen = 15 / Event Player.HealthScale[0] * (5 + (Event Player.Level - 1)) / 24;
			If(Hero Of(Event Player) == Hero(Wrecking Ball));
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[0] * (180 + 54 * (Event Player.Level - 1)) / Global.BossCount / 25;
				"50% damage at level 17 (expected BossLevel for phase 2 on hard difficulty)"
				Event Player.BaseDamageMultiplier = 0.500 / (17 + 4) / 2.200 * (11 + 2.200 * (Event Player.Level - 1));
			Else If(Hero Of(Event Player) == Hero(Zenyatta));
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[0] * (1615 + 485 * (Event Player.Level - 1)) / Global.BossCount / 25;
				Event Player.BaseDamageMultiplier = (35 + 7 * (Event Player.Level - 1)) * 0.600 / 48;
			Else If(Hero Of(Event Player) == Hero(Tracer));
				"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
				Event Player.TotalHPUnits = Event Player.HealthScale[0] * (850 + 255 * (Event Player.Level - 1)) / Global.BossCount / 25;
				"40% damage at level 17 (expected BossLevel for phase 2 on hard difficulty)"
				Event Player.BaseDamageMultiplier = 0.400 / (17 + 4) / 3 * (15 + 3 * (Event Player.Level - 1));
			End;
		End;
	}
}

rule("Update Max HPs, healing and damage (after setting TotalHPUnits, BaseDamageMultiplier and BaseRegen)")
{
	event
	{
		Subroutine;
		UpdateStats;
	}

	actions
	{
		Call Subroutine(CalculateStats);
		If(Event Player.Role == Custom String("Boss"));
			If(Event Player.CachedHealth[0]);
				Event Player.CachedHealth[2] = Health(Event Player);
				Event Player.CachedHealth[3] = Max Health(Event Player);
				Event Player.CachedHealth[1] = True;
			End;
			Event Player.IntendedMaxHealth = Mapped Array(Array(0.533, 0.467), Event Player.TotalHPUnits * Current Array Element);
			Set Damage Dealt(Event Player.Bots[0], Event Player.BaseDamageMultiplier * 113.300);
		Else;
			If(Event Player.Role == Custom String("Hero"));
				Event Player.IntendedMaxHealth[1] = Event Player.TotalHPUnits * Event Player.DefaultHealth[2] / Event Player.DefaultHealth[0];
				Event Player.IntendedMaxHealth[0] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1]) * (
					Event Player.DefaultHealth[1] + 0.600 * Event Player.DefaultHealth[3]) / (
					Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
				Event Player.IntendedMaxHealth[2] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1])
					* Event Player.DefaultHealth[3] * 0.400 / (Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
			Else If(Event Player.Role == Custom String("Add"));
				Event Player.IntendedMaxHealth[1] = Event Player.TotalHPUnits * Event Player.DefaultHealth[2] / (
					Event Player.DefaultHealth[0] + Event Player.DefaultHealth[2] * 0.429);
				Event Player.IntendedMaxHealth[0] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1] / 0.700) * (
					Event Player.DefaultHealth[1] + 0.600 * Event Player.DefaultHealth[3]) / (
					Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
				Event Player.IntendedMaxHealth[2] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1] / 0.700)
					* Event Player.DefaultHealth[3] * 0.400 / (Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
				If(Hero Of(Event Player) == Hero(Wrecking Ball));
					Set Max Ammo(Event Player, 0, Round To Integer(Event Player.Level, To Nearest) + 3);
				End;
			End;
		End;
		Event Player.IntendedMaxHealth = Mapped Array(Event Player.IntendedMaxHealth, Round To Integer(Current Array Element, Up));
		Event Player.HealthScale[1] = Max(Min(Sorted Array(Remove From Array(Mapped Array(Event Player.IntendedMaxHealth,
			Current Array Element / (Event Player.DefaultHealth[Current Array Index + 1] / 25)), 0), Current Array Element)[0], 10),
			0.010);
		Set Max Health(Event Player, Event Player.HealthScale[1] * 100);
		Event Player.NormalExtraHealth = Mapped Array(Event Player.IntendedMaxHealth,
			Current Array Element * 25 - Event Player.DefaultHealth[Current Array Index + 1] * Event Player.HealthScale[1]);
		Set Damage Dealt(Event Player, Event Player.BaseDamageMultiplier * 100);
		Call Subroutine(UpdateHealing);
		Wait(0.250, Ignore Condition);
		While(Count Of(Event Player.NormalExtraHealthPools) > 0);
			Remove Health Pool From Player(Event Player.NormalExtraHealthPools[0]);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Remove From Array By Index, 0);
		End;
		Set Player Health(Event Player, 100000);
		For Player Variable(Event Player, HealthPoolIndex, 0, Min(9, Round To Integer(Event Player.NormalExtraHealth[0] / 9999, Down)), 1);
			Add Health Pool To Player(Event Player, Health, 9999, True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Event Player.NormalExtraHealth[3] = Event Player.NormalExtraHealth[0] % 9999;
		If(Event Player.NormalExtraHealth[3] >= 1);
			Add Health Pool To Player(Event Player, Health, Event Player.NormalExtraHealth[3], True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		For Player Variable(Event Player, HealthPoolIndex, 0, Min(10, Round To Integer(Event Player.NormalExtraHealth[1] / 9999, Down)),
			1);
			Add Health Pool To Player(Event Player, Armor, 9999, True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Event Player.NormalExtraHealth[3] = Event Player.NormalExtraHealth[1] % 9999;
		If(Event Player.NormalExtraHealth[3] >= 1);
			Add Health Pool To Player(Event Player, Armor, Event Player.NormalExtraHealth[3], True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		For Player Variable(Event Player, HealthPoolIndex, 0, Min(9, Round To Integer(Event Player.NormalExtraHealth[2] / 9999, Down)), 1);
			Add Health Pool To Player(Event Player, Shields, 9999, True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Event Player.NormalExtraHealth[3] = Event Player.NormalExtraHealth[2] % 9999;
		If(Event Player.NormalExtraHealth[3] >= 1);
			Add Health Pool To Player(Event Player, Shields, Event Player.NormalExtraHealth[3], True, False);
			Modify Player Variable(Event Player, NormalExtraHealthPools, Append To Array, Last Created Health Pool);
		End;
		Wait(0.250, Ignore Condition);
		Modify Player Variable(Event Player, NormalExtraHealth, Remove From Array By Index, 3);
		If(Event Player.CachedHealth[0]);
			Event Player.CachedHealth[4] = Has Status(Event Player, Phased Out);
			Clear Status(Event Player, Phased Out);
			Event Player.CachedHealth[5] = Max Health(Event Player) - (Event Player.CachedHealth[3] - Event Player.CachedHealth[2]);
			Log To Inspector(Custom String("{0}: {1} -> {2}", Event Player, Custom String("{0} / {1}", Event Player.CachedHealth[2], Event Player.CachedHealth[3]), Custom String("{0} / {1}", Event Player.CachedHealth[5], Max Health(Event Player))));
			Set Player Health(Event Player, Event Player.CachedHealth[5]);
			If(Event Player.CachedHealth[4]);
				Set Status(Event Player, Null, Phased Out, 9999);
			End;
			Event Player.CachedHealth[1] = False;
			Event Player.CachedHealth[0] = False;
		End;
	}
}

rule("On hit effects")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	actions
	{
		If(Attacker.Master[1] != Null);
			Play Effect(Attacker.Master[1], Baptiste Biotic Launcher Explosion Sound, Color(White), Eye Position(Attacker.Master[1]), 30);
		End;
		If(Victim.Role == Custom String("Add"));
			If(Attacker != Global.NullPlayer[0] && Victim.Master[1] == Null && Victim.Target != Null && Is Alive(Victim) && Is Alive(Attacker)
				&& Attacker.StealthTime[0] == 0 && Random Real(0, 1) < Event Damage / Max Health(Victim) * Normalized Health(Victim.Target));
				Victim.Target = Attacker;
			End;
		Else;
			If(Victim.BarrierHealth > 0);
				Heal(Victim, Null, (Event Damage - Max(Event Damage * (1 + Victim.BarrierHealth / (Health(Victim) + Event Damage))
					- Victim.BarrierHealth, 0)) / Victim.HealingModifiers[0]);
				Victim.BarrierHealth = Max(0, Victim.BarrierHealth - Event Damage * (1 + Victim.BarrierHealth / Health(Victim)));
			End;
			If(Array Contains(Victim.MyItemStacks, Custom String("Barrier")));
				Victim.BarrierInfo[1] = Total Time Elapsed + 7;
			End;
			If(Array Contains(Victim.MyItemStacks, Custom String("Egg")));
				Heal(Victim, Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Victim))],
					Victim.HealthScale[0] * Filtered Array(Global.ItemStackSizes,
					Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Egg")
					&& Global.ItemStackOwners[Current Array Index] == Victim)[0] * 15 / Victim.HealingModifiers[0]);
			End;
			If(Array Contains(Victim.MyItemStacks, Custom String("Recovery")));
				Victim.RecoveryTime = 2;
			End;
			If(Victim.Role == Custom String("Boss") && Global.Phase == 4);
				Victim.Phase4DamageReceived += Event Damage;
			End;
		End;
		If(Count Of(Attacker.Master[0].MyItemStacks) == 0);
			disabled Log To Inspector(Custom String("{0} has no items", Attacker.Master[0]));
		Else If(Attacker.Master[0] == Victim);
			Log To Inspector(Custom String("{0} is also the victim", Attacker.Master[0]));
		Else;
			If(Array Contains(Attacker.Master[0].MyItemStacks, Custom String("Slow")) && !(Victim.Role == Custom String("Boss")
				&& Victim.State == Custom String("Dashing")));
				If(Victim.DebuffShield[0] > 0);
					Victim.DebuffShield[0] -= 1;
					Victim.DebuffShield[3] += 1;
				Else;
					Modify Player Variable(Victim, SlowTime, Max, 2 * Filtered Array(Global.ItemStackSizes,
						Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Slow")
						&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0]);
				End;
			End;
			If(Random Real(0, 1) < 0.100 * Filtered Array(Global.ItemStackSizes,
				Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Bleed")
				&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Min(1, Event Damage / (
				Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
				If(Victim.DebuffShield[0] > 0);
					Victim.DebuffShield[0] -= 1;
					Victim.DebuffShield[3] += 1;
				Else;
					Modify Player Variable(Victim, BleedTime, Max, 3 * Min(1, Event Damage / (
						Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
					Victim.BleedInfo[0] += 1;
					Victim.BleedInfo[1] = Max(Attacker.Master[0].BaseDamageMultiplier, (Attacker.Master[0].BaseDamageMultiplier + Victim.BleedInfo[1])
						/ 2);
				End;
			End;
			If(Array Contains(Attacker.Master[0].MyItemStacks, Custom String("Armour Piercing")) && Victim.ArmourPiercingStacks[0] < 5);
				If(Victim.DebuffShield[0] > 0);
					Victim.DebuffShield[0] -= 1;
					Victim.DebuffShield[3] += 1;
				Else;
					If(Victim.ArmourPiercingStacks[0] < 4);
						Victim.ArmourPiercingStacks[0] += 1;
						Modify Player Variable(Victim, APTime, Max, 2 * Min(1, Event Damage / (
							Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
					Else;
						Victim.ArmourPiercingStacks[0] += 1;
						Victim.APTime = 8 * Filtered Array(Global.ItemStackSizes,
							Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Armour Piercing")
							&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0];
						Victim.ArmourModifiers[4] = -60;
						Victim.ShouldUpdateArmour = True;
					End;
				End;
			End;
			If(Event Damage / (Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier)
				>= 50 && Attacker.Master[0].BlastCooldown == 0);
				If(Array Contains(Attacker.Master[0].MyItemStacks, Custom String("Ice Blast")));
					Attacker.Master[0].BlastCooldown = 10;
					Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Victim, 100);
					Play Effect(All Players(All Teams), Echo Sticky Bomb Explosion Effect, Color(White), Victim, 1);
					If(!(Victim.Role == Custom String("Boss") && Victim.State == Custom String("Dashing")));
						If(Victim.DebuffShield[0] > 0);
							Victim.DebuffShield[0] -= 1;
							Victim.DebuffShield[3] += 1;
						Else;
							Modify Player Variable(Victim, SlowTime, Max, 3);
						End;
					End;
					Damage(Victim, Global.NullPlayer[Index Of Array Value(Array(Team 2, Team 1), Team Of(Victim))], 2.500 * Filtered Array(
						Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Ice Blast")
						&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Event Damage);
				End;
				If(Array Contains(Attacker.Master[0].MyItemStacks, Custom String("Flame Blast")));
					Attacker.Master[0].BlastCooldown = 10;
					Attacker.Master[0].FlameTornadoDamage = Event Damage;
					Attacker.Master[0].FlameTornadoPosition = Position Of(Victim);
					Attacker.Master[0].FlameTornadoExpirationTime = Total Time Elapsed + 3;
					Create Effect(All Players(All Teams), Bad Aura, Color(Red), Attacker.Master[0].FlameTornadoPosition, 5, Visible To);
					Attacker.Master[0].FlameTornado = Last Created Entity;
					Play Effect(All Players(All Teams), Reaper Wraith Form Sound, Color(White), Attacker.Master[0].FlameTornadoPosition, 100);
				End;
			Else If(Global.TestMode);
				Attacker.Master[0].NoBlastReason = Array(Event Damage, Victim.DamageReceivedNewAmount, Attacker.Master[0].BaseDamageMultiplier, Attacker.Master[0].BlastCooldown);
			End;
			If(Array Contains(Attacker.Master[0].MyItemStacks, Custom String("Lifesteal")));
				Heal(Attacker.Master[0], Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Attacker.Master[0]))],
					Attacker.Master[0].HealthScale[0] * Filtered Array(Global.ItemStackSizes,
					Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Lifesteal")
					&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Min(1, Event Damage / (
					Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36) / Attacker.Master[0].HealingModifiers[0]);
			End;
			If(Array Contains(Attacker.Master.MyItemStacks, Custom String("Stun Chance")));
				If(Victim.Role != Custom String("Boss") && Random Real(0, 1) < (1 - 1 / (0.050 * Filtered Array(Global.ItemStackSizes,
					Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Stun Chance")
					&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] + 1)) * Min(1, Event Damage / (
					Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
					Set Status(Victim, Attacker.Master[0], Stunned, 2);
				End;
			End;
			If(!Array Contains(Global.LightningStrikes, Attacker.Master[0]) && Array Contains(Attacker.Master[0].MyItemStacks, Custom String(
				"Lightning")) && Random Real(0, 1) < 0.100 * Min(1, Event Damage / (
				Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
				Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Color(White), Eye Position(Victim), 100);
				Modify Global Variable(LightningStrikes, Append To Array, Array(Total Time Elapsed + 0.250, Eye Position(Victim),
					Attacker.Master[0], 5 * Filtered Array(Global.ItemStackSizes,
					Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Lightning")
					&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Event Damage, Min(1, Event Damage / (
					Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36)));
			End;
			If(Array Contains(Attacker.Master[0].MyItemStacks, Custom String("Armour Reduction")));
				If(Victim.DebuffShield[0] > 0);
					Victim.DebuffShield[0] -= 1;
					Victim.DebuffShield[3] += 1;
				Else;
					Victim.ArmourPiercingStacks[1] += Filtered Array(Global.ItemStackSizes,
						Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Armour Reduction")
						&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0];
					Victim.ArmourModifiers[5] = -2 * Victim.ArmourPiercingStacks[1];
					Victim.ShouldUpdateArmour = True;
				End;
			End;
		End;
	}
}

disabled rule("BOTS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Create Queued Bots")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.BotCreationQueue) > 1;
		Count Of(Global.AvailableBotSlots) > 0;
		Server Load Peak < 240;
	}

	actions
	{
		"Don't spawn adds after phase 3"
		If(Global.Phase == 2 || Global.Phase == 3 || !Array Contains(Array(Hero(Wrecking Ball), Hero(Zenyatta), Hero(Tracer)), Global.BotCreationQueue[0]));
			If((Array Contains(All Players(All Teams), Global.BotCreationQueue[1]) && Team Of(Global.BotCreationQueue[1]) == Team 1) || (
				Global.BotCreationQueue[1] == Team 1));
				Create Dummy Bot(Global.BotCreationQueue[0], Team 1, Y Component Of(Last Of(Filtered Array(Global.AvailableBotSlots,
					X Component Of(Current Array Element) == 1))), Vector(300, 0, 0), Forward);
			Else;
				Create Dummy Bot(Global.BotCreationQueue[0], Team 2, Y Component Of(Last Of(Filtered Array(Global.AvailableBotSlots,
					X Component Of(Current Array Element) == 2))), Vector(-300, 0, 0), Forward);
			End;
			Wait Until(Global.BotCreationQueue[0] == Null, 99999);
		End;
		Global.BotCreationQueue = Array Slice(Global.BotCreationQueue, 2, 1000);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Dummy Bot Setup")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Log To Inspector(Custom String("bot joined"));
		If(Array Contains(Array(Hero(Sigma), Hero(Soldier: 76)), Hero Of(Event Player)));
			Event Player.Role = Custom String("NullPlayer");
		Else If(Array Contains(Array(Hero(Wrecking Ball), Hero(Zenyatta), Hero(Tracer)), Hero Of(Event Player)));
			Event Player.Role = Custom String("Add");
		Else If(Hero Of(Event Player) == Hero(Ramattra));
			Event Player.Role = Custom String("Needler");
		End;
		Modify Global Variable(AvailableBotSlots, Remove From Array By Value, Vector(Team Of(Event Player) == Team 1 ? 1 : 2, Slot Of(
			Event Player), 0));
		If(Array Contains(All Players(All Teams), Global.BotCreationQueue[1]));
			Event Player.Master[0] = Global.BotCreationQueue[1];
		Else;
			Event Player.Master[0] = Event Player;
			Start Rule(PlayerSetup, Do Nothing);
		End;
		Global.BotCreationQueue[0] = Null;
	}
}

rule("Destroy bot subroutine")
{
	event
	{
		Subroutine;
		DestroyMe;
	}

	actions
	{
		If(Team Of(Event Player) == Team 2);
			Modify Global Variable(AvailableBotSlots, Append To Array, Vector(Team Of(Event Player) == Team 1 ? 1 : 2, Slot Of(Event Player),
				0));
		End;
		Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
	}
}

disabled rule("ITEMS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Steal subroutine")
{
	event
	{
		Subroutine;
		Steal;
	}

	actions
	{
		Play Effect(Global.CurrentStealee, Moira Fade Disappear Sound, Color(White), Global.CurrentStealee, 100);
		Global.ItemStackOriginalOwners[Global.ItemStackBeingStolenIndex] = Global.CurrentStealee;
		Global.ItemStackOwners[Global.ItemStackBeingStolenIndex] = Null;
		Global.ItemStackNewOwners[Global.ItemStackBeingStolenIndex] = Global.Stealer;
		Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ItemStackBeingStolenIndex, 2,
			-1 * Global.ItemStackSizes[Global.ItemStackBeingStolenIndex], Global.CurrentStealee, False));
	}
}

rule("Handle Item Instances")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State != Null;
		Count Of(Global.ItemStacks) > 0;
		Array Contains(Global.ItemStackOwners, Null) == True;
	}

	actions
	{
		Call Subroutine(HandleItemInstance);
		Global.ItemStackIndex = (Global.ItemStackIndex + 1) % Count Of(Global.ItemStacks);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Acquire Item Subroutine")
{
	event
	{
		Subroutine;
		Acquire;
	}

	actions
	{
		If(Global.ItemStackNewOwners[Global.ItemStackIndex] != Global.ItemStackOriginalOwners[Global.ItemStackIndex]);
			Play Effect(Global.ItemStackNewOwners[Global.ItemStackIndex], Moira Fade Reappear Sound, Color(White),
				Global.ItemStackNewOwners[Global.ItemStackIndex], 100);
		End;
		Global.CurrentItemStackSize = Global.ItemStackSizes[Global.ItemStackIndex];
		Global.ExistingMatchingItemStacks = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
			Global.ItemStacks[Current Array Element] == Global.ItemStacks[Global.ItemStackIndex] && Global.ItemStackOwners[Current Array Element] == Global.ItemStackNewOwners[Global.ItemStackIndex]);
		Global.ItemStackOwners[Global.ItemStackIndex] = Global.ItemStackNewOwners[Global.ItemStackIndex];
		If(Count Of(Global.ExistingMatchingItemStacks) == 0);
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ItemStackIndex, 1, Global.CurrentItemStackSize,
				Global.ItemStackOwners[Global.ItemStackIndex], False));
		Else;
			Global.ItemStackSizes[Global.ItemStackIndex] -= Global.CurrentItemStackSize;
			Global.ItemStackSizes[Global.ExistingMatchingItemStacks[0]] += Global.CurrentItemStackSize;
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ExistingMatchingItemStacks[0], 0,
				Global.CurrentItemStackSize, Global.ItemStackOwners[Global.ItemStackIndex], False));
		End;
		Modify Player Variable(Global.ItemStackNewOwners[Global.ItemStackIndex], ItemStackReturnInfo, Append To Array, Array(
			Global.ItemStackIndex, Global.CurrentItemStackSize));
		Global.ItemStackNewOwners[Global.ItemStackIndex] = Null;
	}
}

rule("Distribute Item Subroutine")
{
	event
	{
		Subroutine;
		DistributeItem;
	}

	actions
	{
		Global.NewItemStackIndex = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
			Global.ItemStacks[Current Array Element] == Global.ItemDistributionInfo[0] && Global.ItemStackOwners[Current Array Element] == Global.ItemDistributionInfo[1]);
		If(Count Of(Global.NewItemStackIndex) > 0);
			Global.NewItemStackIndex = Global.NewItemStackIndex[0];
			Global.ItemStackSizes[Global.NewItemStackIndex] += Global.ItemDistributionInfo[2];
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.NewItemStackIndex, 0, Global.ItemDistributionInfo[2],
				Global.ItemStackOwners[Global.NewItemStackIndex], False));
		Else;
			Call Subroutine(CreateItemStack);
			Global.ItemStackSizes[Global.NewItemStackIndex] += Global.ItemDistributionInfo[2];
		End;
	}
}

rule("Handle Item Instance")
{
	event
	{
		Subroutine;
		HandleItemInstance;
	}

	actions
	{
		If(Global.ItemStackNewOwners[Global.ItemStackIndex]);
			Call Subroutine(Acquire);
		End;
	}
}

rule("Distribute Queued Items")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.ItemDistributionQueue) > 2;
	}

	actions
	{
		"[Item (name), Target Player, Count]"
		Global.ItemDistributionInfo = Array Slice(Global.ItemDistributionQueue, 0, 3);
		Call Subroutine(DistributeItem);
		Global.ItemDistributionQueue = Array Slice(Global.ItemDistributionQueue, 3, 1000);
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Create Item Stack Subroutine")
{
	event
	{
		Subroutine;
		CreateItemStack;
	}

	actions
	{
		Global.NewItemStackIndex = Count Of(Global.ItemStacks);
		Global.ItemStacks[Global.NewItemStackIndex] = Global.ItemDistributionInfo[0];
		Global.ItemStackOwners[Global.NewItemStackIndex] = Global.ItemDistributionInfo[1];
		Global.ItemStackNewOwners[Global.NewItemStackIndex] = Null;
		Create HUD Text(Global.ItemStackSizes[Evaluate Once(Global.NewItemStackIndex)] == 0 ? Null : Global.ItemStackOwners[Evaluate Once(
			Global.NewItemStackIndex)], Evaluate Once(Global.ItemSymbols[Index Of Array Value(Global.Items, Global.ItemDistributionInfo[0])
			]), Custom String("×{0}", Global.ItemStackSizes[Evaluate Once(Global.NewItemStackIndex)]), Null, Left, 4 + Evaluate Once(
			Global.NewItemStackIndex + 1) / (Count Of(Global.ItemStacks) + 1), Global.ItemColours[Index Of Array Value(Global.Items,
			Global.ItemDistributionInfo[0])], Color(White), Null, Visible To Sort Order and String, Default Visibility);
		Global.ItemStackHUDs[Global.NewItemStackIndex] = Last Text ID;
		Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.NewItemStackIndex, 1, Global.ItemDistributionInfo[2],
			Global.ItemStackOwners[Global.NewItemStackIndex], False));
	}
}

rule("Update Item Stacks from Queue")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State != Null;
		Count Of(Global.ItemStackUpdateInfos) > 4;
	}

	actions
	{
		Global.ItemStackUpdateInfo = Array(Global.ItemStackUpdateInfos[0], Global.ItemStacks[Global.ItemStackUpdateInfos[0]],
			Global.ItemStackUpdateInfos[3], Global.ItemStackUpdateInfos[2]);
		If(Array Contains(Array(2, 4), Global.ItemRarities[Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1])]));
			Global.ItemStackUpdateInfo[2].EvenRarityItemsCount += Global.ItemStackUpdateInfo[3];
		End;
		If(Global.ItemStackUpdateInfos[4]);
			Global.ItemStackSizes[Global.ItemStackUpdateInfos[0]] += Global.ItemStackUpdateInfo[3];
		End;
		If(Global.ItemStackUpdateInfo[3] < 0 && !Is True For Any(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Global.ItemStackUpdateInfo[1] && Global.ItemStackOwners[Current Array Index] == Global.ItemStackUpdateInfo[2]));
			Modify Player Variable(Global.ItemStackUpdateInfo[2], MyItemStacks, Remove From Array By Value, Global.ItemStackUpdateInfo[1]);
		End;
		If(Global.ItemStackUpdateInfo[3] > 0 && !Array Contains(Global.ItemStackUpdateInfo[2].MyItemStacks,
			Global.ItemStackUpdateInfo[1]));
			Modify Player Variable(Global.ItemStackUpdateInfo[2], MyItemStacks, Append To Array, Global.ItemStackUpdateInfo[1]);
		End;
		If(Global.ItemStackUpdateInfos[1] == 0);
			Call Subroutine(UpdateItemStack_Modify);
		Else;
			If(Global.ItemStackUpdateInfos[1] > 1);
				Call Subroutine(UpdateItemStack_Remove);
			End;
			If(Global.ItemStackUpdateInfos[1] % 2 == 1);
				Call Subroutine(UpdateItemStack_Add);
			End;
		End;
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Wait(0.100, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Update Item Stack (Add)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Add;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Health, Evaluate Once(Global.ItemStackUpdateInfo[2])
				.HealthScale[0] * 25 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])], True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Shields, (Max Health Of Type(Evaluate Once(Global.ItemStackUpdateInfo[2]),
				Health) + Max Health Of Type(Evaluate Once(Global.ItemStackUpdateInfo[2]), Armor) / 0.700 - Evaluate Once(
				Global.ItemStackUpdateInfo[2]).BarrierHealth) * 0.080 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])],
				True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Health, Evaluate Once(Global.ItemStackUpdateInfo[2])
				.HealthScale[0] * 40 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])], True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
			Global.ItemStackUpdateInfo[2].HealingModifiers[2] = 1.600 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].BarrierInfo[0] = True;
			Call Subroutine(UpdateItemStack_Modify);
		Else If(Array Contains(Array(Custom String("Speed"), Custom String("Double Jump")), Global.ItemStackUpdateInfo[1]));
			Call Subroutine(UpdateItemStack_Modify);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Close Range Damage"));
			Start Damage Modification(Players Within Radius(Eye Position(Global.ItemStackUpdateInfo[2]), 13, All Teams, Off),
				Global.ItemStackUpdateInfo[2], 100 + 20 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])],
				Receivers Damagers and Damage Percent);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Damage Modification ID;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Ice Blast"));
			Chase Player Variable At Rate(Global.ItemStackUpdateInfo[2], BlastCooldown, 0, 1, None);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Flame Blast"));
			Chase Player Variable At Rate(Global.ItemStackUpdateInfo[2], BlastCooldown, 0, 1, None);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Big Explosion"));
			If(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] == Null);
				Create Effect(Global.ItemStackOwners[Evaluate Once(Global.ItemStackUpdateInfo[0])].BoomTime[0] ? All Players(All Teams) : Null,
					Winston Tesla Cannon Target Sound, Color(White), Eye Position(Global.ItemStackOwners[Evaluate Once(
					Global.ItemStackUpdateInfo[0])]), 100, Visible To Position and Radius);
			End;
			Create Effect(Evaluate Once(Global.ItemStackUpdateInfo[2]).BoomTime[0] ? All Players(All Teams) : Null, Sphere, Color(White),
				Eye Position(Evaluate Once(Global.ItemStackUpdateInfo[2])), 30 - (Evaluate Once(Global.ItemStackUpdateInfo[2])
				.BoomTime[0] - Total Time Elapsed) * 10, Visible To Position and Radius);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Entity;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Debuff Shield"));
			Global.ItemStackUpdateInfo[2].DebuffShield[2] = 0;
			Global.ItemStackUpdateInfo[2].DebuffShield[0] += Global.ItemStackUpdateInfo[3];
			Global.ItemStackUpdateInfo[2].DebuffShield[1] += Global.ItemStackUpdateInfo[3];
		End;
	}
}

rule("Update Item Stack (Modify)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Modify;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP"));
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null,
				Global.ItemStackUpdateInfo[2].HealthScale[0] * 25 * Global.ItemStackUpdateInfo[3] / Global.ItemStackUpdateInfo[2].HealingModifiers[0]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null, Max Health Of Type(Global.ItemStackUpdateInfo[2], Health)
				* 0.080 * Global.ItemStackUpdateInfo[3] / Global.ItemStackUpdateInfo[2].HealingModifiers[0]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Speed"));
			Global.ItemStackUpdateInfo[2].MoveSpeedBuffs[3] = 14 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateMoveSpeed = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Double Jump"));
			Global.ItemStackUpdateInfo[2].DoubleJumps[0] = Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].ArmourModifiers[6] = 100 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateArmour = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Global.ItemStackUpdateInfo[2].HealingModifiers[2] = 1.600 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null,
				Global.ItemStackUpdateInfo[2].HealthScale[0] * 40 * Global.ItemStackUpdateInfo[3] / Global.ItemStackUpdateInfo[2].HealingModifiers[0]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Debuff Shield"));
			If(Global.ItemStackUpdateInfo[3] > 0);
				Global.ItemStackUpdateInfo[2].DebuffShield[2] = 0;
			End;
			Global.ItemStackUpdateInfo[2].DebuffShield[0] = Max(0,
				Global.ItemStackUpdateInfo[2].DebuffShield[0] + Global.ItemStackUpdateInfo[3]);
			Global.ItemStackUpdateInfo[2].DebuffShield[1] += Global.ItemStackUpdateInfo[3];
		End;
	}
}

rule("Update Item Stack (Remove)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Remove;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP") || Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Remove Health Pool From Player(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Null;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Speed"));
			Global.ItemStackUpdateInfo[2].MoveSpeedBuffs[3] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateMoveSpeed = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Close Range Damage"));
			Stop Damage Modification(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Double Jump"));
			Global.ItemStackUpdateInfo[2].DoubleJumps[0] = 0;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Big Explosion"));
			Destroy Effect(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackUpdateInfo[2].BoomTime[0] = 0;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].BarrierInfo[0] = False;
			Global.ItemStackUpdateInfo[2].ArmourModifiers[6] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateArmour = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Reprieve"));
			Modify Player Variable At Index(Global.ItemStackUpdateInfo[2], StealthTime, 0, Min, Total Time Elapsed);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Remove Health Pool From Player(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Null;
			Global.ItemStackUpdateInfo[2].HealingModifiers[2] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Debuff Shield"));
			Global.ItemStackUpdateInfo[2].DebuffShield = Array(0, 0, 0);
		End;
	}
}

disabled rule("STATUS EFFECTS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Cleanse some debuffs")
{
	event
	{
		Subroutine;
		CleanseSomeDebuffs;
	}

	actions
	{
		Stop All Damage Over Time(Event Player);
		Event Player.CrippleTime = 0;
		Event Player.SlowTime = 0;
	}
}

rule("Cleanse all debuffs")
{
	event
	{
		Subroutine;
		CleanseAllDebuffs;
	}

	actions
	{
		Call Subroutine(CleanseSomeDebuffs);
		Event Player.BleedTime = 0;
		Event Player.APTime = 0;
		Event Player.RecoveryTime = 0;
		Event Player.ArmourPiercingStacks[1] = 0;
		Event Player.ArmourModifiers[5] = 0;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Crippled")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.CrippleTime > 0;
	}

	actions
	{
		Event Player.MoveSpeedDebuffs[2] = 50;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ArmourModifiers[2] = -20;
		Start Rule(UpdateArmour, Restart Rule);
		Big Message(Event Player, Custom String("CRIPPLED"));
		Wait Until(Event Player.CrippleTime == 0, 9999);
		Event Player.MoveSpeedDebuffs[2] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ArmourModifiers[2] = 0;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Player knocked down")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		If(Team Of(Event Player) == Team 1);
			Clear Status(Event Player, Knocked Down);
		Else If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Clear Status(Event Player, Knocked Down);
		End;
	}
}

rule("Team 2 rooted")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Has Status(Event Player, Rooted) == True;
	}

	actions
	{
		Event Player.WispAcceleration = Vector(0, 0, 0);
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Teleport(Event Player, World Vector Of(Normalize(Throttle Of(Event Player)) * 4, Event Player, Rotation And Translation));
		End;
	}
}

rule("Boss slept")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Has Status(Event Player, Asleep) == True;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Clear Status(Event Player, Asleep);
		End;
	}
}

rule("Boss frozen")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Has Status(Event Player, Frozen) == True;
	}

	actions
	{
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
			Clear Status(Event Player, Frozen);
		End;
	}
}

disabled rule("ITEM EFFECTS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Slowed")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.SlowTime > 0;
	}

	actions
	{
		Event Player.MoveSpeedDebuffs[3] = 60;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Big Message(Event Player, Custom String("SLOWED"));
		Wait Until(Event Player.SlowTime == 0, 9999);
		Event Player.MoveSpeedDebuffs[3] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("No Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierInfo[1] != 0;
		Event Player.BarrierInfo[1] > Total Time Elapsed;
	}

	actions
	{
		Event Player.ArmourModifiers[6] = 0;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierInfo[0] == True;
		Event Player.BarrierInfo[1] < Total Time Elapsed;
	}

	actions
	{
		Event Player.ArmourModifiers[6] = 100 * Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Barrier")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0];
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("No Barrier Health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierHealth == 0;
	}

	actions
	{
		If(Event Player.BarrierHealthDamageModification[1]);
			Stop Damage Modification(Event Player.BarrierHealthDamageModification[0]);
			Event Player.BarrierHealthDamageModification[1] = False;
		End;
	}
}

rule("Barrier Health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierHealth > 0;
		Event Player.BarrierHealthDamageModification[1] == False;
	}

	actions
	{
		Start Damage Modification(Event Player, All Players(All Teams), 100 * Health(Event Player) / (Health(Event Player)
			+ Event Player.BarrierHealth), Receivers Damagers and Damage Percent);
		Event Player.BarrierHealthDamageModification[0] = Last Damage Modification ID;
		Event Player.BarrierHealthDamageModification[1] = True;
		Chase Player Variable At Rate(Event Player, BarrierHealth, 0, (Max Health(Event Player) - Max Health Of Type(Event Player, Armor)
			* 0.300 - Event Player.BarrierHealth) / 30, Destination and Rate);
	}
}

rule("Recover")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.RecoveryTime == 0;
	}

	actions
	{
		Abort If(!Array Contains(Event Player.MyItemStacks, Custom String("Recovery")));
		Heal(Event Player, Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Event Player))], (
			Event Player.HealthScale[0] * 20 + (Max Health Of Type(Event Player, Health) + Max Health Of Type(Event Player, Armor))
			* 0.050 * Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Recovery")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0]) / Event Player.HealingModifiers[0]);
	}
}

rule("Debuff Shield on cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DebuffShield[1] > 0;
		Event Player.DebuffShield[0] == 0;
	}

	actions
	{
		Event Player.DebuffShield[2] = Total Time Elapsed + 5;
	}
}

rule("Debuff Shield off cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DebuffShield[2] > 0;
		Total Time Elapsed > Event Player.DebuffShield[2];
	}

	actions
	{
		Event Player.DebuffShield[2] = 0;
		Event Player.DebuffShield[0] = Event Player.DebuffShield[1];
	}
}

rule("Debuff Shield increase barrier health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DebuffShield[3] > 0;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Event Player.DebuffShield[4] = Event Player.DebuffShield[3];
		Event Player.DebuffShield[5] = Min(Max Health(Event Player) - Max Health Of Type(Event Player, Armor)
			* 0.300 - 2 * Event Player.BarrierHealth, Event Player.DebuffShield[4] * 0.100 * (Max Health(Event Player)
			- Max Health Of Type(Event Player, Armor) * 0.300 - Event Player.BarrierHealth));
		Event Player.BarrierHealth += Event Player.DebuffShield[5];
		Wait(0.100, Ignore Condition);
		Event Player.DebuffShield[3] -= Event Player.DebuffShield[4];
		Loop If Condition Is True;
	}
}

rule("Allow double jump if > 0.8 altitude & have double jumps")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.Role == Custom String("Boss") || Altitude Of(Event Player) > 0.800) == True;
		Event Player.DoubleJumps[0] - Event Player.DoubleJumps[1] > 0;
	}

	actions
	{
		Event Player.DoubleJumps[3] = True;
	}
}

rule("Disallow double jump")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DoubleJumps[1] >= Event Player.DoubleJumps[0];
	}

	actions
	{
		Event Player.DoubleJumps[3] = False;
	}
}

rule("Double jump?")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Abort If(!Event Player.DoubleJumps[3] || Is Dead(Event Player) || Has Status(Event Player, Rooted) || Has Status(Event Player,
			Stunned));
		Event Player.DoubleJumps[2] += 1;
		Abort If((Hero Of(Event Player) == Hero(Genji) && Event Player.DoubleJumps[2] == 1) || (Hero Of(Event Player) == Hero(Hanzo)
			&& Mapped Array(Ability Cooldown(Event Player, Button(Jump)), Current Array Element == 0 || Current Array Element > 4.900)
			[0]));
		Event Player.DoubleJumps[1] += 1;
		Apply Impulse(Event Player, Up, 10, To World, Cancel Contrary Motion);
	}
}

rule("Bleeding")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BleedTime > 0;
	}

	actions
	{
		"20(%)/14"
		Damage(Event Player, Global.NullPlayer[Index Of Array Value(Array(Team 2, Team 1), Team Of(Event Player))],
			1.429 * Event Player.BleedInfo[0] * Event Player.BleedInfo[1]);
		Wait(0.250, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Not Bleeding")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BleedTime == 0;
	}

	actions
	{
		Event Player.BleedInfo = Array(0, 0);
	}
}

rule("Not AP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.APTime == 0;
	}

	actions
	{
		If(Event Player.ArmourPiercingStacks[0] == 5);
			Event Player.ArmourModifiers[4] = 0;
			Start Rule(UpdateArmour, Restart Rule);
		End;
		Event Player.ArmourPiercingStacks[0] = 0;
	}
}

rule("Reprieve")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Array Contains(Event Player.MyItemStacks, Custom String("Reprieve")) == True;
		Normalized Health(Event Player) < 0.250;
		Is Alive(Event Player) == True;
		Event Player.StealthTime[0] == 0;
		Event Player.StealthTime[1] == 0;
	}

	actions
	{
		Event Player.StealthTime[0] = Total Time Elapsed + 5;
		Event Player.StealthTime[1] = Event Player.StealthTime[0] + 30 * 0.500 ^ Max(0, Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Reprieve")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0] - 1);
		Set Invisible(Event Player, All);
		Event Player.MoveSpeedBuffs[4] = 40;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Uncloak")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.StealthTime[0] != 0;
		Total Time Elapsed > Event Player.StealthTime[0];
	}

	actions
	{
		Set Invisible(Event Player, None);
		Event Player.MoveSpeedBuffs[4] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.StealthTime[0] = 0;
	}
}

rule("Reprieve becomes available")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.StealthTime[1] != 0;
		Total Time Elapsed > Event Player.StealthTime[1];
	}

	actions
	{
		Event Player.StealthTime[1] = 0;
	}
}

rule("Start Big Explosion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Normalized Health(Event Player) < 0.250;
		Array Contains(Event Player.MyItemStacks, Custom String("Big Explosion")) == True;
		Event Player.BoomTime[0] == 0;
		Event Player.BoomTime[1] == 0;
	}

	actions
	{
		Event Player.BoomTime[0] = Total Time Elapsed + 3;
		Event Player.BoomTime[1] = Total Time Elapsed + 30 / (1 + Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Reprieve")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0]);
	}
}

rule("Big Explosion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BoomTime[0] != 0;
		Total Time Elapsed > Event Player.BoomTime[0];
	}

	actions
	{
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Color(White), Eye Position(Event Player), 100);
		Play Effect(All Players(All Teams), Bad Explosion, Color(White), Eye Position(Event Player), 30);
		Damage(Players Within Radius(Eye Position(Event Player), 30, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers),
			Event Player, 6000 / 14);
		Event Player.BoomTime[0] = 0;
	}
}

rule("Big explosion becomes available")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BoomTime[1] != 0;
		Total Time Elapsed > Event Player.BoomTime[1];
	}

	actions
	{
		Event Player.BoomTime[1] = 0;
	}
}

rule("Destroy Flame Tornado")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FlameTornado != Null;
		Total Time Elapsed > Event Player.FlameTornadoExpirationTime;
	}

	actions
	{
		Destroy Effect(Event Player.FlameTornado);
		Event Player.FlameTornadoPosition = Null;
		Event Player.FlameTornado = Null;
		Wait(0.016, Ignore Condition);
		Event Player.FlameTornadoExpirationTime = Null;
	}
}

rule("Flame Tornado Damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FlameTornado != Null;
	}

	actions
	{
		Event Player.Victims = Filtered Array(Players Within Radius(Event Player.FlameTornadoPosition, 5, Opposite Team Of(Team Of(
			Event Player)), Off), Event Player.Role != Custom String("Add") || Is On Ground(Current Array Element));
		If(Event Player.Role == Custom String("Add"));
			Set Status(Event Player.Victims, Event Player, Burning, 0.350);
		End;
		Damage(Event Player.Victims, Event Player.Role != Custom String("Add") ? Global.NullPlayer[Index Of Array Value(Array(Team 1,
			Team 2), Team Of(Event Player))] : Event Player, Event Player.FlameTornadoDamage * 0.304);
		Wait(0.304, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Lightning Strike Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.LightningStrikes) > 0;
		Total Time Elapsed > Global.LightningStrikes[0];
	}

	actions
	{
		Global.StrikeVictims = Filtered Array(All Living Players(Opposite Team Of(Team Of(Global.LightningStrikes[2]))), Distance Between(
			Eye Position(Current Array Element), Global.LightningStrikes[1]) < 3);
		Damage(Global.StrikeVictims, Global.LightningStrikes[2],
			Global.LightningStrikes[3] / Global.LightningStrikes[2].BaseDamageMultiplier);
		Apply Impulse(Global.StrikeVictims, Down, 70 * Global.LightningStrikes[4], To World, Cancel Contrary Motion);
		Wait(0.080, Ignore Condition);
		Global.LightningStrikes = Array Slice(Global.LightningStrikes, 5, 1000);
		Loop If Condition Is True;
	}
}

disabled rule("PHASE 0")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter State: Buy")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Buy");
	}

	actions
	{
		Global.ItemShops = Append To Array(Global.Items, Array(Custom String("?"), Custom String("??"), Custom String("???")));
		Global.ItemShopRarities = Append To Array(Global.ItemRarities, Array(1, 2, 3));
		Global.ItemShops = Sorted Array(Global.ItemShops, Global.ItemShopRarities[Current Array Index] + Index Of Array Value(Global.Items,
			Current Array Element) / Count Of(Global.Items));
		Global.ItemShopRarities = Sorted Array(Global.ItemShopRarities, Current Array Element);
		Global.ItemShopRadii = Array(0);
		For Global Variable(ShopIndex, 1, 5, 1);
			Global.ItemShopRadii[Global.ShopIndex * 2 - 1] = 4 * (Max(Count Of(Filtered Array(Global.ItemShopRarities,
				Current Array Element == Global.ShopIndex)), 5) - 1) / 6.283;
			Global.ItemShopRadii[Global.ShopIndex * 2] = Global.ItemShopRadii[Global.ShopIndex * 2 - 2] + Global.ItemShopRadii[Global.ShopIndex * 2 - 1] * 2 + (
				Global.ShopIndex > 1 ? 4 : 0);
			Modify Global Variable At Index(ItemShopRadii, 0, Max, Global.ItemShopRadii[Global.ShopIndex * 2 - 1]);
		End;
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			If(Global.ItemShopRarities[Global.ItemShopIndex - 1] != Global.ItemShopRarities[Global.ItemShopIndex]);
				Global.ShopIndex = Global.ItemShopIndex;
			End;
			Global.ItemShopPositions[Global.ItemShopIndex] = Vector(90 + Global.ItemShopRadii[0], 0, Last Of(Global.ItemShopRadii)
				/ 2 - Global.ItemShopRadii[Global.ItemShopRarities[Global.ItemShopIndex] * 2] + Global.ItemShopRadii[Global.ItemShopRarities[Global.ItemShopIndex] * 2 - 1]);
			Global.ItemShopPositions[Global.ItemShopIndex] += Global.ItemShopRadii[Global.ItemShopRarities[Global.ItemShopIndex] * 2 - 1] * Direction From Angles(
				180 / (1 - Max(Count Of(Filtered Array(Global.ItemShopRarities,
				Current Array Element == Global.ItemShopRarities[Global.ItemShopIndex])), 5)) * (Global.ItemShopIndex - Global.ShopIndex - (
				Count Of(Filtered Array(Global.ItemShopRarities, Current Array Element == Global.ItemShopRarities[Global.ItemShopIndex])) - 1)
				/ 2) - 90, 0);
		End;
		disabled Global.ItemShopPositions = Mapped Array(Global.ItemShops, Vector(95, 0, ((Count Of(Global.ItemShops) - 1)
			/ 2 - Current Array Index) * 3));
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			Create In-World Text(All Players(Team 1), Mapped Array(Index Of Array Value(Global.Items, Global.ItemShops[Global.ItemShopIndex]),
				Current Array Element == -1 ? Global.ItemShops[Global.ItemShopIndex] : Global.ItemSymbols[Current Array Element]),
				Global.ItemShopPositions[Global.ItemShopIndex] + Up, 4, Do Not Clip, Visible To, Mapped Array(Index Of Array Value(
				Global.Items, Global.ItemShops[Global.ItemShopIndex]), Current Array Element == -1 ? Color(White)
				: Global.ItemColours[Current Array Element]), Default Visibility);
			Global.ItemShopEffects1[Global.ItemShopIndex] = Last Text ID;
			Create Effect(All Players(All Teams), Orb, Array(Color(White), Color(Green), Color(Red), Color(Yellow))
				[Global.ItemShopRarities[Global.ItemShopIndex] - 1], Global.ItemShopPositions[Global.ItemShopIndex], 1, Visible To);
			Global.ItemShopEffects2[Global.ItemShopIndex] = Last Created Entity;
			Wait(0.016, Ignore Condition);
		End;
		Global.ItemShopPrices = Mapped Array(Global.ItemShops, Global.ItemRarities[Index Of Array Value(Global.Items,
			Current Array Element)] > 3 ? Custom String("∞") : (Array Contains(Global.Items, Current Array Element) ? 30 : 25) * Array(1,
			2, 16)[(Array Contains(Global.Items, Current Array Element) ? Global.ItemRarities[Index Of Array Value(Global.Items,
			Current Array Element)] : String Length(Current Array Element)) - 1]);
		Wait(10, Abort When False);
		Wait Until(Is True For All(All Players(Team 1), Current Array Element.Role != Custom String("Hero") || (
			Current Array Element.State == Custom String("Ready") && (X Component Of(Position Of(Current Array Element))
			< 80 || Current Array Element.Currency < 25))), 80);
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			Destroy In-World Text(Global.ItemShopEffects1[Global.ItemShopIndex]);
			Destroy Effect(Global.ItemShopEffects2[Global.ItemShopIndex]);
			Wait(0.016, Ignore Condition);
		End;
		Global.State = Custom String("Waiting");
	}
}

rule("Buy (with interact)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Global.State == Custom String("Buy");
		Is True For Any(Global.ItemShopPositions, Distance Between(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(
			Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False), Current Array Element) < 1.500) == True;
	}

	actions
	{
		Event Player.BuyIndex = Sorted Array(Mapped Array(Global.ItemShopPositions, Current Array Index), Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Global.ItemShopPositions[Current Array Element]))[0];
		Call Subroutine(Buy);
	}
}

rule("Random Buy")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.TestMode == True;
		Global.State == Custom String("Buy");
		(!Array Contains(All Players(Team 1), Host Player) || Is Button Held(Host Player, Button(Interact))) == True;
		Event Player.Role == Custom String("Hero");
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(1.250, Abort When False);
		While(True);
			Wait(0.250, Abort When False);
			Event Player.BuyIndex = Random Integer(0, Count Of(Global.ItemShops) - 1);
			Call Subroutine(Buy);
		End;
	}
}

rule("Buy subroutine")
{
	event
	{
		Subroutine;
		Buy;
	}

	actions
	{
		If(Event Player.Currency >= Global.ItemShopPrices[Event Player.BuyIndex] || (
			Global.TestMode && Event Player == Host Player && Global.ItemShopPrices[Event Player.BuyIndex] == Custom String("∞")));
			Event Player.Currency -= Global.ItemShopPrices[Event Player.BuyIndex];
			If(Array Contains(Global.Items, Global.ItemShops[Event Player.BuyIndex]));
				Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Global.ItemShops[Event Player.BuyIndex], Event Player, 1));
			Else;
				If(Global.ItemShops[Event Player.BuyIndex] == Custom String("??") && Random Real(0, 1) < 0.150 * Min(1, Global.StagesCompleted / (
					Event Player.EvenRarityItemsCount + 1)));
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == 4)), Event Player, 1));
				Else;
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == String Length(Global.ItemShops[Event Player.BuyIndex]))), Event Player, 1));
				End;
			End;
			Play Effect(All Players(All Teams), Brigitte Repair Pack Armor Sound, Color(White),
				Global.ItemShopPositions[Event Player.BuyIndex], 100);
		Else;
			Play Effect(Event Player, Sombra Translocator Reappear Sound, Color(White), Global.ItemShopPositions[Event Player.BuyIndex], 50);
		End;
	}
}

rule("On Enter State: Waiting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Waiting");
	}

	actions
	{
		Set Invisible(Event Player, All);
		Start Forcing Player Position(Event Player, Vector(1, 2.500, 0), False);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Status(Event Player, Null, Unkillable, 9999);
		Event Player.CanSwing = False;
	}
}

rule("Enter State: OnTheWay")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Waiting");
		disabled Is True For Any(All Living Players(Team 1), Has Spawned(Current Array Element) && Absolute Value(X Component Of(Position Of(
			Current Array Element))) < 16 && Absolute Value(Z Component Of(Position Of(Current Array Element))) < 16) == True;
		Is True For Any(All Living Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0,
			0, 0)) < 70) == True;
		Is True For Any(Players On Hero(Hero(Reinhardt), Team 2), Has Spawned(Current Array Element)) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.State = Custom String("OnTheWay");
	}
}

rule("On Enter State: OnTheWay")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("OnTheWay");
	}

	actions
	{
		Disable Built-In Game Mode Music;
		Global.Heroes = Filtered Array(All Players(All Teams), Current Array Element.Role == Custom String("Hero"));
		Global.Bosses = Filtered Array(All Players(All Teams), Current Array Element.Role == Custom String("Boss"));
		Global.PlayerCount = Count Of(Global.Heroes);
		Global.BossCount = Count Of(Global.Bosses);
		Global.PlayerFactor = 1 + 0.300 * (Global.PlayerCount - 1);
		Global.TimeFactor = 0.051 * Global.DifficultyValue * Global.PlayerCount ^ 0.200;
		Wait(2, Ignore Condition);
		Global.State = Custom String("Cutscene");
	}
}

rule("On Enter State: Cutscene (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Cutscene");
	}

	actions
	{
		Wait(2.850, Ignore Condition);
		Global.Bosses.State = Custom String("Cutscene");
		Destroy Effect(Global.BossSpawnEffect);
		Wait Until(Is True For All(Global.Bosses, Current Array Element.State == Custom String("Ready")), 99999);
		Global.State = Custom String("BossFight");
		Global.Phase = 1;
		If(Global.Dialogue[0]);
			Modify Global Variable(Dialogue, Append To Array, Array(Null, Custom String("BossSpawn")));
		End;
	}
}

rule("On Enter State: Cutscene (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Cutscene");
	}

	actions
	{
		Start Facing(Event Player, Left, 10000, To World, None);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Stop Forcing Player Position(Event Player);
		Clear Status(Event Player, Phased Out);
		Apply Impulse(Event Player, Down, 70, To World, Cancel Contrary Motion);
		Call Subroutine(UpdateStats);
		Set Invisible(Event Player, None);
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is On Ground(Event Player), 99999);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Color(White), Position Of(Event Player), 100);
		Wait(1.500, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1.500, Ignore Condition);
		Event Player.State = Custom String("Ready");
	}
}

rule("On Enter State: Cutscene (Team 1)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.State == Custom String("Cutscene");
		Event Player.Role == Custom String("Hero");
	}

	actions
	{
		Event Player.CameraPosition = Eye Position(Event Player) + World Vector Of(Forward, Event Player, Rotation);
		Disable Hero HUD(Event Player);
		Start Rule(PrepareSounds, Do Nothing);
		Set Status(Event Player, Null, Rooted, 9999);
		Set Ability 1 Enabled(Event Player, False);
		Set Ability 2 Enabled(Event Player, False);
		Set Primary Fire Enabled(Event Player, False);
		Set Secondary Fire Enabled(Event Player, False);
		Set Ultimate Ability Enabled(Event Player, False);
		Disallow Button(Event Player, Button(Interact));
		Set Melee Enabled(Event Player, False);
		Set Reload Enabled(Event Player, False);
		Wait(0.050, Abort When False);
		Start Camera(Event Player, Event Player.CameraPosition, World Vector Of(2 * Up, Global.Bosses[Slot Of(Event Player) % Count Of(
			Global.Bosses)], Rotation And Translation), 60);
		Start Rule(SoundCue, Restart Rule);
		If(Distance Between(Global.Bosses[Slot Of(Event Player) % Count Of(Global.Bosses)], Event Player.CameraPosition)
			< Distance Between(Global.Bosses[Slot Of(Event Player) % Count Of(Global.Bosses)], World Vector Of(Vector(0, 2, 35),
			Global.Bosses[Slot Of(Event Player) % Count Of(Global.Bosses)], Rotation And Translation)));
			Chase Player Variable At Rate(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 6), Global.Bosses[Slot Of(Event Player)
				% Count Of(Global.Bosses)], Rotation And Translation), 10, Destination and Rate);
		Else;
			Chase Player Variable Over Time(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 35), Global.Bosses[Slot Of(Event Player)
				% Count Of(Global.Bosses)], Rotation And Translation), 1, Destination and Duration);
			Wait(1, Abort When False);
			Chase Player Variable At Rate(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 6), Global.Bosses[Slot Of(Event Player)
				% Count Of(Global.Bosses)], Rotation And Translation), 15, Destination and Rate);
		End;
		Wait Until(Global.State != Custom String("Cutscene"), 9999);
		Clear Status(Event Player, Rooted);
		Set Ability 1 Enabled(Event Player, True);
		Set Ability 2 Enabled(Event Player, True);
		Set Primary Fire Enabled(Event Player, True);
		Set Secondary Fire Enabled(Event Player, True);
		Set Ultimate Ability Enabled(Event Player, True);
		Allow Button(Event Player, Button(Interact));
		Set Melee Enabled(Event Player, True);
		Set Reload Enabled(Event Player, True);
		Chase Player Variable At Rate(Event Player, CameraPosition, Eye Position(Event Player) + World Vector Of(Forward, Event Player,
			Rotation), 60, Destination and Rate);
		Enable Hero HUD(Event Player);
		Wait Until(Distance Between(Event Player.CameraPosition, Eye Position(Event Player)) < 1.500, 1);
		Stop Camera(Event Player);
		Stop Chasing Player Variable(Event Player, CameraPosition);
		Event Player.CameraPosition = Null;
	}
}

rule("Prepare Sound Cue")
{
	event
	{
		Subroutine;
		PrepareSounds;
	}

	actions
	{
		Event Player.Sounds = Array(False, False, False, False, False);
		Create Effect(Event Player.Sounds[0] || Event Player.Sounds[1] || Event Player.Sounds[4] ? Event Player : Null, Energy Sound,
			Color(White), Event Player, 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Echo Focusing Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] ? Event Player : Null, Zarya Particle Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Create Effect(Event Player.Sounds[4] ? Event Player : Null, Decal Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Echo Focusing Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] ? Event Player : Null, Zarya Particle Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Create Effect(Event Player.Sounds[4] ? Event Player : Null, Decal Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Echo Focusing Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] ? Event Player : Null, Zarya Particle Beam Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Create Effect(Event Player.Sounds[4] ? Event Player : Null, Decal Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[0] ? Event Player : Null, Beacon Sound, Color(White), Event Player, 100,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[2] || Event Player.Sounds[0] ? Event Player : Null, Bad Aura Sound, Color(White), Event Player,
			100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[1] || Event Player.Sounds[4] ? Event Player : Null, Echo Cloning Sound, Color(White),
			Event Player, 100, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[2] ? Event Player : Null, Omnic Slicer Beam Sound, Color(White), Event Player, 100,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
		Create Effect(Event Player.Sounds[3] ? Event Player : Null, Baptiste Immortality Field Protected Sound, Color(White), Event Player,
			Event Player.Sounds[2] ? 100 : 40, Visible To Position and Radius);
		Modify Player Variable(Event Player, Sounds, Append To Array, Last Created Entity);
	}
}

rule("Sound Cue")
{
	event
	{
		Subroutine;
		SoundCue;
	}

	actions
	{
		Wait(0.300, Ignore Condition);
		Call Subroutine(Call);
		If(Global.Phase < 2);
			Event Player.Sounds[3] = True;
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
		Else;
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
			Wait(0.188, Ignore Condition);
			Call Subroutine(Call);
			Wait(0.375, Ignore Condition);
			Call Subroutine(Call);
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
			Wait(0.188, Ignore Condition);
			Call Subroutine(Call);
			Wait(0.375, Ignore Condition);
			Call Subroutine(Call);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[0] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[0] = False;
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[1] = False;
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[3] = True;
			Event Player.Sounds[4] = True;
			Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
				Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
			Wait(0.188, Ignore Condition);
			Event Player.Sounds[4] = False;
		End;
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = True;
		Event Player.Sounds[2] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(2.820, Ignore Condition);
		Event Player.Sounds[2] = False;
		Event Player.Sounds[3] = False;
		Destroy Effect(Array Slice(Event Player.Sounds, 5, 1000));
	}
}

rule("Motif")
{
	event
	{
		Subroutine;
		Call;
	}

	actions
	{
		Event Player.Sounds[0] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(0.375, Ignore Condition);
		Event Player.Sounds[0] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = True;
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Play Effect(Event Player, DVa Micro Missiles Explosion Sound, Color(White),
			Event Player.CameraPosition ? Event Player.CameraPosition : Eye Position(Event Player), 100);
		Wait(0.188, Ignore Condition);
		Event Player.Sounds[0] = False;
		Wait(0.188, Ignore Condition);
	}
}

disabled rule("PHASE 1")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reset Shockwave")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.ShockwaveRadius == 55;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, ShockwaveRadius);
		Event Player.ShockwaveRadius = -1;
		Destroy Effect(Event Player.ShockwaveEffect);
	}
}

rule("On Phase 1 Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 1;
	}

	actions
	{
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ShowBossBar = True;
		Stop Facing(Event Player);
		Wait(1, Abort When False);
		Chase Player Variable At Rate(Event Player, TakeoffCooldown, 0, 1, None);
		Event Player.State = Custom String("ClosingIn");
	}
}

rule("On Enter State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("ClosingIn");
	}

	actions
	{
		Event Player.CanSprint = True;
		Event Player.CanNeedle[1] = Event Player.CanNeedle[0];
		Event Player.MoveSpeedBuffs[2] = 200;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Start Forcing Throttle(Event Player, 1, 1, 0, 0, 0, 0.010);
	}
}

rule("Exit State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("ClosingIn");
		Is True For Any(All Living Players(Team 1), Distance Between(Event Player, Current Array Element) < 2) == True;
	}

	actions
	{
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("On Exit State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
	}

	actions
	{
		Event Player.CanNeedle[1] = False;
		Event Player.MoveSpeedBuffs[2] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("On Enter State: Becoming Idle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("BecomingIdle");
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Crouch));
		Stop Forcing Throttle(Event Player);
		If(Event Player.PizzaIndex == Custom String("ASAP"));
			Event Player.State = Custom String("Pizza");
		Else If(Array Contains(Array(1, 3), Global.Phase) && Is On Ground(Event Player) && Normalized Health(Event Player)
				< 0.750 && Event Player.TakeoffCooldown == 0);
			Event Player.State = Custom String("StartingTakeoff");
		Else;
			Stop Forcing Throttle(Event Player);
			If(Global.Phase == 4);
				Event Player.CanNeedle = Array(True, True);
			End;
			Event Player.State = Custom String("Idle");
		End;
	}
}

rule("Enable Sprint")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Idle");
		Is True For Any(All Living Players(Team 1), Distance Between(Position Of(Current Array Element) - Y Component Of(Position Of(
			Current Array Element)) * Up, Event Player) < 13) == False;
	}

	actions
	{
		Event Player.CanSprint = True;
	}
}

rule("Disable Sprint")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
		(Event Player.State == Custom String("Idle") && !Is True For Any(All Living Players(Team 1), Distance Between(Position Of(
			Current Array Element) - Y Component Of(Position Of(Current Array Element)) * Up, Event Player) < 13)) == False;
	}

	actions
	{
		Event Player.CanSprint = False;
	}
}

rule("Enter State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
		Event Player.CanSprint == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		Event Player.State = Custom String("ClosingIn");
	}
}

rule("Enable Takeoff (cooldown & state etc permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		"Maybe add an extra requirement - either a manual keypress or taking 2 instances of damage for each takeoff or something?"
		Normalized Health(Event Player) < 0.750;
	}

	actions
	{
		Event Player.CanTakeOff = True;
	}
}

rule("Enter State: StartingTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanTakeOff == True;
		Event Player.State == Custom String("Idle");
		"Maybe add an extra requirement - either a manual keypress or taking 2 instances of damage for each takeoff or something?"
		Event Player.TakeoffCooldown == 0;
		Is On Ground(Event Player) == True;
		"don't initiate takeoff just before hammer hits the ground"
		Ultimate Charge Percent(Event Player) > 95;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is Crouching(Event Player), 99999);
		Abort If Condition Is False;
		Event Player.State = Custom String("StartingTakeoff");
	}
}

rule("On Enter State: StartingTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingTakeoff");
	}

	actions
	{
		Event Player.State = Custom String("Takeoff");
	}
}

rule("On Enter State: FinishingFullTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("FinishingFullTakeoff");
	}

	actions
	{
		Event Player.BleedTime = 0;
		If(Global.Phase == 3);
			Stop Chasing Player Variable(Event Player, TakeoffCooldown);
		End;
		Event Player.TakeoffCooldown = 30;
		If(Global.Phase == 3);
			Event Player.PizzaIndex = Custom String("Soon");
		End;
		Event Player.CachedHealth[0] = True;
		Call Subroutine(UpdateStats);
		Wait(3, Abort When False);
		Event Player.State = Custom String("Landing");
	}
}

rule("On Enter State: Landing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Landing");
	}

	actions
	{
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Stop Forcing Player Position(Event Player);
		Clear Status(Event Player, Phased Out);
		Apply Impulse(Event Player, Down, 70, To World, Cancel Contrary Motion);
		Set Invisible(Event Player, None);
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is On Ground(Event Player), 99999);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Color(White), Position Of(Event Player), 100);
		If(Global.Phase == 1 || Event Player.PizzaIndex == Custom String("Soon"));
			Create Effect(All Players(All Teams), Ring, Color(Sky Blue), Vector(0, 0, 0), Event Player.ShockwaveRadius + 2,
				Visible To Position and Radius);
			Event Player.ShockwaveEffect = Last Created Entity;
			Event Player.ShockwaveRadius = 0;
			Chase Player Variable At Rate(Event Player, ShockwaveRadius, 55, 10, None);
			Event Player.CanNeedle = Array(True, False);
		End;
		Wait(1, Abort When False);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1, Abort When False);
		"Remove Armour Boost"
		Event Player.ArmourModifiers[1] = 0;
		Start Rule(UpdateArmour, Restart Rule);
		Clear Status(Event Player, Rooted);
		Call Subroutine(ChooseState);
		Abort If(Event Player.PizzaIndex != Custom String("Soon"));
		Event Player.PizzaTime[0] = Total Time Elapsed + Random Real(5, 8.500);
	}
}

rule("Choose State (Closing In / Becoming Idle)")
{
	event
	{
		Subroutine;
		ChooseState;
	}

	actions
	{
		If(Is True For Any(All Living Players(Team 1), Distance Between(Event Player, Current Array Element) < 2));
			Event Player.State = Custom String("BecomingIdle");
		Else;
			Event Player.State = Custom String("ClosingIn");
		End;
	}
}

rule("Shockwave Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is True For Any(Global.Bosses, Current Array Element.ShockwaveRadius > 0 && Distance Between(Event Player,
			Current Array Element.ShockwaveRadius * Direction From Angles(Horizontal Angle From Direction(Position Of(Event Player)), 0))
			< 0.500) == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Phased Out) == False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Damage(Event Player, Global.NullPlayer[1], 170 * Global.Bosses[0].BaseDamageMultiplier);
		If(Event Player.DebuffShield[0] > 0);
			Event Player.DebuffShield[0] -= 1;
			Event Player.DebuffShield[3] += 1;
		Else;
			Modify Player Variable(Event Player, CrippleTime, Max, 3);
		End;
	}
}

rule("Low health")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Health(Event Player) < 2;
	}

	actions
	{
		Abort If(Event Player.HasLostThisPhase);
		Log To Inspector(Custom String("\"death\""));
		"probably need a bunch more caveats"
		If(Global.Phase == 1);
			Event Player.HasLostThisPhase = True;
			If(Event Player.State == Custom String("Takeoff"));
				Event Player.State = Custom String("Takeoff2");
			Else If(Event Player.State == Custom String("FullTakeoff"));
				Event Player.State = Custom String("FullTakeoff2");
			Else If(Event Player.State == Custom String("FinishingFullTakeoff"));
				Event Player.State = Custom String("FinishingFullTakeoff2");
			Else;
				Event Player.State = Custom String("StartingTakeoff2");
			End;
		Else If(Global.Phase == 3);
			Play Effect(All Players(All Teams), Sombra EMP Explosion Sound, Color(White), Event Player, 100);
			Event Player.HasLostThisPhase = True;
			Event Player.CanSwing = False;
			Event Player.CanSlam = False;
			Cancel Primary Action(Event Player);
			Set Status(Event Player, Null, Phased Out, 9999);
			Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
			Set Invisible(Event Player, All);
			Event Player.ShowBossBar = False;
			Call Subroutine(CleanseAllDebuffs);
			Event Player.State = Custom String("Absent");
		End;
	}
}

rule("On Enter State: StartingTakeoff2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingTakeoff2");
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Event Player.State = Custom String("Takeoff2");
	}
}

rule("TakeOff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(Custom String("Takeoff"), Custom String("Takeoff2")), Event Player.State) == True;
	}

	actions
	{
		"Add Armour Boost"
		Event Player.ArmourModifiers[1] = 200;
		Start Rule(UpdateArmour, Restart Rule);
		Event Player.CanSwing = False;
		Event Player.CanSlam = False;
		Start Holding Button(Event Player, Button(Crouch));
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Wait(1, Abort When False);
		Event Player.State = Mapped Array(Event Player.State, String Contains(Current Array Element, Custom String("Takeoff"))
			? Custom String("Full{0}", Current Array Element) : Current Array Element)[0];
		Abort If(!String Contains(Event Player.State, Custom String("Takeoff")));
		Apply Impulse(Event Player, Up, 70, To World, Cancel Contrary Motion);
		Wait(0.250, Ignore Condition);
		Set Invisible(Event Player, All);
		Start Forcing Player Position(Event Player, Vector(1, 50, 0), False);
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.State = Custom String("Finishing{0}", Event Player.State);
	}
}

rule("Stunned during takeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Takeoff");
		Has Status(Event Player, Stunned) == True;
	}

	actions
	{
		Event Player.State = Custom String("AbortingTakeoff");
		Event Player.TakeoffCooldown = 30;
		"Remove Armour Boost"
		Event Player.ArmourModifiers[1] = 0;
		Event Player.ShouldUpdateArmour = True;
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("On Enter State: FinishingFullTakeoff2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("FinishingFullTakeoff2");
	}

	actions
	{
		Event Player.ShowBossBar = False;
		Event Player.TakeoffCooldown = 0;
		Call Subroutine(CleanseAllDebuffs);
		Event Player.State = Custom String("Absent");
	}
}

rule("Enter Phase: 2/4")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.Bosses) > 0;
		Is True For All(Global.Bosses, Current Array Element.State == Custom String("Absent")) == True;
	}

	actions
	{
		If(Global.Phase == 1);
			Global.Phase = 2;
		Else If(Global.Phase == 3);
			Global.Phase = 4;
		End;
	}
}

disabled rule("SWING")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Disable Swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Event Player.CanSwing && Event Player.SwingCooldown == 0) == False;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
	}
}

rule("Enable swing (cooldown permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
	}

	actions
	{
		Event Player.CanSwing = True;
	}
}

rule("Enable swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanSwing == True;
		Event Player.SwingCooldown == 0;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("Enter State: StartingSwing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		If(Event Player.CanSwing);
			Event Player.State = Custom String("StartingSwing");
		Else;
			Cancel Primary Action(Event Player);
		End;
	}
}

rule("On Enter State: StartingSwing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingSwing");
	}

	actions
	{
		Disable Movement Collision With Players(Event Player);
		Event Player.CanSlam = False;
		Event Player.SwingCooldown = 5;
		Wait(0.200, Abort When False);
		Start Forcing Throttle(Event Player, 0, 1, 0, 1, 0, 0);
		Wait Until(Is On Ground(Event Player), 1);
		Event Player.DashAngles[0] = Horizontal Facing Angle Of(Event Player);
		Event Player.DashAngles[1] = 4.945;
		Set Gravity(Event Player, 63);
		Event Player.DashSpeed = 32 / Event Player.MoveSpeedDebuffs[0];
		Call Subroutine(Dash);
		Event Player.State = Custom String("Swinging");
	}
}

disabled rule("SLAM")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Disable Slam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Event Player.CanSlam && Event Player.SlamCooldown == 0) == False;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, False);
	}
}

rule("Enable slam (cooldown permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
	}

	actions
	{
		Event Player.CanSlam = True;
	}
}

rule("Enable slam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanSlam == True;
		Event Player.SlamCooldown == 0;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		Set Ultimate Ability Enabled(Event Player, True);
	}
}

rule("Enter State: Slamming")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Slamming");
	}
}

rule("On Enter State: Slamming")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Slamming");
	}

	actions
	{
		Event Player.SlamCooldown = 4;
		Event Player.CanSwing = False;
		Event Player.CanDash[0] = False;
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		If(Global.Phase == 3);
			Modify Global Variable(FlamePillarPositions, Append To Array, World Vector Of(3 * Forward, Event Player,
				Rotation And Translation));
			Modify Global Variable(FlamePillarExpirationTimes, Append To Array, Total Time Elapsed + 45);
			Create Effect(All Players(All Teams), Light Shaft, Color(Blue), Last Of(Global.FlamePillarPositions), 1, Visible To);
			Modify Global Variable(FlamePillars, Append To Array, Last Created Entity);
		End;
		Wait(Random Real(0, 3), Abort When False);
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("Augmented slam")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		If(Event Was Critical Hit);
			Damage(Victim, Attacker, 340);
		End;
		Abort If(Global.Phase < 3);
		Damage(Victim, Attacker, 35);
		If(Victim.DebuffShield[0] > 0);
			Victim.DebuffShield[0] -= 1;
			Victim.DebuffShield[3] += 1;
		Else;
			Modify Player Variable(Victim, CrippleTime, Max, 3);
		End;
	}
}

disabled rule("DASH")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Enable Dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
		Global.Phase != 4;
	}

	actions
	{
		Event Player.CanDash[0] = True;
	}
}

rule("Disable Dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Is On Ground(Event Player) && Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State)
			&& Global.Phase != 4) == False;
	}

	actions
	{
		Event Player.CanDash[0] = False;
	}
}

rule("Replenish all dashes")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanDash[2] > 0;
		Total Time Elapsed > Event Player.CanDash[2];
	}

	actions
	{
		Event Player.CanDash[1] = 2;
	}
}

rule("Enter State: Dashing (with jump button)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanDash[0] == True;
		Event Player.CanDash[1] > 0;
		Event Player.DashCooldown == 0;
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Event Player.State = Custom String("Dashing");
	}
}

rule("Enter State: Dashing (with sideways movement)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanDash[1] > 0;
		Event Player.DashCooldown == 0;
		Absolute Value(X Component Of(Throttle Of(Event Player))) > 0.005;
	}

	actions
	{
		Abort If(!Event Player.CanDash[0] || Event Player.State != Custom String("ClosingIn"));
		Event Player.State = Custom String("Dashing");
	}
}

rule("On Enter State: Dashing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Dashing");
	}

	actions
	{
		Event Player.CanDash[1] -= 1;
		Event Player.CanDash[2] = Total Time Elapsed + 3.400;
		If(Event Player.CanDash[1] == 0);
			Event Player.DashCooldown = 3.400;
		Else;
			Event Player.DashCooldown = 2;
		End;
		Call Subroutine(CleanseSomeDebuffs);
		Disable Movement Collision With Players(Event Player);
		Event Player.CanSlam = False;
		Event Player.DashAngles[0] = Horizontal Angle From Direction(World Vector Of(Mapped Array(Throttle Of(Event Player),
			X Component Of(Current Array Element) == 0 ? (Z Component Of(Current Array Element) == 0 ? Forward : Backward) : Vector(
			X Component Of(Current Array Element) * 100, 0, Z Component Of(Current Array Element))), Event Player, Rotation));
		Event Player.DashAngles[1] = 6.300;
		Set Gravity(Event Player, 175);
		Event Player.DashSpeed = 31;
		Call Subroutine(Dash);
	}
}

rule("Is On Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.DoubleJumps[1] = 0;
		Event Player.DoubleJumps[2] = 0;
		If(Event Player.Role != Custom String("Boss"));
			Event Player.DoubleJumps[3] = False;
		End;
		If(Array Contains(Array(Custom String("Dashing"), Custom String("Swinging")), Event Player.State));
			Log To Inspector(Custom String("S: {0} T: {1}", Distance Between(Event Player, Event Player.DashStartPosition),
				Total Time Elapsed - Event Player.DashStartTime));
			Set Gravity(Event Player, 100);
			Event Player.State = Custom String("BecomingIdle");
		End;
	}
}

rule("On Exit State: Dash/Swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("Dashing");
		Event Player.State != Custom String("Swinging");
		Event Player.State != Custom String("StartingSwing");
	}

	actions
	{
		Enable Movement Collision With Players(Event Player);
	}
}

rule("Dash subroutine")
{
	event
	{
		Subroutine;
		Dash;
	}

	actions
	{
		Event Player.DashStartPosition = Position Of(Event Player);
		Event Player.DashStartTime = Total Time Elapsed;
		Apply Impulse(Event Player, Direction From Angles(Event Player.DashAngles[0], Is On Ground(Event Player)
			? -1 * Event Player.DashAngles[1] : Max(-1 * Event Player.DashAngles[1], Vertical Facing Angle Of(Event Player))),
			Event Player.DashSpeed, To World, Cancel Contrary Motion XYZ);
	}
}

disabled rule("SHOOT")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Needler Bot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ramattra;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.Role == Custom String("Needler");
	}

	actions
	{
		Event Player.Master[0].Bots[0] = Event Player;
		Wait(0.250, Ignore Condition);
		Start Forcing Dummy Bot Name(Event Player, Event Player.Master[0]);
		Set Gravity(Event Player, 0);
		Disable Movement Collision With Environment(Event Player, True);
		Attach Players(Event Player, Event Player.Master[0], Vector Towards(Local Vector Of(Eye Position(Event Player), Event Player,
			Rotation And Translation), Local Vector Of(Eye Position(Event Player.Master[0]), Event Player.Master[0],
			Rotation And Translation)));
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Invisible(Event Player, All);
		Start Facing(Event Player, Facing Direction Of(Event Player.Master[0]), 720, To World, Direction and Turn Rate);
	}
}

rule("Replenish needle ammo")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.NeedleCooldown == 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, NeedleAmmo);
		Event Player.NeedleAmmo = 30;
	}
}

rule("Start Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.NeedleCooldown == 0;
		Event Player.NeedleAmmo > 0;
		Event Player.CanNeedle[1] == True;
	}

	actions
	{
		Event Player.NeedleCooldown = 6;
		Start Holding Button(Event Player.Bots[0], Button(Primary Fire));
		Chase Player Variable At Rate(Event Player, NeedleAmmo, 0, 25, None);
		If(Global.TestMode);
			Log To Inspector(Custom String("Start holding button"));
			Small Message(Event Player, Custom String("Start holding button"));
		End;
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.NeedleAmmo == 0;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
		If(Global.TestMode);
			Log To Inspector(Custom String("Out of ammo"));
			Small Message(Event Player, Custom String("Out of ammo"));
		End;
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
		If(Global.TestMode);
			Log To Inspector(Custom String("Not holding button"));
			Small Message(Event Player, Custom String("Not holding button"));
		End;
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanNeedle[1] == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
		If(Global.TestMode);
			Log To Inspector(Custom String("Shoot disabled"));
			Small Message(Event Player, Custom String("Shoot disabled"));
		End;
	}
}

disabled rule("PHASE 2")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter Phase: 2 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 2;
	}

	actions
	{
		Call Subroutine(SetCoefficient);
		For Global Variable(BossIndex, 0, Min(2, Global.BossCount) * 2, 1);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Tracer), Team 2));
			Wait(0.016, Abort When False);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Tracer), Team 2));
			Wait(0.016, Abort When False);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Zenyatta), Team 2));
			Wait(0.016, Abort When False);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Wrecking Ball), Team 2));
			Wait(0.016, Abort When False);
		End;
		Start Heal Over Time(Global.Bosses, Null, 16, 10000);
	}
}

rule("Enter Phase: 3")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 2;
		Count Of(Global.BotCreationQueue) == 0;
		Is True For Any(All Living Players(Team 2), Current Array Element.Role == Custom String("Add")) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Global.Phase = 3;
	}
}

rule("AI Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For Any(All Living Players(Team 2), Current Array Element.Role == Custom String("Add")) == True;
	}

	actions
	{
		Global.Adds = Filtered Array(All Living Players(Team 2),
			Current Array Element.Master[0] && Current Array Element.Role == Custom String("Add")
			&& Current Array Element.Master[1] == Null && Current Array Element.State && Current Array Element.State != Custom String(
			"IndividualSetup"));
		For Global Variable(AiIndex, 0, Count Of(Global.Adds), 1);
			Global.Add = Global.Adds[Global.AiIndex];
			Call Subroutine(AiStep);
			Wait(0.050, Ignore Condition);
		End;
		Wait(0.200, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("AiStep")
{
	event
	{
		Subroutine;
		AiStep;
	}

	actions
	{
		Abort If(Global.Add.Master[1] != Null);
		If(Hero Of(Global.Add) == Hero(Tracer));
			Call Subroutine(ChooseVThrottle);
		End;
		If(Global.Add.Target);
			If(!Array Contains(Filtered Array(All Living Players(Team 1), Current Array Element.StealthTime[0] == 0), Global.Add.Target));
				Global.Add.Target = Null;
				Call Subroutine(LoseTarget);
				Abort;
			End;
			If(Global.Add.State == Custom String("Idle"));
				Call Subroutine(TryShoot);
				disabled Else If(Global.Add.State == Custom String("Shoot"));
			End;
			If(Hero Of(Global.Add) == Hero(Zenyatta) && Global.Add.State == Custom String("Idle"));
				Press Button(Global.Add, Button(Ability 1));
			End;
		Else;
			If(Global.Add.State == Custom String("Rise"));
				If(Y Component Of(Position Of(Global.Add)) > 15);
					Global.Add.Master[2] = True;
					Global.Add.State = Custom String("Idle");
				Else;
					Abort;
				End;
			End;
			"Try choose target"
			Global.Add.Target = Sorted Array(Filtered Array(All Living Players(Team 1), !Has Status(Current Array Element, Phased Out)
				&& Current Array Element.StealthTime[0] == 0 && Current Array Element.Master[0] == Current Array Element), Distance Between(
				Global.Add, Current Array Element))[0];
			If(Global.Add.Target);
				If(Hero Of(Global.Add) == Hero(Wrecking Ball));
					Start Facing(Global.Add, Direction Towards(Eye Position(Evaluate Once(Global.Add)), Eye Position(Evaluate Once(Global.Add)
						.Target)), Is In Alternate Form(Evaluate Once(Global.Add)) ? 35 : 12.600, To World, Direction and Turn Rate);
				Else If(Hero Of(Global.Add) == Hero(Zenyatta));
					Start Facing(Global.Add, Direction Towards(Eye Position(Evaluate Once(Global.Add)), Eye Position(Evaluate Once(Global.Add)
						.Target)), 720, To World, Direction and Turn Rate);
				Else If(Hero Of(Global.Add) == Hero(Tracer));
					Start Facing(Global.Add, Direction Towards(Eye Position(Evaluate Once(Global.Add)), Eye Position(Evaluate Once(Global.Add)
						.Target)), Is Firing Primary(Evaluate Once(Global.Add)) ? 12.600 : 35, To World, Direction and Turn Rate);
				End;
			End;
		End;
	}
}

rule("Evaluate wisp vertical throttle")
{
	event
	{
		Subroutine;
		ChooseVThrottle;
	}

	actions
	{
		If(Global.Add.Target);
			If(Vertical Angle Towards(Global.Add.Target, Global.Add) < 10 && Vertical Speed Of(Global.Add) > -1 && Is Button Held(Global.Add,
				Button(Jump)));
				Stop Holding Button(Global.Add, Button(Jump));
			End;
			If(Vertical Angle Towards(Global.Add.Target, Global.Add) > -35 && Vertical Speed Of(Global.Add) < 1 && Is Button Held(Global.Add,
				Button(Crouch)));
				Stop Holding Button(Global.Add, Button(Crouch));
			End;
			If(Vertical Angle Towards(Global.Add.Target, Global.Add) > 0 || (Vertical Angle Towards(Global.Add.Target, Global.Add)
				> -35 && Vertical Speed Of(Global.Add) < -1));
				Start Holding Button(Global.Add, Button(Jump));
			Else If(Vertical Angle Towards(Global.Add.Target, Global.Add) < -50 || (Vertical Angle Towards(Global.Add.Target, Global.Add)
					< 10 && Vertical Speed Of(Global.Add) > 1));
				Start Holding Button(Global.Add, Button(Crouch));
			End;
		Else;
			If(Y Component Of(Position Of(Global.Add)) > 20 && Vertical Speed Of(Global.Add) > -1 && Is Button Held(Global.Add, Button(Jump)));
				Stop Holding Button(Global.Add, Button(Jump));
			End;
			If(Y Component Of(Position Of(Global.Add)) < 20 && Vertical Speed Of(Global.Add) < 1 && Is Button Held(Global.Add, Button(
				Crouch)));
				Stop Holding Button(Global.Add, Button(Crouch));
			End;
			If(Y Component Of(Position Of(Global.Add)) < 15 || (Y Component Of(Position Of(Global.Add)) < 20 && Vertical Speed Of(Global.Add)
				< -1));
				Start Holding Button(Global.Add, Button(Jump));
			Else If(Y Component Of(Position Of(Global.Add)) > 25 || (Y Component Of(Position Of(Global.Add)) > 20 && Vertical Speed Of(
					Global.Add) > 1));
				Start Holding Button(Global.Add, Button(Crouch));
			End;
		End;
	}
}

rule("Add. has no target")
{
	event
	{
		Subroutine;
		LoseTarget;
	}

	actions
	{
		(Event Player != Null ? Event Player : Global.Add).Target = Null;
		Stop Facing(Event Player != Null ? Event Player : Global.Add);
		Stop Forcing Throttle(Event Player != Null ? Event Player : Global.Add);
		(Event Player != Null ? Event Player : Global.Add).State = Custom String("Idle");
	}
}

rule("TryShoot")
{
	event
	{
		Subroutine;
		TryShoot;
	}

	actions
	{
		Abort If(Distance Between(Global.Add, Global.Add.Target) > (Hero Of(Global.Add) == Hero(Wrecking Ball) ? 18 : 25));
		Abort If(Distance Between(Global.Add, Global.Add.Target) < 15 && Ultimate Charge Percent(Global.Add) == 100);
		Abort If(Hero Of(Global.Add) == Hero(Tracer) && !Is In View Angle(Global.Add, Eye Position(Global.Add.Target), 35));
		Abort If(Hero Of(Global.Add) == Hero(Wrecking Ball) && Ammo(Global.Add, 0) < Max Ammo(Global.Add, 0));
		Abort If(Hero Of(Global.Add) == Hero(Wrecking Ball) && !Is In View Angle(Global.Add, Eye Position(Global.Add.Target), 40));
		Global.Add.State = Custom String("Shoot");
		If(Hero Of(Global.Add) == Hero(Wrecking Ball));
			Start Holding Button(Global.Add, Button(Primary Fire));
		End;
	}
}

rule("Add. enter state: idle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.Role == Custom String("Add");
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
		Distance Between(Event Player, Event Player.Target) > (Hero Of(Event Player) == Hero(Wrecking Ball) ? 18 : 25);
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Event Player.State = Custom String("Idle");
	}
}

rule("Add. on exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.Role == Custom String("Add");
		Event Player.Master[1] == Null;
		Event Player.State != Custom String("Shoot");
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Primary Fire));
		Stop Holding Button(Event Player, Button(Secondary Fire));
	}
}

rule("Add. move forward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.Role == Custom String("Add");
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) > 15;
		Absolute Value(Horizontal Angle Towards(Event Player, Event Player.Target)) < 45;
	}

	actions
	{
		Start Forcing Throttle(Event Player, 1, 1, 0, 0, Hero Of(Event Player) == Hero(Wrecking Ball) ? 0 : Random Real(0, 1), 1);
		disabled Log To Inspector(Custom String("start moving forward"));
		Wait(4, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Wisp stop moving forward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) > 15;
		Absolute Value(Horizontal Angle Towards(Event Player, Event Player.Target)) > 50;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		disabled Log To Inspector(Custom String("wisp stop throttle"));
	}
}

disabled rule("EXPLODER")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Add. Setup")
{
	event
	{
		Subroutine;
		AddSetup;
	}

	actions
	{
		If(Hero Of(Event Player) == Hero(Wrecking Ball));
			"160 dps at level 17 (expected BossLevel for phase 2 on hard difficulty)"
			Event Player.FlameTornadoDamage = 160 / 0.500;
			Call Subroutine(UpdateStats);
			Event Player.BaseMoveSpeedModifier = 55;
			Event Player.ShouldUpdateMoveSpeed = True;
			Start Scaling Player(Event Player, 0.400, False);
			If(Global.Phase == 2);
				Teleport(Event Player, Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0));
			Else;
				Teleport(Event Player, Mapped Array(Mapped Array(Random Value In Array(Filtered Array(All Living Players(Team 1),
					Current Array Element.Role == Custom String("Hero"))), Current Array Element ? Position Of(Current Array Element)
					- Y Component Of(Position Of(Current Array Element)) * Up + Random Real(10, 30) * Direction From Angles(Random Integer(-179,
					179), 0) : Random Real(0, Global.ArenaRadius - 10) * Direction From Angles(Random Integer(-179, 179), 0)), Min(
					Global.ArenaRadius - 1, Magnitude Of(Current Array Element)) * Normalize(Current Array Element))[0]);
			End;
			Event Player.Name = Random Value In Array(Remove From Array(Global.BallNames, Mapped Array(All Players(Team 2),
				Current Array Element.Name)));
			If(Event Player.Name == Null);
				Event Player.Name = Random Value In Array(Global.BallNames);
			End;
			Start Forcing Dummy Bot Name(Event Player, Event Player.Name);
			Play Effect(All Players(All Teams), Reaper Wraith Form Sound, Color(White), Position Of(Event Player), 100);
			Event Player.Master[2] = True;
			Event Player.State = Custom String("Idle");
		Else If(Hero Of(Event Player) == Hero(Zenyatta));
			Chase Player Variable At Rate(Event Player, DashCooldown, 0, 1, None);
			Call Subroutine(UpdateStats);
			Start Scaling Player(Event Player, 1.150, False);
			If(Global.Phase == 2);
				Teleport(Event Player, 2.500 * Up + Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0));
			Else;
				Teleport(Event Player, 2.500 * Up + Mapped Array(Mapped Array(Random Value In Array(Filtered Array(All Living Players(Team 1),
					Current Array Element.Role == Custom String("Hero"))), Current Array Element ? Position Of(Current Array Element)
					- Y Component Of(Position Of(Current Array Element)) * Up + Random Real(10, 30) * Direction From Angles(Random Integer(-179,
					179), 0) : Random Real(0, Global.ArenaRadius - 10) * Direction From Angles(Random Integer(-179, 179), 0)), Min(
					Global.ArenaRadius - 1, Magnitude Of(Current Array Element)) * Normalize(Current Array Element))[0]);
			End;
			Set Max Ammo(Event Player, 0, 1);
			Event Player.Name = Random Value In Array(Remove From Array(Global.ZenyattaNames, Mapped Array(All Players(Team 2),
				Current Array Element.Name)));
			If(Event Player.Name == Null);
				Event Player.Name = Random Value In Array(Global.ZenyattaNames);
			End;
			Start Forcing Dummy Bot Name(Event Player, Event Player.Name);
			Play Effect(All Players(All Teams), Pharah Barrage Explosion Sound, Color(White), Position Of(Event Player), 100);
			Event Player.Master[2] = True;
			Event Player.State = Custom String("Idle");
		Else If(Hero Of(Event Player) == Hero(Tracer));
			Call Subroutine(UpdateStats);
			Set Jump Enabled(Event Player, False);
			Start Scaling Player(Event Player, 1.150, False);
			Teleport(Event Player, Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0) + Random Real(10, 13) * Up);
			If(Global.TestMode);
				Create HUD Text(Global.Phase == 2 ? All Players(All Teams) : Null, Slot Of(Event Player), Null, Absolute Value(
					Horizontal Angle Towards(Event Player, Event Player.Target)), Left, 0, Color(White), Color(White), Color(White),
					Visible To and String, Default Visibility);
			End;
			Event Player.Name = Random Value In Array(Remove From Array(Global.TracerNames, Mapped Array(All Players(Team 2),
				Current Array Element.Name)));
			If(Event Player.Name == Null);
				Event Player.Name = Random Value In Array(Global.TracerNames);
			End;
			Start Forcing Dummy Bot Name(Event Player, Event Player.Name);
			Event Player.State = Custom String("Rise");
		End;
	}
}

rule("Exploder exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Target != Null;
		Event Player.State == Custom String("Shoot");
		Ammo(Event Player, 0) == 0;
		Is In View Angle(Event Player, Eye Position(Event Player.Target), 40) == False;
	}

	actions
	{
		Wait(0.150, Abort When False);
		Event Player.State = Custom String("Idle");
	}
}

rule("Exploder go into ball form")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Idle");
		Is In Alternate Form(Event Player) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Ability 1));
		Wait Until(Is In Alternate Form(Event Player), 3);
		Stop Holding Button(Event Player, Button(Ability 1));
		Wait(0.500, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Exploder jump")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Target != Null;
		Is On Ground(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
		Magnitude Of(Throttle Of(Event Player)) > 0.200;
	}

	actions
	{
		Press Button(Event Player, Button(Jump));
	}
}

rule("Exploder stop moving forward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 4.500;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		disabled Log To Inspector(Custom String("exploder stop throttle"));
	}
}

disabled rule("GOLEM")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Golem stop moving forward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 11;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		disabled Log To Inspector(Custom String("golem stop throttle"));
	}
}

rule("Golem slow")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Shoot");
		Event Player.BaseMoveSpeedModifier = 60;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Golem normal speed")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.State != Custom String("Dashing");
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 100;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Golem dash cooldown")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.State != Custom String("Dashing");
	}

	actions
	{
		Event Player.DashCooldown = 2;
	}
}

rule("Golem fast")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.State == Custom String("Dashing");
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 260;
		Event Player.ShouldUpdateMoveSpeed = True;
		Start Throttle In Direction(Event Player, Mapped Array(Throttle Of(Event Player), Magnitude Of(Current Array Element)
			== 0 ? Forward : Current Array Element), 1, To Player, Replace existing throttle, None);
		Wait(1.200, Abort When False);
		Event Player.State = Custom String("Idle");
	}
}

rule("Golem dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Is Firing Secondary(Event Player) == False;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
		Event Player.State != Custom String("Dashing");
		Event Player.DashCooldown == 0;
	}

	actions
	{
		Event Player.State = Custom String("Dashing");
	}
}

rule("On enter state: shoot (Golem)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Start Holding Button(Event Player, Button(Secondary Fire));
		Loop;
	}
}

disabled rule("WISP")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Wisp gravity on")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) > 50;
	}

	actions
	{
		Set Gravity(Event Player, 100);
	}
}

rule("Wisp gravity off")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < 25;
	}

	actions
	{
		Set Gravity(Event Player, 0);
	}
}

rule("Wisp on enter state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
	}

	actions
	{
		Wait(2, Abort When False);
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Wisp exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Target != Null;
		Event Player.State == Custom String("Shoot");
		Is In View Angle(Event Player, Eye Position(Event Player.Target), 35) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Event Player.State = Custom String("Idle");
	}
}

rule("Wisp is shooting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		If(Magnitude Of(Event Player.WispAcceleration));
			Event Player.WispAcceleration = 4 * Normalize(Event Player.WispAcceleration);
		End;
		Event Player.BaseMoveSpeedModifier = 40;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Wisp is not shooting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Is Firing Primary(Event Player) == False;
	}

	actions
	{
		If(Magnitude Of(Event Player.WispAcceleration));
			Event Player.WispAcceleration = 10 * Normalize(Event Player.WispAcceleration);
		End;
		"Was 115, but nerfed slightly to make them grouping up take longer"
		Event Player.BaseMoveSpeedModifier = 100;
		Event Player.ShouldUpdateMoveSpeed = True;
	}
}

rule("Wisp descent")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Jump)) == False;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Stunned) == False;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Event Player.WispAcceleration = Down * (Is Firing Primary(Event Player) ? 4 : 10);
	}
}

rule("Wisp ascent")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Crouch)) == False;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Stunned) == False;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Event Player.WispAcceleration = Up * (Is Firing Primary(Event Player) ? 4 : 10);
	}
}

rule("Wisp enter state: ult")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Array Contains(Array(Custom String("Idle"), Custom String("Shoot")), Event Player.State) == True;
		Event Player.Target != Null;
		Distance Between(Event Player, Event Player.Target) < 15;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Event Player.State = Custom String("Ult");
	}
}

rule("Wisp on enter state: ult")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Ult");
	}

	actions
	{
		Start Holding Button(Event Player, Button(Ultimate));
		Wait Until(Ultimate Charge Percent(Event Player) < 50, 5);
		Stop Holding Button(Event Player, Button(Ultimate));
		Wait Until(!Is Using Ultimate(Event Player), 5);
		Event Player.State = Custom String("Idle");
	}
}

rule("Wisp move backward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 6;
	}

	actions
	{
		Start Forcing Throttle(Event Player, 0, 0, 1, 1, Random Real(0, 1), 1);
		disabled Log To Inspector(Custom String("wisp move back"));
	}
}

rule("Wisp stop moving forward/backward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		"Min: 10.5 - 2.5 = 8, Max: 10.5 + 2.5 = 13"
		Absolute Value(Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(
			Current Array Element), 0, Z Component Of(Current Array Element)))) - 10.500) < 2.500;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		disabled Log To Inspector(Custom String("wisp stop throttle"));
	}
}

rule("Wisp stop accelerating")
{
	event
	{
		Ongoing - Each Player;
		All;
		Tracer;
	}

	conditions
	{
		(Has Status(Event Player, Stunned) || !(Is Button Held(Event Player, Button(Crouch)) || Is Button Held(Event Player, Button(
			Jump)))) == True;
	}

	actions
	{
		Event Player.WispAcceleration = Vector(0, 0, 0);
	}
}

rule("On enter Phase 2 (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 2;
		(Event Player.Target && Is Alive(Event Player.Target) && !Is Button Held(Event Player, Button(Interact))) == False;
	}

	actions
	{
		Wait(1.800, Abort When False);
		Event Player.Target.Master[1] = Null;
		Event Player.Target = Null;
		While(Event Player.Target == Null && Global.Phase == 2);
			Random Value In Array(Filtered Array(All Living Players(Team 2), Current Array Element.Role == Custom String("Add")
				&& Current Array Element.Master[1] == Null && Current Array Element.Master[2])).Master[1] = Event Player;
			Event Player.Target = Filtered Array(All Players(Team 2), Current Array Element.Master[1] == Event Player)[0];
			Wait(0.200, Ignore Condition);
		End;
		If(Event Player.Target == Null);
			Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Else;
			Stop Forcing Throttle(Event Player);
			Stop Forcing Throttle(Event Player.Target);
			If(!Is Button Held(Event Player, Button(Primary Fire)));
				Stop Holding Button(Event Player.Target, Button(Primary Fire));
			End;
			If(!Is Button Held(Event Player, Button(Secondary Fire)));
				Stop Holding Button(Event Player.Target, Button(Secondary Fire));
			End;
			If(!Is Button Held(Event Player, Button(Ability 1)));
				Stop Holding Button(Event Player.Target, Button(Ability 1));
			End;
			If(!Is Button Held(Event Player, Button(Ultimate)));
				Stop Holding Button(Event Player.Target, Button(Ultimate));
			End;
			If(!Is Button Held(Event Player, Button(Jump)) && Hero Of(Event Player.Target) != Hero(Wrecking Ball));
				Stop Holding Button(Event Player.Target, Button(Jump));
			End;
			If(!Is Button Held(Event Player, Button(Crouch)));
				Stop Holding Button(Event Player.Target, Button(Crouch));
			End;
			If(!Is Button Held(Event Player, Button(Reload)));
				Stop Holding Button(Event Player.Target, Button(Reload));
			End;
		End;
	}
}

rule("Add Start Facing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[1] != Null;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Start Facing(Event Player, Facing Direction Of(Event Player.Master[1]), 1000, To World, Direction and Turn Rate);
	}
}

rule("Add Start Throttle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[1] != Null;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
		Event Player.State != Custom String("Dashing");
	}

	actions
	{
		Start Throttle In Direction(Event Player, Throttle Of(Event Player.Master[1]), Magnitude Of(Throttle Of(Event Player.Master[1])),
			To Player, Replace existing throttle, Direction and Magnitude);
	}
}

rule("Stop Throttle in direction")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
		Event Player.State != Custom String("Dashing");
	}

	actions
	{
		Stop Throttle In Direction(Event Player);
	}
}

rule("Add Stop Facing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		(Event Player.Master[1] == Null || Has Status(Event Player, Stunned)) == True;
	}

	actions
	{
		Stop Facing(Event Player);
	}
}

rule("Add Start Holding Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Primary Fire));
	}
}

rule("Add Stop Holding Primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Primary Fire));
	}
}

rule("Add Start Holding Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Secondary Fire));
	}
}

rule("Add Stop Holding Secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Secondary Fire));
	}
}

rule("Add Start Holding Ability 1")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Ability 1));
	}
}

rule("Add Stop Holding Ability 1")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Ability 1));
	}
}

rule("Add Start Holding Ultimate button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Ultimate));
	}
}

rule("Add Stop Holding Ultimate button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Ultimate)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Ultimate));
	}
}

rule("Add Start Holding Jump button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Hero Of(Event Player.Target) != Hero(Wrecking Ball);
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Jump));
	}
}

rule("Add Stop Holding Jump button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Hero Of(Event Player.Target) != Hero(Wrecking Ball);
		Is Button Held(Event Player, Button(Jump)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Jump));
	}
}

rule("Add Start Holding Crouch button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Crouch));
	}
}

rule("Add Stop Holding Crouch button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Crouch)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Crouch));
	}
}

rule("Add Start Holding Reload button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Start Holding Button(Event Player.Target, Button(Reload));
	}
}

rule("Add Stop Holding Reload button")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.Target != Null;
		Is Button Held(Event Player, Button(Reload)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Target, Button(Reload));
	}
}

rule("Boss spectate")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 2;
		Event Player.Target != Null;
	}

	actions
	{
		disabled Start Camera(Event Player, Eye Position(Event Player.Target) + World Vector Of(Right, Event Player.Target, Rotation), Eye Position(
			Event Player.Target) + World Vector Of(Right, Event Player.Target, Rotation) + 5 * Facing Direction Of(Event Player.Target),
			60);
		Start Camera(Event Player, Eye Position(Event Player.Target) - Facing Direction Of(Event Player.Target), Eye Position(
			Event Player.Target) + 5 * Facing Direction Of(Event Player.Target), 25);
	}
}

rule("Stop Phase 2 camera")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Global.Phase == 2 && Event Player.Target) == False;
	}

	actions
	{
		Stop Camera(Event Player);
	}
}

disabled rule("PHASE 3")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Phase 3 Start (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 3;
	}

	actions
	{
		Stop All Heal Over Time(Event Player);
		Event Player.Target = Null;
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Stop Chasing Player Variable(Event Player, TakeoffCooldown);
		Event Player.CanNeedle = Array(False, False);
		Call Subroutine(CleanseAllDebuffs);
		Call Subroutine(UpdateStats);
		Wait(3, Abort When False);
		Event Player.ShowBossBar = True;
		Event Player.State = Custom String("Landing");
	}
}

rule("On Phase 3 Start (Team 1)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.Phase == 3;
	}

	actions
	{
		Abort If(Event Player.Role != Custom String("Hero"));
		Start Rule(PrepareSounds, Do Nothing);
		Wait(0.200, Abort When False);
		Start Rule(SoundCue, Restart Rule);
	}
}

rule("On Enter Phase: 3 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 3;
	}

	actions
	{
		Wait(4, Abort When False);
		Global.Director[0] = 300;
		Call Subroutine(SetCoefficient);
		While(True);
			Call Subroutine(TrySpawn);
			Wait(Global.Director[1], Abort When False);
			Global.Director[0] += Global.Director[1] * (1 + 0.400 * Global.DifficultyCoefficient) * (Global.PlayerCount + 1) / 2;
		End;
	}
}

rule("Try Spawn")
{
	event
	{
		Subroutine;
		TrySpawn;
	}

	actions
	{
		If(!Is True For Any(Global.AvailableBotSlots, X Component Of(Current Array Element) == 2));
			Global.Director[5] = False;
		Else;
			If(!Global.Director[5]);
				If(Random Real(0, 1) < 0.200);
					Global.Director[2] = 0;
				Else If(Random Real(0, 1) < 0.750);
					Global.Director[2] = 1;
				Else;
					Global.Director[2] = 2;
				End;
				Global.Director[3] = Array(80, 350, 550)[Global.Director[2]];
				Global.Director[7] = 0;
			End;
			If(Global.Director[0] < Global.Director[3] || (Global.Director[0] >= 36 * Global.Director[3] && Global.Director[2] < 2)
				|| Global.Director[7] > 5);
				Global.Director[5] = False;
			Else;
				Global.Director[5] = True;
				Global.Director[0] -= Global.Director[3];
				Global.Director[6] = Global.BossCount;
				While(Global.Director[6] > 0);
					Modify Global Variable(BotCreationQueue, Append To Array, Array(Array(Hero(Wrecking Ball), Hero(Zenyatta), Hero(Tracer))
						[Global.Director[2]], Team 2));
					Global.Director[6] -= 1;
				End;
				Global.Director[7] += 1;
			End;
		End;
		If(Global.Director[5]);
			Global.Director[1] = Random Real(0.100, 1);
		Else;
			Global.Director[1] = Random Real(4.500, 9);
			Call Subroutine(SetCoefficient);
		End;
	}
}

rule("Pizza Time")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.PizzaIndex == Custom String("Soon");
		Event Player.PizzaTime[0] != Null;
		Total Time Elapsed > Event Player.PizzaTime[0];
	}

	actions
	{
		If(Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) && Ultimate Charge Percent(
			Event Player) > 95 && !Has Status(Event Player, Stunned));
			Event Player.State = Custom String("Pizza");
		Else;
			Event Player.PizzaIndex = Custom String("ASAP");
		End;
		Event Player.PizzaTime[0] = Null;
	}
}

rule("On Enter State: Pizza")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage"), Custom String("PizzaWait")), Event Player.State)
			== True;
		Event Player.HasLostThisPhase == False;
	}

	actions
	{
		Event Player.CanSwing = False;
		Event Player.CanSlam = False;
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Start Holding Button(Event Player, Button(Crouch));
		For Player Variable(Event Player, PizzaIndex, 0, 5, 1);
			Abort If Condition Is False;
			Event Player.State = Custom String("Pizza");
			Chase Player Variable At Rate(Event Player, PizzaAngle, Event Player.PizzaAngle + 10 * Event Player.PizzaAngularVelocity,
				Absolute Value(Event Player.PizzaAngularVelocity), Destination and Rate);
			Event Player.PizzaAngularVelocity = Random Value In Array(Array(1, -1)) * 50;
			Event Player.PizzaAngle = Random Integer(0, 180);
			Event Player.PizzaTime[1] = Total Time Elapsed + 0.700;
			Wait(0.700, Abort When False);
			Stop Chasing Player Variable(Event Player, PizzaAngle);
			"doesn't dynamically update with NumDeathLines"
			Event Player.Victims = Remove From Array(Filtered Array(All Living Players(Team 1), Absolute Value(Cosine From Degrees(
				Event Player.PizzaAngle) * X Component Of(Vector Towards(Current Array Element, Event Player)) - Sine From Degrees(
				Event Player.PizzaAngle) * Z Component Of(Vector Towards(Current Array Element, Event Player)))
				< Global.DeathLineRadius || Absolute Value(Cosine From Degrees(Event Player.PizzaAngle + 45) * X Component Of(Vector Towards(
				Current Array Element, Event Player)) - Sine From Degrees(Event Player.PizzaAngle + 45) * Z Component Of(Vector Towards(
				Current Array Element, Event Player))) < Global.DeathLineRadius || Absolute Value(Cosine From Degrees(
				Event Player.PizzaAngle + 90) * X Component Of(Vector Towards(Current Array Element, Event Player)) - Sine From Degrees(
				Event Player.PizzaAngle + 90) * Z Component Of(Vector Towards(Current Array Element, Event Player)))
				< Global.DeathLineRadius || Absolute Value(Cosine From Degrees(Event Player.PizzaAngle + 135) * X Component Of(Vector Towards(
				Current Array Element, Event Player)) - Sine From Degrees(Event Player.PizzaAngle + 135) * Z Component Of(Vector Towards(
				Current Array Element, Event Player))) < Global.DeathLineRadius), Global.NullPlayer);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Eye Position(Event Player), 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Eye Position(Event Player), 100);
			Damage(Event Player.Victims, Event Player, 382.500);
			Apply Impulse(Event Player.Victims, Up, 8, To World, Incorporate Contrary Motion);
			Event Player.State = Custom String("PizzaDamage");
			Small Message(Event Player, (Total Time Elapsed - Event Player.PizzaTime[1]) * 20);
			Wait(0.100, Ignore Condition);
			Modify Player Variable(Filtered Array(Event Player.Victims, Current Array Element.DebuffShield[0] <= 0), CrippleTime, Max, 3);
			Filtered Array(Event Player.Victims, Current Array Element.DebuffShield[0] > 0).DebuffShield[3] += 1;
			Filtered Array(Event Player.Victims, Current Array Element.DebuffShield[0] > 0).DebuffShield[0] -= 1;
			Wait(0.100, Abort When False);
			Event Player.State = Custom String("PizzaWait");
			Small Message(Event Player, (Total Time Elapsed - Event Player.PizzaTime[1]) * 20);
			Wait(1.200, Abort When False);
		End;
		Event Player.PizzaIndex = Custom String("Dormant");
		Stop Holding Button(Event Player, Button(Crouch));
		Chase Player Variable At Rate(Event Player, TakeoffCooldown, 0, 1, None);
		Call Subroutine(ChooseState);
	}
}

rule("Destroy Flame Pillar")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.FlamePillars) > 0;
		Total Time Elapsed > Global.FlamePillarExpirationTimes[0];
	}

	actions
	{
		Destroy Effect(Global.FlamePillars[0]);
		Modify Global Variable(FlamePillarPositions, Remove From Array By Index, 0);
		Modify Global Variable(FlamePillarExpirationTimes, Remove From Array By Index, 0);
		Modify Global Variable(FlamePillars, Remove From Array By Index, 0);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Flame Pillar Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is True For Any(Global.FlamePillarPositions, Distance Between(Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(
			Position Of(Event Player))), Vector(X Component Of(Current Array Element), 0, Z Component Of(Current Array Element))) < 1)
			== True;
	}

	actions
	{
		Set Status(Event Player, Global.NullPlayer[1], Burning, 0.250);
		Damage(Event Player, Global.NullPlayer[1], 42.500 * Global.Bosses[0].BaseDamageMultiplier);
		Wait(0.200, Abort When False);
		Loop If Condition Is True;
	}
}

disabled rule("PHASE 4")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter Phase: 4 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 4;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		Kill(Filtered Array(All Players(Team 2), Current Array Element.Role == Custom String("Add")), Global.NullPlayer[0]);
		disabled Wait(5, Ignore Condition);
		disabled Global.FlamePillarExpirationTimes = Mapped Array(Global.FlamePillarExpirationTimes, Total Time Elapsed);
	}
}

rule("On Enter Phase: 4 (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 4;
	}

	actions
	{
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 55;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.CanNeedle = Array(True, False);
		Clear Status(Event Player, Unkillable);
		Teleport(Event Player, Vector(0, 0, 0));
		"Add Armour Boost"
		Event Player.ArmourModifiers[1] = 200;
		Start Rule(UpdateArmour, Restart Rule);
		Call Subroutine(CleanseAllDebuffs);
		Call Subroutine(UpdateStats);
		Set Invisible(Event Player, None);
		Event Player.PizzaIndex = Custom String("Dormant");
		Wait(5.750, Abort When False);
		Start Holding Button(Event Player, Button(Crouch));
		Wait(0.250, Abort When False);
		Disallow Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Crouch));
		Event Player.CanUseOrbs = False;
		Event Player.ShowBossBar = True;
		Event Player.State = Custom String("Stealing");
	}
}

rule("On Enter State: Stealing (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 4;
		Is True For All(Global.Bosses, Current Array Element.State == Custom String("Stealing")) == True;
	}

	actions
	{
		Global.Stealees = Filtered Array(Global.Heroes, !Current Array Element.IsDead);
		While(Count Of(Global.Stealees) > 0);
			Global.Stealer = Global.Bosses[Global.BossIndex];
			Global.CurrentStealee = Global.Stealees[Global.StealeeIndex];
			Wait Until(Count Of(Global.ItemStackUpdateInfos) == 0, 3);
			If(Count Of(Global.CurrentStealee.MyItemStacks) == 0);
				Modify Global Variable(Stealees, Remove From Array By Index, Global.StealeeIndex);
			Else;
				Global.ItemStackBeingStolenIndex = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
					Global.ItemStacks[Current Array Element] == Global.CurrentStealee.MyItemStacks[0] && Global.ItemStackOwners[Current Array Element] == Global.CurrentStealee);
				If(Count Of(Global.ItemStackBeingStolenIndex) == 0);
					Small Message(Host Player, Custom String("Item Steal Error"));
					Modify Global Variable(Stealees, Remove From Array By Index, Global.StealeeIndex);
				Else;
					Global.ItemStackBeingStolenIndex = Global.ItemStackBeingStolenIndex[0];
					Call Subroutine(Steal);
					Global.StealeeIndex += 1;
				End;
				Global.BossIndex = (Global.BossIndex + 1) % Count Of(Global.Bosses);
			End;
			Global.StealeeIndex %= Count Of(Global.Stealees);
			Wait(0.250, Abort When False);
		End;
		Wait Until(Is True For All(Global.ItemStackNewOwners, Current Array Element == Null), 99999);
		Global.Bosses.State = Custom String("StealingFinished");
	}
}

rule("On Enter State: Stealing Finished")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StealingFinished");
	}

	actions
	{
		Event Player.HealthPerItemStack = Max Health(Event Player) / (Count Of(Event Player.ItemStackReturnInfo) / 2);
		Clear Status(Event Player, Phased Out);
		Allow Button(Event Player, Button(Crouch));
		Start Holding Button(Event Player, Button(Crouch));
		Wait(4, Abort When False);
		Disallow Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1, Abort When False);
		Allow Button(Event Player, Button(Crouch));
		"Remove Armour Boost (as late as possible)"
		Event Player.ArmourModifiers[1] = 0;
		Start Rule(UpdateArmour, Restart Rule);
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("Enter State: Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 4;
		Event Player.CanUseOrbs == True;
		Event Player.State == Custom String("Idle");
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Orbs");
	}
}

rule("On Enter State: Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Orbs");
	}

	actions
	{
		Start Facing(Event Player, Vector(0, -1, 1), 120, To Player, None);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Start Holding Button(Event Player, Button(Crouch));
		Wait(1.500, Abort When False);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 100);
		Damage(Event Player, Global.NullPlayer[0], 0.080 * Health(Event Player));
		"May want to do more to ensure two bosses simultaneously creating orbs doesn't break this"
		For Player Variable(Event Player, OrbCreationIndex, 0, 8, 1);
			Modify Global Variable(OrbCreators, Append To Array, Event Player);
			Wait(0.016, Ignore Condition);
			Event Player.NewOrbGlobalIndex = Last Of(Remove From Array(Mapped Array(Global.OrbCreators,
				Current Array Element == Event Player ? Current Array Index : -1), -1));
			Global.OrbInitialAngles[Event Player.NewOrbGlobalIndex] = Horizontal Facing Angle Of(Event Player) + (
				0.500 - Event Player.OrbCreationIndex) * 45;
			Global.OrbCreationTimes[Event Player.NewOrbGlobalIndex] = Total Time Elapsed;
			Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex] = Mapped Array(Position Of(Event Player),
				Current Array Element - Y Component Of(Current Array Element) * Up)[0];
			Global.OrbPositions[Event Player.NewOrbGlobalIndex] = Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex];
			Create Effect(All Players(All Teams), Sphere, Color(Sky Blue), Global.OrbPositions[Evaluate Once(Event Player.NewOrbGlobalIndex)],
				1, Visible To Position and Radius);
			Global.OrbEffects[Event Player.NewOrbGlobalIndex] = Last Created Entity;
			Create Effect(All Players(All Teams), Orisa Amplifier Sound, Color(White), Global.OrbPositions[Evaluate Once(
				Event Player.NewOrbGlobalIndex)], 100, Visible To Position and Radius);
			Global.OrbSounds[Event Player.NewOrbGlobalIndex] = Last Created Entity;
		End;
		Stop Facing(Event Player);
		Wait(4, Abort When False);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1, Abort When False);
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("Orb Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For Any(Global.OrbPositions, Current Array Element != Null) == True;
	}

	actions
	{
		For Global Variable(OrbEvaluationIndex, 0, Count Of(Global.OrbPositions), 1);
			Wait(0.016, Ignore Condition);
			Call Subroutine(HandleOrb);
			Global.OrbPositions = Mapped Array(Mapped Array(Global.OrbCreationTimes, Total Time Elapsed - Current Array Element),
				Global.OrbPositions[Current Array Index] ? Global.OrbInitialPositions[Current Array Index] + 50 * Square Root(3.250 / (
				1 + Absolute Value(1.500 * Sine From Radians(0.524 * Current Array Element)) ^ 2)) * Sine From Radians(
				0.524 * Current Array Element) * Direction From Angles(
				Global.OrbInitialAngles[Current Array Index] - 22.500 * Current Array Element, 0) : Null);
		End;
		Loop If Condition Is True;
	}
}

rule("Destroy Orb")
{
	event
	{
		Subroutine;
		DestroyOrb;
	}

	actions
	{
		"Don't set effect to null, to ensure this is definitely destroyed."
		Destroy Effect(Global.OrbEffects[Global.OrbEvaluationIndex]);
		Destroy Effect(Global.OrbSounds[Global.OrbEvaluationIndex]);
		Global.OrbPositions[Global.OrbEvaluationIndex] = Null;
	}
}

rule("Enable Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Normalized Health(Event Player) < 0.900;
	}

	actions
	{
		If(Global.Phase == 4);
			Event Player.CanUseOrbs = True;
		End;
	}
}

rule("Return Items")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.HealthPerItemStack > 0;
		Count Of(Event Player.ItemStackReturnInfo) > 0;
		(Is Dead(Event Player) || Event Player.Phase4DamageReceived >= (Event Player.NumberOfStacksReturned + 1)
			* Event Player.HealthPerItemStack) == True;
	}

	actions
	{
		Play Effect(Event Player, Moira Fade Disappear Sound, Color(White), Event Player, 100);
		Play Effect(Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex], Moira Fade Reappear Sound, Color(White),
			Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex], 100);
		While(True);
			Abort If Condition Is False;
			Event Player.StackBeingReturnedIndex = Event Player.ItemStackReturnInfo[0];
			Event Player.RemainingMatchingStacks = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
				Global.ItemStacks[Current Array Element] == Global.ItemStacks[Event Player.StackBeingReturnedIndex] && Global.ItemStackOwners[Current Array Element] == Event Player);
			Global.ItemStackOwners[Event Player.StackBeingReturnedIndex] = Null;
			If(Count Of(Event Player.RemainingMatchingStacks) == 1);
				Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingReturnedIndex, 2,
					-1 * Global.ItemStackSizes[Event Player.StackBeingReturnedIndex], Event Player, False));
			Else;
				Event Player.StackBeingDepletedIndex = Filtered Array(Event Player.RemainingMatchingStacks,
					Global.ItemStackSizes[Current Array Element] > 0)[0];
				If(Event Player.StackBeingReturnedIndex == Event Player.StackBeingDepletedIndex);
					Global.ItemStackSizes[Remove From Array(Event Player.RemainingMatchingStacks, Event Player.StackBeingDepletedIndex)
						[0]] += Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] - Event Player.ItemStackReturnInfo[1];
					Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] = Event Player.ItemStackReturnInfo[1];
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingReturnedIndex, 2,
						-1 * Event Player.ItemStackReturnInfo[1], Event Player, False));
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Remove From Array(Event Player.RemainingMatchingStacks,
						Event Player.StackBeingDepletedIndex)[0], 1, Global.ItemStackSizes[Remove From Array(Event Player.RemainingMatchingStacks,
						Event Player.StackBeingDepletedIndex)[0]], Event Player, False));
				Else;
					Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] -= Event Player.ItemStackReturnInfo[1];
					Global.ItemStackSizes[Event Player.StackBeingReturnedIndex] += Event Player.ItemStackReturnInfo[1];
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingDepletedIndex, 0,
						-1 * Event Player.ItemStackReturnInfo[1], Event Player, False));
				End;
			End;
			Global.ItemStackNewOwners[Event Player.StackBeingReturnedIndex] = Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex];
			Event Player.NumberOfStacksReturned += 1;
			Modify Player Variable(Event Player, ItemStackReturnInfo, Remove From Array By Index, 0);
			Modify Player Variable(Event Player, ItemStackReturnInfo, Remove From Array By Index, 0);
			Wait(0.100, Abort When False);
		End;
	}
}

rule("Handle Orb")
{
	event
	{
		Subroutine;
		HandleOrb;
	}

	actions
	{
		Abort If(Global.OrbPositions[Global.OrbEvaluationIndex] == Null);
		Global.OrbVictims = Remove From Array(Filtered Array(All Living Players(Team 1), Distance Between(Current Array Element,
			Global.OrbPositions[Global.OrbEvaluationIndex]) < 1), Global.NullPlayer);
		If(Count Of(Global.OrbVictims) > 0);
			Damage(Global.OrbVictims, Global.OrbCreators[Global.OrbEvaluationIndex], 170);
			"Don't set effect to null, to ensure this is definitely destroyed."
			Call Subroutine(DestroyOrb);
		Else If(Total Time Elapsed > Global.OrbCreationTimes[Global.OrbEvaluationIndex] + 9);
			"Don't set effect to null, to ensure this is definitely destroyed."
			Call Subroutine(DestroyOrb);
		End;
	}
}

disabled rule("PHASE X")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Player Died")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.IsDead == False;
	}

	actions
	{
		Event Player.BarrierHealth = 0;
		Event Player.BoomTime[0] = 0;
		Call Subroutine(CleanseAllDebuffs);
		Event Player.WispAcceleration = Vector(0, 0, 0);
		If(Event Player.Role == Custom String("Add"));
			Call Subroutine(LoseTarget);
		Else If(Event Player.Role == Custom String("Hero") && Global.Dialogue[0]);
			If(Global.Phase == 1 || Global.Phase == 3);
				Modify Global Variable(Dialogue, Append To Array, Array(Attacker.Master[0].Role == Custom String("Boss") ? Attacker.Master[0] : Null, Custom String("EarlyHeroDeath")));
			Else If(Global.Phase == 4);
				Modify Global Variable(Dialogue, Append To Array, Array(Attacker.Master[0].Role == Custom String("Boss") ? Attacker.Master[0] : Null, Custom String("LateHeroDeath")));
			End;
		End;
		If(Array Contains(Event Player.MyItemStacks, Custom String("Extra Life")));
			If(Team Of(Event Player) != Team 2);
				Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Filtered Array(Mapped Array(Global.ItemStackSizes,
					Current Array Index),
					Global.ItemStackSizes[Current Array Element] > 0 && Global.ItemStacks[Current Array Element] == Custom String("Extra Life")
					&& Global.ItemStackOwners[Current Array Element] == Event Player)[0], 0, -1, Event Player, True));
			End;
			Wait(2, Ignore Condition);
			Resurrect(Event Player);
			Set Status(Event Player, Null, Invincible, 3);
			Wait(0.100, Ignore Condition);
			Set Player Health(Event Player, Max Health(Event Player));
		Else;
			Event Player.IsDead = True;
			If(Event Player.Role == Custom String("Add"));
				If(Hero Of(Event Player) == Hero(Wrecking Ball));
					Event Player.FlameTornadoPosition = Position Of(Event Player);
					Event Player.FlameTornadoExpirationTime = Total Time Elapsed + 7;
					Create Effect(All Players(All Teams), Ring, Color(Sky Blue), Event Player.FlameTornadoPosition, 5, Visible To);
					Event Player.FlameTornado = Last Created Entity;
				End;
				Wait(9, Ignore Condition);
				Call Subroutine(DestroyMe);
			End;
		End;
	}
}

rule("Player Is Alive")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Event Player.IsDead == True;
	}

	actions
	{
		Event Player.IsDead = False;
	}
}

rule("Boss Died")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.IsDead == True;
	}

	actions
	{
		Event Player.ShowBossBar = False;
		Event Player.HasLostThisPhase = True;
		Play Effect(All Players(All Teams), Sombra EMP Explosion Sound, Color(White), Event Player, 100);
		If(Global.Dialogue[0]);
			Modify Global Variable(Dialogue, Append To Array, Array(Event Player, Custom String("BossDeath")));
		End;
	}
}

rule("Ramattra Bot Boss Gone")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ramattra;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		(!Array Contains(Filtered Array(All Players(Team 2), !Current Array Element.IsDead), Event Player.Master[0]) || Is Match Complete)
			== True;
	}

	actions
	{
		Call Subroutine(DestroyMe);
	}
}

rule("Hide Null Players from victory screen")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Match Complete == True;
		Array Contains(Global.NullPlayer, Event Player) == True;
	}

	actions
	{
		Call Subroutine(DestroyMe);
	}
}

rule("All Bosses Gone")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Is True For All(Global.Bosses, Current Array Element.IsDead) == True;
	}

	actions
	{
		Global.State = Custom String("PlayerVictory");
		Global.Phase = Custom String("X");
		If(Current Game Mode == Game Mode(Skirmish));
			Wait(3, Ignore Condition);
			Declare Team Victory(Team 1);
		End;
	}
}

rule("All Heroes Gone")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Is True For All(Global.Heroes, Current Array Element.IsDead) == True;
	}

	actions
	{
		If(Current Game Mode == Game Mode(Skirmish));
			Wait(3, Ignore Condition);
			Declare Team Victory(Team 2);
		End;
	}
}

rule("Hero Left")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	actions
	{
		Global.Heroes = Filtered Array(Global.Heroes, Array Contains(All Players(All Teams), Current Array Element));
	}
}

rule("Boss Left")
{
	event
	{
		Player Left Match;
		Team 2;
		All;
	}

	actions
	{
		Global.Bosses = Filtered Array(Global.Bosses, Array Contains(All Players(All Teams), Current Array Element));
	}
}