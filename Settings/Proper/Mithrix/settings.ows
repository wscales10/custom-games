settings
{
	lobby
	{
		Max Team 1 Players: 2
		Max Team 2 Players: 1
	}

	modes
	{
		Elimination
		{
			Hero Selection: Limited
			Score To Win: 5

			enabled maps
			{
			}
		}

		Skirmish
		{
			enabled maps
			{
				Workshop Expanse 0
			}
		}

		General
		{
			Hero Limit: Off
		}
	}

	heroes
	{
		Team 2
		{
			Reinhardt
			{
				Barrier Field: Off
				Charge: Off
				Fire Strike: Off
				Ultimate Generation - Combat Earthshatter: 0%
				Ultimate Generation - Passive Earthshatter: 0%
			}

			Tracer
			{
				Blink: Off
				No Ammunition Requirement: On
				Projectile Gravity: 0%
				Projectile Speed: 70%
				Quick Melee: Off
				Recall: Off
				Ultimate Generation - Passive Pulse Bomb: 200%
				Ultimate Generation Pulse Bomb: 500%
			}

			Wrecking Ball
			{
				Adaptive Shield: Off
				Grappling Claw: Off
				Piledriver: Off
				Quick Melee: Off
				Ultimate Ability Minefield: Off
			}

			Zenyatta
			{
				Orb of Discord: Off
				Orb of Harmony: Off
				Primary Fire: Off
				Projectile Speed: 28%
				Quick Melee: Off
				Ultimate Ability Transcendence: Off
			}

			enabled heroes
			{
				Reinhardt
			}
		}

		General
		{
			Health: 16%
		}
	}

	workshop
	{
		Difficulty: 2
		Test Mode: Off
	}

	extensions
	{
		Beam Effects
		Beam Sounds
		Buff and Debuff Sounds
		Energy Explosion Effects
		Explosion Sounds
		Play More Effects
	}
}

variables
{
	global:
		0: State
		1: Phase
		2: Heroes
		3: Bosses
		4: TestMode
		5: DeathLineRadius
		6: OverallBossLevel
		7: OverallPlayerLevel
		8: PlayerCount
		9: PlayerFactor
		10: DifficultyValue
		11: TimeFactor
		12: StagesCompleted
		13: DifficultyCoefficient
		14: BossCount
		15: Items
		16: ItemSymbols
		17: ItemRarities
		18: ItemColours
		19: ItemDistributionQueue
		20: ItemDistributionInfo
		21: ItemStacks
		22: ItemStackOwners
		23: ItemStackNewOwners
		24: ItemStackOriginalOwners
		25: ItemStackSizes
		26: ItemStackIndex
		27: NewItemStackIndex
		28: ItemStackHUDs
		29: ItemStackEffects
		30: ItemStackUpdateInfos
		31: ItemStackUpdateInfo
		32: ExistingMatchingItemStacks
		33: CurrentItemStackSize
		34: ItemShops
		35: ItemShopPositions
		36: ItemShopPrices
		37: ItemShopEffects1
		38: ItemShopEffects2
		39: ItemShopIndex
		40: Stealees
		41: BossIndex
		42: CurrentStealee
		43: StealeeIndex
		44: Stealer
		45: ItemStackBeingStolenIndex
		46: BossSpawnEffect
		47: FlamePillars
		48: FlamePillarPositions
		49: FlamePillarExpirationTimes
		50: OrbCreationTimes
		51: OrbEffects
		52: OrbInitialAngles
		53: OrbPositions
		54: OrbCreators
		55: OrbEvaluationIndex
		56: OrbVictims
		57: OrbInitialPositions
		58: OrbSounds
		59: BotCreationQueue
		60: AvailableBotSlots
		61: TracerNames
		62: ZenyattaNames
		63: BallNames
		64: ArenaRadius
		65: StrikeVictims
		66: LightningStrikes
		67: NullPlayer

	player:
		0: Master
		1: IsDead
		2: ItemStacks
		3: BaseDamageMultiplier
		4: Armour
		5: ShouldUpdateArmour
		6: ArmourModifiers
		7: ArmourIndex
		8: DamageReceivedNewAmount
		9: BaseMoveSpeedModifier
		10: ShouldUpdateMoveSpeed
		11: MoveSpeedBuffs
		12: MoveSpeedDebuffs
		13: MoveSpeedIndex
		14: SlowTime
		15: BleedTime
		16: BleedInfo
		17: APTime
		18: ArmourPiercingStacks
		19: BlastCooldown
		20: FlameTornado
		21: FlameTornadoPosition
		22: FlameTornadoExpirationTime
		23: FlameTornadoDamage
		24: Currency
		25: BuyIndex
		26: CameraPosition
		27: CrippleTime
		28: State
		29: ShowBossBar
		30: HasLostThisPhase
		31: DefaultHealth
		32: BaseRegen
		33: NormalExtraHealth
		34: IntendedMaxHealth
		35: TotalHPUnits
		36: Bots
		37: CanSwing
		38: CanDash
		39: CanSlam
		40: CanSprint
		41: CanNeedle
		42: CanTakeOff
		43: CanUseOrbs
		44: SwingCooldown
		45: DashCooldown
		46: SlamCooldown
		47: NeedleCooldown
		48: TakeoffCooldown
		49: ShockwaveRadius
		50: ShockwaveEffect
		51: DashStartTime
		52: DashStartPosition
		53: DashAngles
		54: DashSpeed
		55: NumPizzaLines
		56: PizzaIndex
		57: PizzaAngle
		58: PizzaAngularVelocity
		59: PizzaRadius
		60: Victims
		61: PizzaTime
		62: Phase4DamageReceived
		63: HealthPerItemStack
		64: NumberOfStacksReturned
		65: ItemStackReturnInfo
		66: StackBeingReturnedIndex
		67: StackBeingDepletedIndex
		68: RemainingMatchingStacks
		69: OrbCreationIndex
		70: NewOrbGlobalIndex
		71: CouldBeHumanPlayer
		72: Target
		73: DoubleJumps
		74: RecoveryTime
		75: Name
		76: WispAcceleration
		77: WallAcceleration
		78: EvenRarityItemsCount
		79: StealthTime
		80: BoomTime
		81: Level
		82: ShouldUpdateHealing
		83: HealingModifiers
		84: HealingIndex
		85: HealthScale
		86: BarrierInfo
}

subroutines
{
	1: Steal
	2: Acquire
	3: DistributeItem
	4: HandleItemInstance
	5: Dash
	6: UpdateMoveSpeed
	7: UpdateArmour
	8: DestroyOrb
	9: HandleOrb
	10: CreateItemStack
	11: SetCoefficient
	12: UpdateStats
	13: ChooseState
	14: UpdateItemStack_Add
	15: UpdateItemStack_Remove
	16: UpdateItemStack_Modify
	17: Settings
	18: CleanseSomeDebuffs
	19: CleanseAllDebuffs
	20: DestroyMe
	21: Buy
	22: UpdateHealing
}

rule("Global setup")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.ArenaRadius = 80;
		Global.StagesCompleted = 5;
		Global.LightningStrikes = Empty Array;
		Disable Built-In Game Mode Music;
		Global.BotCreationQueue = Empty Array;
		Global.AvailableBotSlots = Array(8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23);
		Call Subroutine(Settings);
		Global.ItemStackUpdateInfos = Empty Array;
		Global.DeathLineRadius = 0.750;
		Create Effect(All Players(All Teams), Bad Aura, Color(Black), Vector(0, 0, 0), 3.500, Visible To Position and Radius);
		Global.BossSpawnEffect = Last Created Entity;
		Global.Items = Array(Custom String("Max HP"), Custom String("Speed"), Custom String("Slow"), Custom String("Bleed"), Custom String(
			"Armour Piercing"), Custom String("Extra Life"), Custom String("Close Range Damage"), Custom String("Ice Blast"),
			Custom String("Flame Blast"), Custom String("Lifesteal"), Custom String("Stun Chance"), Custom String("Recovery"),
			Custom String("Double Jump"), Custom String("Armour Reduction"), Custom String("Egg"), Custom String("Reprieve"),
			Custom String("Lightning"), Custom String("Big Explosion"), Custom String("Rock"), Custom String("Shields"), Custom String(
			"Barrier"));
		Global.ItemSymbols = Array(Custom String("♥"), Custom String("»"), Custom String("«"), Custom String("†"), Custom String("▲"),
			Custom String("+1"), Custom String("(•)"), Custom String("*"), Custom String("*"), Custom String("Ϣ"), Custom String("@"),
			Custom String("+"), Custom String("ニ"), Custom String("Ø"), Custom String("0"), Custom String("◌"), Icon String(Bolt), Icon String(Warning), Custom String("●"), Custom String("♥"), Custom String("○"));
		Global.ItemRarities = Array(1, 1, 2, 1, 3, 3, 1, 2, 2, 2, 1, 1, 2, 3, 4, 2, 4, 4, 4, 1, 1);
		Global.ItemColours = Array(Custom Color(205, 83, 63, 255), Custom Color(189, 192, 159, 255), Custom Color(230, 225, 209, 255),
			Custom Color(171, 43, 43, 255), Custom Color(88, 100, 73, 255), Custom Color(189, 191, 206, 255), Custom Color(226, 40, 78,
			255), Custom Color(214, 229, 233, 255), Custom Color(165, 114, 106, 255), Custom Color(77, 34, 21, 255), Custom Color(62, 75,
			53, 255), Custom Color(25, 98, 10, 255), Custom Color(85, 188, 229, 255), Custom Color(230, 139, 142, 255), Custom Color(255,
			185, 148, 255), Custom Color(96, 71, 70, 200), Color(White), Color(White), Custom Color(13, 20, 59, 255), Custom Color(165,
			239, 246, 255), Custom Color(198, 193, 252, 200));
		Global.Items = Sorted Array(Global.Items, Global.ItemRarities[Current Array Index]);
		Global.ItemSymbols = Sorted Array(Global.ItemSymbols, Global.ItemRarities[Current Array Index]);
		Global.ItemColours = Sorted Array(Global.ItemColours, Global.ItemRarities[Current Array Index]);
		Global.ItemRarities = Sorted Array(Global.ItemRarities, Current Array Element);
		Global.ItemDistributionQueue = Empty Array;
		Global.ItemStackOriginalOwners = Empty Array;
		Global.FlamePillarPositions = Empty Array;
		Global.FlamePillarExpirationTimes = Empty Array;
		Global.FlamePillars = Empty Array;
		Global.OrbCreators = Empty Array;
		Create HUD Text(All Players(Team 1), Custom String("{0} {1}", Array(Icon String(Happy), Icon String(Sad), Icon String(Skull))
			[Global.DifficultyValue - 1], Array(Custom String("Easy"), Custom String("Normal"), Custom String("Hard"))
			[Global.DifficultyValue - 1]), Null, Null, Right, 0, Array(Custom Color(102, 153, 102, 255), Custom Color(204, 153, 102, 255),
			Custom Color(153, 51, 51, 255))[Global.DifficultyValue - 1], Color(White), Color(White), Visible To, Default Visibility);
		Create HUD Text(All Players(Team 1), Null, Global.Phase > 0 ? Custom String("Objective: Defeat the boss") : Custom String(" "),
			Null, Right, 0.100, Array(Custom Color(102, 153, 102, 255), Custom Color(204, 153, 102, 255), Custom Color(153, 51, 51, 255))
			[Global.DifficultyValue - 1], Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 1, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 2, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 3, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 4, Color(White), Color(White), Color(White),
			Visible To, Default Visibility);
		If(Global.TestMode);
			disabled Create HUD Text(All Players(All Teams), Global.State, Custom String("Global State"), Global.Phase, Left, 0, Color(White), Color(
				White), Color(White), Visible To and String, Default Visibility);
		End;
		Global.BallNames = Array(Custom String("Interference"), Custom String("Locomotion"), Custom String("Destruction"));
		Global.TracerNames = Array(Custom String("Soul"), Custom String("Design"), Custom String("Wonder"), Custom String("Speed"),
			Custom String("Inspiration"), Custom String("Strength"), Custom String("Curiosity"), Custom String("Spirit"), Custom String(
			"Life"), Custom String("Power"));
		Global.ZenyattaNames = Array(Custom String("Stone"), Custom String("Silver"), Custom String("Speed"), Custom String("Volatility"),
			Custom String("Stability"), Custom String("Dance"), Custom String("Song"));
		Create Effect(All Players(All Teams), Light Shaft, Color(Sky Blue), Vector(0, 0, 0), 1.060 * Global.ArenaRadius, Visible To);
		Create Effect(All Players(All Teams), Ring, Color(Gray), Vector(0, 0, 0), 57, Visible To);
		Create Beam Effect(Count Of(Global.LightningStrikes) ? All Players(All Teams) : Null, Bad Beam, Update Every Frame(
			Global.LightningStrikes[1] + 30 * Up), Update Every Frame(Global.LightningStrikes[1] + Down), Color(White),
			Visible To Position Radius and Color);
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Sigma), Team 2));
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Soldier: 76), Team 1));
		Global.State = Custom String("Buy");
	}
}

rule("Settings")
{
	event
	{
		Subroutine;
		Settings;
	}

	actions
	{
		Global.TestMode = Workshop Setting Toggle(Custom String("Developer"), Custom String("Test Mode"), False, 0);
		Global.DifficultyValue = Workshop Setting Integer(Custom String("Difficulty"), Custom String("Difficulty"), 2, 1, 3, 0);
		Global.OverallPlayerLevel = Workshop Setting Integer(Custom String("Difficulty"), Custom String("Player Level"), 8, 1, 99, 0);
	}
}

rule("Identify Boss")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	actions
	{
		Event Player.Level = Global.OverallBossLevel;
		Event Player.CouldBeHumanPlayer = True;
		Event Player.Master[0] = Event Player;
	}
}

rule("Boss Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("IndividualSetup");
	}

	actions
	{
		Create HUD Text(Event Player.ShowBossBar ? All Players(Team 1) : Null, Null, Custom String("{0} {1}", Custom String("{0} {1} {2}",
			Custom String("{0} {1}", Event Player.BlastCooldown ? Custom String("{0}×{1}", Icon String(Asterisk), Round To Integer(
			Event Player.BlastCooldown, Up)) : Custom String(" "),
			Event Player.BarrierInfo[0] && Event Player.BarrierInfo[1] < Total Time Elapsed ? Icon String(Ring Thick) : Custom String(" ")),
			Event Player.RecoveryTime ? Icon String(Plus) : Custom String(" "), Event Player.StealthTime[1] ? Custom String("{0}{1}",
			Icon String(Eye), Event Player.StealthTime[0] ? Custom String("") : Max(1, Round To Integer(
			Event Player.StealthTime[1] - Total Time Elapsed, Up))) : Custom String(" ")), Custom String("{0} {1} {2}",
			Event Player.CrippleTime ? Icon String(Skull) : Custom String(" "), Event Player.SlowTime ? Icon String(Arrow: Down)
			: Custom String(" "), Custom String("{0} {1} {2}", Event Player.BleedInfo[0] ? Custom String("†×{0}",
			Event Player.BleedInfo[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[0] ? Custom String("Ѳ×{0}",
			Event Player.ArmourPiercingStacks[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[1] ? Custom String("Ø×{0}",
			Event Player.ArmourPiercingStacks[1]) : Custom String(" ")))), Null, Top, Slot Of(Event Player), Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create Progress Bar HUD Text(Event Player.ShowBossBar ? All Players(Team 1) : Empty Array, 100 * Normalized Health(Event Player),
			String("{0} / {1}", Max(1, Round To Integer(Health(Event Player), To Nearest)), Round To Integer(Max Health(Event Player),
			To Nearest)), Top, Slot Of(Event Player) + 0.100, Color(Red), Color(White), Visible To and Values, Default Visibility);
		Create HUD Text(Event Player.ShowBossBar ? All Players(Team 1) : Null, Null, Null, Event Player, Top, Slot Of(Event Player)
			+ 0.200, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Event Player.PizzaRadius = 100;
		Chase Player Variable At Rate(Event Player, SwingCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, DashCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, SlamCooldown, 0, 1, None);
		Chase Player Variable At Rate(Event Player, NeedleCooldown, 0, 1, None);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Reinhardt), Button(
			Primary Fire)), Custom String("[{0}]", Input Binding String(Button(Primary Fire))),
			Event Player.CanSwing && Event Player.SwingCooldown ? Round To Integer(Event Player.SwingCooldown, Up) : Custom String(" "),
			Right, 0, Event Player.CanSwing ? (Event Player.SwingCooldown > 0 ? Color(Orange) : Color(Gray)) : Color(Red), Color(White),
			Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Soldier: 76), Button(
			Ability 1)), Custom String("[{0}]", Input Binding String(Button(Ability 1))), Null, Right, 0, Event Player.CanSprint ? (
			Event Player.State == Custom String("ClosingIn") ? Color(Orange) : Color(Gray)) : Color(Red), Color(White), Color(White),
			Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Tracer), Button(
			Ability 1)), Event Player.State == Custom String("ClosingIn") ? Custom String("←/↓/→") : Custom String("[{0}]",
			Input Binding String(Button(Jump))), Event Player.CanDash && Event Player.DashCooldown ? Round To Integer(
			Event Player.DashCooldown, Up) : Custom String(" "), Right, 0, Event Player.CanDash ? (Event Player.DashCooldown > 0 ? Color(
			Orange) : Color(Gray)) : Color(Red), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Reinhardt), Button(
			Ultimate)), Custom String("[{0}]", Input Binding String(Button(Ultimate))),
			Event Player.CanSlam && Event Player.SlamCooldown ? Round To Integer(Event Player.SlamCooldown, Up) : Custom String(" "),
			Right, 0, Event Player.CanSlam ? (Event Player.SlamCooldown > 0 ? Color(Orange) : Color(Gray)) : Color(Red), Color(White),
			Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Doomfist), Button(
			Ultimate)), Null, Event Player.CanTakeOff && Event Player.TakeoffCooldown ? Round To Integer(Event Player.TakeoffCooldown, Up)
			: Custom String(" "), Right, 0, Event Player.CanTakeOff ? Color(Orange) : Color(Red), Color(White), Color(White),
			String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(0, 1, 3, 4), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Ramattra), Button(
			Primary Fire)), Custom String("[{0}]", Input Binding String(Button(Secondary Fire))),
			Event Player.CanNeedle[1] ? Custom String("{0} • {1}", Round To Integer(Event Player.NeedleCooldown, Up), Ammo(
			Event Player.Bots[0], 0)) : Custom String(" "), Right, 0, Event Player.CanNeedle[1] ? (Event Player.NeedleCooldown > 0 ? Color(
			Orange) : Color(Gray)) : Color(Red), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(4), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Echo), Button(
			Secondary Fire)), Custom String("[{0}]", Input Binding String(Button(Ability 2))), Null, Right, 0, Event Player.CanUseOrbs ? (
			Event Player.State == Custom String("Orbs") ? Color(Orange) : Color(Gray)) : Color(Red), Color(White), Color(White),
			Visible To String and Color, Default Visibility);
		Create HUD Text(Array Contains(Array(3), Global.Phase) ? Event Player : Null, Ability Icon String(Hero(Orisa), Button(Ability 2)),
			Null, Event Player.PizzaIndex == Custom String("Dormant") ? Null : Max(0, Event Player.PizzaTime[0] - Total Time Elapsed),
			Right, 0, Event Player.PizzaIndex == Custom String("Dormant") ? Color(Red) : (Event Player.PizzaIndex == Custom String("Soon")
			? Color(Gray) : Color(Orange)), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Set Jump Enabled(Event Player, False);
		Event Player.ShockwaveRadius = -1;
		Event Player.PizzaIndex = Custom String("Dormant");
		Create Icon(Global.State == Custom String("BossFight") ? Filtered Array(Global.Heroes,
			Event Player.CameraPosition == Null && Has Spawned(Event Player) && Is Alive(Event Player) && !Has Status(Event Player,
			Phased Out) && !Is In View Angle(Current Array Element, Eye Position(Event Player), 45)) : Null, Event Player, Arrow: Down,
			Visible To and Position, Color(Red), True);
		Event Player.NumPizzaLines = 4;
		For Player Variable(Event Player, PizzaIndex, 0, Event Player.NumPizzaLines, 1);
			Create Beam Effect(Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage")), Event Player.State) ? All Players(
				All Teams) : Null, Bad Beam, Update Every Frame(Position Of(Event Player) + (Event Player.State == Custom String("Pizza")
				? 0 : (Total Time Elapsed + 0.250 - Event Player.PizzaTime[1]) * 20) * Up + Event Player.PizzaRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0)
				+ Global.DeathLineRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)), Update Every Frame(Position Of(Event Player) + (
				Event Player.State == Custom String("Pizza") ? 0 : (Total Time Elapsed + 0.250 - Event Player.PizzaTime[1]) * 20)
				* Up - Event Player.PizzaRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0) + Global.DeathLineRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)),
				Event Player.State == Custom String("Pizza") ? Color(Blue) : Color(White), Visible To Position Radius and Color);
			Create Beam Effect(Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage")), Event Player.State) ? All Players(
				All Teams) : Null, Bad Beam, Update Every Frame(Position Of(Event Player) + (Event Player.State == Custom String("Pizza")
				? 0 : (Total Time Elapsed + 0.250 - Event Player.PizzaTime[1]) * 20) * Up + Event Player.PizzaRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0)
				- Global.DeathLineRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)), Update Every Frame(Position Of(Event Player) + (
				Event Player.State == Custom String("Pizza") ? 0 : (Total Time Elapsed + 0.250 - Event Player.PizzaTime[1]) * 20)
				* Up - Event Player.PizzaRadius * Direction From Angles(Event Player.PizzaAngle + Evaluate Once(
				Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines), 0) - Global.DeathLineRadius * Direction From Angles(
				Event Player.PizzaAngle + Evaluate Once(Event Player.PizzaIndex * 180 / Event Player.NumPizzaLines - 90), 0)),
				Event Player.State == Custom String("Pizza") ? Color(Blue) : Color(White), Visible To Position Radius and Color);
		End;
		Create Icon(Event Player.ArmourModifiers[1] && Has Spawned(Event Player) && !Has Status(Event Player, Phased Out) ? All Players(
			All Teams) : Null, Event Player, Heart, Visible To and Position, Color(Yellow), False);
		Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Ramattra), Event Player));
		disabled Create HUD Text(Event Player, Update Every Frame(Horizontal Speed Of(Event Player)), Null, Null, Left, 0, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Set Knockback Received(Event Player, 0);
		Event Player.ItemStackReturnInfo = Empty Array;
		Event Player.State = Custom String("Waiting");
	}
}

rule("Player Setup")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Array Contains(All Heroes, Hero Of(Event Player)) == True;
		Max Health(Event Player) > 0;
	}

	actions
	{
		If(Team Of(Event Player) == Team 2 && Hero Of(Event Player) == Hero(Sigma) && !Event Player.CouldBeHumanPlayer);
			Global.NullPlayer[1] = Event Player;
			Set Invisible(Event Player, All);
			Start Forcing Player Position(Event Player, Vector(-5, 300, 0), False);
			Set Status(Event Player, Null, Phased Out, 9999);
			Start Forcing Dummy Bot Name(Event Player, Custom String("The Planet"));
			Abort;
		Else If(Team Of(Event Player) == Team 1 && Hero Of(Event Player) == Hero(Soldier: 76) && !Event Player.CouldBeHumanPlayer);
			Global.NullPlayer[0] = Event Player;
			Set Invisible(Event Player, All);
			Start Forcing Player Position(Event Player, Vector(5, 300, 0), False);
			Set Status(Event Player, Null, Phased Out, 9999);
			Start Forcing Dummy Bot Name(Event Player, Custom String("The Captain"));
			Abort;
		End;
		Disable Built-In Game Mode Respawning(Event Player);
		Event Player.ItemStacks = Empty Array;
		Chase Player Variable At Rate(Event Player, SlowTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, BleedTime, 0, 1, None);
		Chase Player Variable At Rate(Event Player, APTime, 0, 1, None);
		Event Player.WispAcceleration = Vector(0, 0, 0);
		Event Player.HealthScale = Team Of(Event Player) == Team 2 ? 0.600 / 2.400 : 0.600;
		If(Event Player.CouldBeHumanPlayer);
			Chase Player Variable At Rate(Event Player, RecoveryTime, 0, 1, None);
			Create HUD Text(Array Contains(Array(Null, Custom String("Buy")), Global.State) ? Null : Event Player, Null, Null, Custom String(
				"{0} {1}", Custom String("{0} {1} {2}", Custom String("{0} {1}", Event Player.BlastCooldown ? Custom String("{0}×{1}",
				Icon String(Asterisk), Round To Integer(Event Player.BlastCooldown, Up)) : Custom String(" "),
				Event Player.BarrierInfo[0] && Event Player.BarrierInfo[1] < Total Time Elapsed ? Icon String(Ring Thick) : Custom String(" ")),
				Event Player.RecoveryTime ? Icon String(Plus) : Custom String(" "), Event Player.StealthTime[1] ? Custom String("{0}{1}",
				Icon String(Eye), Event Player.StealthTime[0] ? Custom String("") : Max(1, Round To Integer(
				Event Player.StealthTime[1] - Total Time Elapsed, Up))) : Custom String(" ")), Custom String("{0} {1} {2}",
				Event Player.CrippleTime ? Icon String(Skull) : Custom String(" "), Event Player.SlowTime ? Icon String(Arrow: Down)
				: Custom String(" "), Custom String("{0} {1} {2}", Event Player.BleedInfo[0] ? Custom String("†×{0}",
				Event Player.BleedInfo[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[0] ? Custom String("Ѳ×{0}",
				Event Player.ArmourPiercingStacks[0]) : Custom String(" "), Event Player.ArmourPiercingStacks[1] ? Custom String("Ø×{0}",
				Event Player.ArmourPiercingStacks[1]) : Custom String(" ")))), Left, 2.100, Color(White), Color(White), Color(White),
				Visible To and String, Default Visibility);
			Create HUD Text(Remove From Array(All Players(Team Of(Event Player)), Event Player), Hero Icon String(Hero Of(Event Player)),
				Event Player, Is Dead(Event Player) ? Icon String(X) : Mapped Array(Custom String("||||||||||"), String Slice(
				Current Array Element, 0, Round To Integer(Normalized Health(Event Player) * String Length(Current Array Element), Up))), Left,
				3.100, Color(White), Color(White), Normalized Health(Event Player) > 0.900 ? Color(Green) : Color(Lime Green),
				Visible To String and Color, Default Visibility);
		End;
		Disable Kill Feed(Event Player);
		Event Player.DefaultHealth = Array(Max Health(Event Player), Max Health Of Type(Event Player, Health), Max Health Of Type(
			Event Player, Armor), Max Health Of Type(Event Player, Shields));
		Add Health Pool To Player(Event Player, Health, Event Player.NormalExtraHealth[0], True, True);
		If(Event Player.DefaultHealth[2]);
			Add Health Pool To Player(Event Player, Armor, Event Player.NormalExtraHealth[1], True, True);
		End;
		If(Event Player.DefaultHealth[3]);
			Add Health Pool To Player(Event Player, Shields, Event Player.NormalExtraHealth[2], True, True);
		End;
		If(Team Of(Event Player) == Team 2 && !Event Player.CouldBeHumanPlayer);
			Event Player.Level = Global.OverallBossLevel;
			Set Crouch Enabled(Event Player, False);
			Event Player.BaseRegen = 15 / Event Player.HealthScale * (5 + (Event Player.Level - 1)) / 24;
		End;
		Event Player.State = Custom String("IndividualSetup");
	}
}

rule("Update Difficulty Coefficient (And Boss Level)")
{
	event
	{
		Subroutine;
		SetCoefficient;
	}

	actions
	{
		Global.DifficultyCoefficient = (Global.PlayerFactor + (Total Time Elapsed + 715) / 60 * Global.TimeFactor)
			* 1.150 ^ Global.StagesCompleted;
		Global.OverallBossLevel = 1 + 3 * (Global.DifficultyCoefficient - Global.PlayerFactor);
		All Players(Team 2).Level = Global.OverallBossLevel;
	}
}

rule("Identify Heroes")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	actions
	{
		Event Player.CouldBeHumanPlayer = True;
		Event Player.Master[0] = Event Player;
	}
}

rule("Team 1 Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.State == Custom String("IndividualSetup");
		Global.State != Null;
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.Currency = 1500;
		Chase Player Variable At Rate(Event Player, CrippleTime, 0, 1, None);
		disabled Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Global.Items), Event Player, 10));
		Event Player.Level = Global.OverallPlayerLevel;
		Event Player.TotalHPUnits = Event Player.HealthScale * Event Player.DefaultHealth[0] / 0.160 * (90 / 150) * (1 + 0.300 * (
			Event Player.Level - 1)) / 25;
		Event Player.BaseDamageMultiplier = (1 + 0.200 * (Event Player.Level - 1)) / 2.400;
		Event Player.BaseRegen = 15 / Event Player.HealthScale * (5 + (Event Player.Level - 1)) / 24;
		Call Subroutine(UpdateStats);
		Create Effect(Event Player.CrippleTime > 0 ? All Players(All Teams) : Null, Good Aura, Color(Sky Blue), Eye Position(Event Player),
			1, Visible To Position and Radius);
		If(Global.DifficultyValue == 1);
			Event Player.Armour[3] = 70;
		End;
		Create Effect(Global.State == Custom String("Buy") && Is True For Any(Global.ItemShopPositions, Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Current Array Element) < 1.500) ? Event Player : Null, Sphere, Color(Yellow), Sorted Array(
			Global.ItemShopPositions, Distance Between(Current Array Element, Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False)))[0], 0.600,
			Visible To Position Radius and Color);
		Create HUD Text(Global.State == Custom String("Buy") ? Event Player : Null, Custom String("£{0}", Event Player.Currency), Null,
			Max(0, Round To Integer(90 - Total Time Elapsed, Up)), Left, 1.100, Color(Yellow), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Global.State == Custom String("Buy") && Is True For Any(Global.ItemShopPositions, Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Current Array Element) < 1.500) ? Event Player : Null, Global.ItemShops[Filtered Array(Mapped Array(
			Global.ItemShopPositions, Current Array Index), Distance Between(Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False),
			Global.ItemShopPositions[Current Array Element]) < 1.500)[0]], Null, Custom String("£{0}",
			Global.ItemShopPrices[Filtered Array(Mapped Array(Global.ItemShopPositions, Current Array Index), Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Global.ItemShopPositions[Current Array Element]) < 1.500)[0]]), Top, 1, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Event Player.State = Custom String("Ready");
	}
}

rule("Team 1 Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Global.State != Null;
	}

	actions
	{
		Wait Until(Is Alive(Event Player), 9999);
		Teleport(Event Player, Vector(Random Real(105, 115), 0, Random Real(-19, 19)));
		disabled Teleport(Event Player, 80 * Direction From Angles(Random Integer(45, 135), 0));
		Set Facing(Event Player, Direction From Angles(Horizontal Angle Towards(Event Player, Vector(0, 0, 0)), 0), To Player);
	}
}

rule("Enable OSP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) > 0.900;
	}

	actions
	{
		Set Status(Event Player, Null, Unkillable, 9999);
	}
}

rule("Disable OSP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) <= 0.900;
	}

	actions
	{
		Clear Status(Event Player, Unkillable);
	}
}

rule("Crippled")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CrippleTime > 0;
	}

	actions
	{
		Event Player.MoveSpeedDebuffs[1] = 50;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ArmourModifiers[2] = -20;
		Start Rule(UpdateArmour, Restart Rule);
		Big Message(Event Player, Custom String("CRIPPLED"));
	}
}

rule("Not Crippled")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.CrippleTime == 0;
	}

	actions
	{
		Event Player.MoveSpeedDebuffs[1] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ArmourModifiers[2] = 0;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Slowed")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.SlowTime > 0;
	}

	actions
	{
		Event Player.MoveSpeedDebuffs[2] = 60;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Big Message(Event Player, Custom String("SLOWED"));
	}
}

rule("Not Slowed")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.SlowTime == 0;
	}

	actions
	{
		Event Player.MoveSpeedDebuffs[2] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("No Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierInfo[1] > Total Time Elapsed;
	}

	actions
	{
		Event Player.ArmourModifiers[6] = 0;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Barrier")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BarrierInfo[1] < Total Time Elapsed;
	}

	actions
	{
		Event Player.ArmourModifiers[6] = 100 * Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Barrier")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0];
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Recover")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.RecoveryTime == 0;
		Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
			"Recovery") && Global.ItemStackOwners[Current Array Index] == Event Player) == True;
	}

	actions
	{
		Heal(Event Player, Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Event Player))], (
			Event Player.HealthScale * 20 + Max Health(Event Player) * 0.050 * Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Recovery")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0]) / Event Player.HealingModifiers[0]);
	}
}

rule("Allow double jump if > 0.8 altitude & have double jumps")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		((Team Of(Event Player) == Team 2 && Event Player.CouldBeHumanPlayer) || (Altitude Of(Event Player) > 0.800)) == True;
		Event Player.DoubleJumps[0] - Event Player.DoubleJumps[1] > 0;
	}

	actions
	{
		Event Player.DoubleJumps[3] = True;
	}
}

rule("Disallow double jump")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.DoubleJumps[1] >= Event Player.DoubleJumps[0];
	}

	actions
	{
		Event Player.DoubleJumps[3] = False;
	}
}

rule("Double jump?")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Abort If(!Event Player.DoubleJumps[3] || Is Dead(Event Player) || Has Status(Event Player, Rooted) || Has Status(Event Player,
			Stunned));
		Event Player.DoubleJumps[2] += 1;
		Abort If((Hero Of(Event Player) == Hero(Genji) && Event Player.DoubleJumps[2] == 1) || (Hero Of(Event Player) == Hero(Hanzo)
			&& Mapped Array(Ability Cooldown(Event Player, Button(Jump)), Current Array Element == 0 || Current Array Element > 4.900)
			[0]));
		Event Player.DoubleJumps[1] += 1;
		Apply Impulse(Event Player, Up, 10, To World, Cancel Contrary Motion);
	}
}

rule("Bleeding")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BleedTime > 0;
	}

	actions
	{
		"20(%)/14"
		Damage(Event Player, Global.NullPlayer[Index Of Array Value(Array(Team 2, Team 1), Team Of(Event Player))],
			1.429 * Event Player.BleedInfo[0] * Event Player.BleedInfo[1]);
		Wait(0.250, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Not Bleeding")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BleedTime == 0;
	}

	actions
	{
		Event Player.BleedInfo = Array(0, 0);
	}
}

rule("Not AP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.APTime == 0;
	}

	actions
	{
		If(Event Player.ArmourPiercingStacks[0] == 5);
			Event Player.ArmourModifiers[4] = 0;
			Start Rule(UpdateArmour, Restart Rule);
		End;
		Event Player.ArmourPiercingStacks[0] = 0;
	}
}

rule("Update Move Speed (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateMoveSpeed == True;
	}

	actions
	{
		Event Player.ShouldUpdateMoveSpeed = False;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Update Move Speed")
{
	event
	{
		Subroutine;
		UpdateMoveSpeed;
	}

	actions
	{
		Event Player.MoveSpeedBuffs[0] = 1;
		Event Player.MoveSpeedDebuffs[0] = 1;
		For Player Variable(Event Player, MoveSpeedIndex, 1, Count Of(Event Player.MoveSpeedBuffs), 1);
			"1: Sprint, 2: Speed Item, 3: Stealth bonus"
			Event Player.MoveSpeedBuffs[0] += Event Player.MoveSpeedBuffs[Event Player.MoveSpeedIndex] / 100;
		End;
		For Player Variable(Event Player, MoveSpeedIndex, 1, Count Of(Event Player.MoveSpeedDebuffs), 1);
			"1: Cripple, 2: Slow"
			Event Player.MoveSpeedDebuffs[0] += Event Player.MoveSpeedDebuffs[Event Player.MoveSpeedIndex] / 100;
		End;
		Log To Inspector(Custom String("Updating move speed for {0}", Event Player));
		Set Move Speed(Event Player, Event Player.BaseMoveSpeedModifier * (
			Event Player.MoveSpeedBuffs[0] / Event Player.MoveSpeedDebuffs[0]));
		Log To Inspector(Custom String("Updated move speed for {0}", Event Player));
	}
}

rule("Update Armour (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateArmour == True;
	}

	actions
	{
		Event Player.ShouldUpdateArmour = False;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("Update Armour")
{
	event
	{
		Subroutine;
		UpdateArmour;
	}

	actions
	{
		Log To Inspector(Custom String("updating armour for {0}", Event Player));
		Event Player.ArmourModifiers[0] = 0;
		For Player Variable(Event Player, ArmourIndex, 1, Count Of(Event Player.ArmourModifiers), 1);
			"1: Armour Boost, 2: Cripple, 3: Easy Mode, 4: Armour Piercing, 5: Armour Reduction, 6: Barrier"
			Event Player.ArmourModifiers[0] += Event Player.ArmourModifiers[Event Player.ArmourIndex];
		End;
		Event Player.Armour = Event Player.ArmourModifiers[0];
		Event Player.DamageReceivedNewAmount = 1 - Event Player.Armour / (100 + Absolute Value(Event Player.Armour));
		Set Damage Received(Event Player, 100 * Event Player.DamageReceivedNewAmount);
		Log To Inspector(Custom String("updated damage received for {0} to {1}", Event Player, Event Player.DamageReceivedNewAmount));
	}
}

rule("Update Healing (From Flag)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.ShouldUpdateHealing == True;
	}

	actions
	{
		Event Player.ShouldUpdateHealing = False;
		Start Rule(UpdateHealing, Restart Rule);
	}
}

rule("Update Healing")
{
	event
	{
		Subroutine;
		UpdateHealing;
	}

	actions
	{
		Event Player.HealingModifiers[1] = 0;
		For Player Variable(Event Player, HealingIndex, 2, Count Of(Event Player.HealingModifiers), 1);
			"2: Rock"
			Event Player.HealingModifiers[1] += Event Player.HealingModifiers[Event Player.HealingIndex];
		End;
		Event Player.HealingModifiers[1] *= 1 + 0.200 * (Event Player.Level - 1);
		Event Player.HealingModifiers[1] += Event Player.BaseRegen;
		Log To Inspector(Custom String("Updating healing for {0}", Event Player));
		Event Player.HealingModifiers[0] = Event Player.HealingModifiers[1] * Array(1.500, 1, 0.600)[Global.DifficultyValue - 1] / (
			15 / Event Player.HealthScale);
		Set Healing Received(Event Player, Event Player.HealingModifiers[0] * 100);
		Log To Inspector(Custom String("Updated healing for {0}", Event Player));
	}
}

rule("Update Max HPs, healing and damage (after setting TotalHPUnits, BaseDamageMultiplier and BaseRegen)")
{
	event
	{
		Subroutine;
		UpdateStats;
	}

	actions
	{
		If(Event Player.CouldBeHumanPlayer && Team Of(Event Player) == Team 2);
			Event Player.NormalExtraHealth = Mapped Array(Array Slice(Event Player.DefaultHealth, 1, 2), Max(1, Round To Integer(
				Event Player.TotalHPUnits * Array(0.533, 0.467)[Current Array Index], Down)) * 25 - Current Array Element);
			Set Damage Dealt(Event Player.Bots[0], Event Player.BaseDamageMultiplier * 113.300);
		Else;
			Event Player.IntendedMaxHealth[1] = Event Player.TotalHPUnits * Event Player.DefaultHealth[2] / (
				Event Player.DefaultHealth[0] + Event Player.DefaultHealth[2] * (Event Player.CouldBeHumanPlayer ? 0 : 0.429));
			Event Player.IntendedMaxHealth[0] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1] / (
				Event Player.CouldBeHumanPlayer ? 1 : 0.700)) * (Event Player.DefaultHealth[1] + 0.600 * Event Player.DefaultHealth[3]) / (
				Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
			Event Player.IntendedMaxHealth[2] = (Event Player.TotalHPUnits - Event Player.IntendedMaxHealth[1] / (
				Event Player.CouldBeHumanPlayer ? 1 : 0.700)) * Event Player.DefaultHealth[3] * 0.400 / (
				Event Player.DefaultHealth[0] - Event Player.DefaultHealth[2]);
			Event Player.NormalExtraHealth = Mapped Array(Event Player.IntendedMaxHealth, Max(1, Round To Integer(Current Array Element, Down))
				* 25 - Event Player.DefaultHealth[Current Array Index + 1]);
		End;
		Set Damage Dealt(Event Player, Event Player.BaseDamageMultiplier * 100);
		Call Subroutine(UpdateHealing);
		Call Subroutine(CleanseAllDebuffs);
		Wait(0.250, Ignore Condition);
		Set Player Health(Event Player, 100000);
	}
}

rule("On hit effects")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	actions
	{
		If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
			"Barrier") && Global.ItemStackOwners[Current Array Index] == Victim));
			Victim.BarrierInfo[1] = Total Time Elapsed + 7;
		End;
		If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
			"Egg") && Global.ItemStackOwners[Current Array Index] == Victim));
			Heal(Victim, Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Victim))], Victim.HealthScale * Filtered Array(
				Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Egg")
				&& Global.ItemStackOwners[Current Array Index] == Victim)[0] * 15 / Victim.HealingModifiers[0]);
		End;
		If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
			"Recovery") && Global.ItemStackOwners[Current Array Index] == Victim));
			Victim.RecoveryTime = 2;
		End;
		If(Count Of(Attacker.Master[0].ItemStacks) > 0);
			Modify Player Variable(Victim, SlowTime, Max, 2 * Filtered Array(Global.ItemStackSizes,
				Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Slow")
				&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0]);
			If(Random Real(0, 1) < 0.100 * Filtered Array(Global.ItemStackSizes,
				Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Bleed")
				&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Min(1, Event Damage / (
				Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
				Modify Player Variable(Victim, BleedTime, Max, 3 * Min(1, Event Damage / (
					Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
				Victim.BleedInfo[0] += 1;
				Victim.BleedInfo[1] = Max(Attacker.Master[0].BaseDamageMultiplier, (Attacker.Master[0].BaseDamageMultiplier + Victim.BleedInfo[1])
					/ 2);
			End;
			If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
				"Armour Piercing") && Global.ItemStackOwners[Current Array Index] == Attacker.Master[0]));
				If(Victim.ArmourPiercingStacks[0] < 4);
					Victim.ArmourPiercingStacks[0] += 1;
					Modify Player Variable(Victim, APTime, Max, 2 * Min(1, Event Damage / (
						Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
				Else If(Victim.ArmourPiercingStacks[0] == 4);
					Victim.ArmourPiercingStacks[0] += 1;
					Victim.APTime = 8 * Filtered Array(Global.ItemStackSizes,
						Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Armour Piercing")
						&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0];
					Victim.ArmourModifiers[4] = -60;
					Victim.ShouldUpdateArmour = True;
				End;
			End;
			If(Event Damage / (Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier)
				>= 50 && Attacker.Master[0].BlastCooldown == 0);
				If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
					"Ice Blast") && Global.ItemStackOwners[Current Array Index] == Attacker.Master[0]));
					Attacker.Master[0].BlastCooldown = 10;
					Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Victim, 100);
					Play Effect(All Players(All Teams), Echo Sticky Bomb Explosion Effect, Color(White), Victim, 1);
					Modify Player Variable(Victim, SlowTime, Max, 3);
					Damage(Victim, Global.NullPlayer[Index Of Array Value(Array(Team 2, Team 1), Team Of(Victim))], 2.500 * Filtered Array(
						Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Ice Blast")
						&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Event Damage);
				End;
				If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
					"Flame Blast") && Global.ItemStackOwners[Current Array Index] == Attacker.Master[0]));
					Attacker.Master[0].BlastCooldown = 10;
					Attacker.Master[0].FlameTornadoDamage = Event Damage;
					Attacker.Master[0].FlameTornadoPosition = Position Of(Victim);
					Attacker.Master[0].FlameTornadoExpirationTime = Total Time Elapsed + 3;
					Create Effect(All Players(All Teams), Bad Aura, Color(Red), Attacker.Master[0].FlameTornadoPosition, 5, Visible To);
					Attacker.Master[0].FlameTornado = Last Created Entity;
					Play Effect(All Players(All Teams), Reaper Wraith Form Sound, Color(White), Attacker.Master[0].FlameTornadoPosition, 100);
				End;
			End;
			Heal(Attacker.Master[0], Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2), Team Of(Attacker.Master[0]))],
				Attacker.Master[0].HealthScale * Filtered Array(Global.ItemStackSizes,
				Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Lifesteal")
				&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Min(1, Event Damage / (
				Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36) / Attacker.Master[0].HealingModifiers[0]);
			If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
				"Stun Chance") && Global.ItemStackOwners[Current Array Index] == Attacker.Master[0]));
				If((Team Of(Victim) == Team 1 || !Victim.CouldBeHumanPlayer) && Random Real(0, 1) < (1 - 1 / (0.050 * Filtered Array(
					Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Stun Chance")
					&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] + 1)) * Min(1, Event Damage / (
					Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
					Set Status(Victim, Attacker.Master[0], Stunned, 2);
				End;
			End;
			If(!Array Contains(Global.LightningStrikes, Attacker.Master[0]) && Is True For Any(Global.ItemStackSizes,
				Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Lightning")
				&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0]) && Random Real(0, 1) < 0.100 * Min(1, Event Damage / (
				Victim.DamageReceivedNewAmount * Attacker.Master[0].BaseDamageMultiplier) / 36));
				Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Color(White), Eye Position(Victim), 100);
				Modify Global Variable(LightningStrikes, Append To Array, Array(Total Time Elapsed + 0.250, Eye Position(Victim),
					Attacker.Master[0], 5 * Filtered Array(Global.ItemStackSizes,
					Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Lightning")
					&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0] * Event Damage));
			End;
			Victim.ArmourPiercingStacks[1] += Filtered Array(Global.ItemStackSizes,
				Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Armour Reduction")
				&& Global.ItemStackOwners[Current Array Index] == Attacker.Master[0])[0];
			Victim.ArmourModifiers[5] = -2 * Victim.ArmourPiercingStacks[1];
			Victim.ShouldUpdateArmour = True;
		End;
		If(Team Of(Victim) == Team 2 && Victim.CouldBeHumanPlayer && Global.Phase == 4);
			Victim.Phase4DamageReceived += Event Damage;
		End;
		If(Global.TestMode);
			Small Message(Attacker.Master[0], Event Damage);
		End;
	}
}

rule("Reprieve")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Event Player.ItemStacks) > 0;
		Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
			"Reprieve") && Global.ItemStackOwners[Current Array Index] == Event Player) == True;
		Normalized Health(Event Player) < 0.250;
		Is Alive(Event Player) == True;
		Event Player.StealthTime[0] == 0;
		Event Player.StealthTime[1] == 0;
	}

	actions
	{
		Event Player.StealthTime[0] = Total Time Elapsed + 5;
		Event Player.StealthTime[1] = Event Player.StealthTime[0] + 30 * 0.500 ^ Max(0, Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Reprieve")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0] - 1);
		Set Invisible(Event Player, All);
		Event Player.MoveSpeedBuffs[3] = 40;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Uncloak")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.StealthTime[0] != 0;
		Total Time Elapsed > Event Player.StealthTime[0];
	}

	actions
	{
		Set Invisible(Event Player, None);
		Event Player.MoveSpeedBuffs[3] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.StealthTime[0] = 0;
	}
}

rule("Reprieve becomes available")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Total Time Elapsed > Event Player.StealthTime[1];
	}

	actions
	{
		Event Player.StealthTime[1] = 0;
	}
}

rule("Start Big Explosion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Event Player.ItemStacks) > 0;
		Normalized Health(Event Player) < 0.250;
		Is Alive(Event Player) == True;
		Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
			"Big Explosion") && Global.ItemStackOwners[Current Array Index] == Event Player) == True;
		Event Player.BoomTime[0] == 0;
		Event Player.BoomTime[1] == 0;
	}

	actions
	{
		Event Player.BoomTime[0] = Total Time Elapsed + 3;
		Event Player.BoomTime[1] = Total Time Elapsed + 30 / (1 + Filtered Array(Global.ItemStackSizes,
			Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String("Reprieve")
			&& Global.ItemStackOwners[Current Array Index] == Event Player)[0]);
	}
}

rule("Big Explosion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.BoomTime[0] != 0;
		Total Time Elapsed > Event Player.BoomTime[0];
	}

	actions
	{
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Color(White), Eye Position(Event Player), 100);
		Play Effect(All Players(All Teams), Bad Explosion, Color(White), Eye Position(Event Player), 30);
		Damage(Players Within Radius(Eye Position(Event Player), 30, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers),
			Event Player, 6000 / 14);
		Event Player.BoomTime[0] = 0;
	}
}

rule("Big explosion becomes available")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Total Time Elapsed > Event Player.BoomTime[1];
	}

	actions
	{
		Event Player.BoomTime[1] = 0;
	}
}

rule("Destroy Flame Tornado")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FlameTornado != Null;
		Total Time Elapsed > Event Player.FlameTornadoExpirationTime;
	}

	actions
	{
		Destroy Effect(Event Player.FlameTornado);
		Event Player.FlameTornadoPosition = Null;
		Event Player.FlameTornado = Null;
		Wait(0.016, Ignore Condition);
		Event Player.FlameTornadoExpirationTime = Null;
	}
}

rule("Flame Tornado Damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.FlameTornado != Null;
	}

	actions
	{
		Event Player.Victims = Filtered Array(Players Within Radius(Event Player.FlameTornadoPosition, 5, Opposite Team Of(Team Of(
			Event Player)), Off), Event Player.CouldBeHumanPlayer || Is On Ground(Current Array Element));
		Set Status(Event Player.Victims, Event Player, Burning, 0.350);
		Damage(Event Player.Victims, Event Player.CouldBeHumanPlayer ? Global.NullPlayer[Index Of Array Value(Array(Team 1, Team 2),
			Team Of(Event Player))] : Event Player, Event Player.FlameTornadoDamage * 0.304);
		Wait(0.304, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Lightning Strike Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.LightningStrikes) > 0;
		Total Time Elapsed > Global.LightningStrikes[0];
	}

	actions
	{
		Global.StrikeVictims = Filtered Array(All Living Players(Opposite Team Of(Team Of(Global.LightningStrikes[2]))), Distance Between(
			Eye Position(Current Array Element), Global.LightningStrikes[1]) < 3);
		Damage(Global.StrikeVictims, Global.LightningStrikes[2],
			Global.LightningStrikes[3] / Global.LightningStrikes[2].BaseDamageMultiplier);
		Apply Impulse(Global.StrikeVictims, Down, 70, To World, Cancel Contrary Motion);
		Wait(0.080, Ignore Condition);
		Global.LightningStrikes = Array Slice(Global.LightningStrikes, 4, 1000);
		Loop If Condition Is True;
	}
}

disabled rule("BOTS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Create Queued Bots")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.BotCreationQueue) > 1;
		Count Of(Global.AvailableBotSlots) > 0;
	}

	actions
	{
		Create Dummy Bot(Global.BotCreationQueue[0], Array Contains(All Players(All Teams), Global.BotCreationQueue[1]) ? Team Of(
			Global.BotCreationQueue[1]) : Global.BotCreationQueue[1], Last Of(Global.AvailableBotSlots), Vector(0, 0, 0), Forward);
		Wait Until(Global.BotCreationQueue[0] == Null, 99999);
		Global.BotCreationQueue = Array Slice(Global.BotCreationQueue, 2, 1000);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Dummy Bot Setup")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Event Player.CouldBeHumanPlayer = False;
		Modify Global Variable(AvailableBotSlots, Remove From Array By Value, Slot Of(Event Player));
		If(Array Contains(All Players(All Teams), Global.BotCreationQueue[1]));
			Event Player.Master[0] = Global.BotCreationQueue[1];
		Else;
			Event Player.Master[0] = Event Player;
		End;
		Global.BotCreationQueue[0] = Null;
	}
}

rule("Destroy bot subroutine")
{
	event
	{
		Subroutine;
		DestroyMe;
	}

	actions
	{
		If(Team Of(Event Player) == Team 2);
			Modify Global Variable(AvailableBotSlots, Append To Array, Slot Of(Event Player));
		End;
		Destroy Dummy Bot(Team Of(Event Player), Slot Of(Event Player));
	}
}

disabled rule("ITEMS")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Steal subroutine")
{
	event
	{
		Subroutine;
		Steal;
	}

	actions
	{
		Play Effect(Global.CurrentStealee, Moira Fade Disappear Sound, Color(White), Global.CurrentStealee, 100);
		Global.ItemStackOriginalOwners[Global.ItemStackBeingStolenIndex] = Global.CurrentStealee;
		Global.ItemStackOwners[Global.ItemStackBeingStolenIndex] = Null;
		Modify Player Variable(Global.CurrentStealee, ItemStacks, Remove From Array By Index, 0);
		Global.ItemStackNewOwners[Global.ItemStackBeingStolenIndex] = Global.Stealer;
		Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ItemStackBeingStolenIndex, 2,
			-1 * Global.ItemStackSizes[Global.ItemStackBeingStolenIndex]));
	}
}

rule("Handle Item Instances")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State != Null;
		Count Of(Global.ItemStacks) > 0;
		Array Contains(Global.ItemStackOwners, Null) == True;
	}

	actions
	{
		Call Subroutine(HandleItemInstance);
		Global.ItemStackIndex = (Global.ItemStackIndex + 1) % Count Of(Global.ItemStacks);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Acquire Item Subroutine")
{
	event
	{
		Subroutine;
		Acquire;
	}

	actions
	{
		If(Global.ItemStackNewOwners[Global.ItemStackIndex] != Global.ItemStackOriginalOwners[Global.ItemStackIndex]);
			Play Effect(Global.ItemStackNewOwners[Global.ItemStackIndex], Moira Fade Reappear Sound, Color(White),
				Global.ItemStackNewOwners[Global.ItemStackIndex], 100);
		End;
		Global.CurrentItemStackSize = Global.ItemStackSizes[Global.ItemStackIndex];
		Global.ExistingMatchingItemStacks = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
			Global.ItemStacks[Current Array Element] == Global.ItemStacks[Global.ItemStackIndex] && Global.ItemStackOwners[Current Array Element] == Global.ItemStackNewOwners[Global.ItemStackIndex]);
		Global.ItemStackOwners[Global.ItemStackIndex] = Global.ItemStackNewOwners[Global.ItemStackIndex];
		If(Count Of(Global.ExistingMatchingItemStacks) == 0);
			Modify Player Variable(Global.ItemStackOwners[Global.ItemStackIndex], ItemStacks, Append To Array,
				Global.ItemStacks[Global.ItemStackIndex]);
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ItemStackIndex, 1, Global.CurrentItemStackSize));
		Else;
			Global.ItemStackSizes[Global.ItemStackIndex] -= Global.CurrentItemStackSize;
			Global.ItemStackSizes[Global.ExistingMatchingItemStacks[0]] += Global.CurrentItemStackSize;
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.ExistingMatchingItemStacks[0], 0,
				Global.CurrentItemStackSize));
		End;
		Modify Player Variable(Global.ItemStackNewOwners[Global.ItemStackIndex], ItemStackReturnInfo, Append To Array, Array(
			Global.ItemStackIndex, Global.CurrentItemStackSize));
		Global.ItemStackNewOwners[Global.ItemStackIndex] = Null;
	}
}

rule("Distribute Item Subroutine")
{
	event
	{
		Subroutine;
		DistributeItem;
	}

	actions
	{
		Global.NewItemStackIndex = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
			Global.ItemStacks[Current Array Element] == Global.ItemDistributionInfo[0] && Global.ItemStackOwners[Current Array Element] == Global.ItemDistributionInfo[1]);
		If(Count Of(Global.NewItemStackIndex) > 0);
			Global.NewItemStackIndex = Global.NewItemStackIndex[0];
			Global.ItemStackSizes[Global.NewItemStackIndex] += Global.ItemDistributionInfo[2];
			Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.NewItemStackIndex, 0, Global.ItemDistributionInfo[2]));
		Else;
			Call Subroutine(CreateItemStack);
			Global.ItemStackSizes[Global.NewItemStackIndex] += Global.ItemDistributionInfo[2];
		End;
	}
}

rule("Handle Item Instance")
{
	event
	{
		Subroutine;
		HandleItemInstance;
	}

	actions
	{
		If(Global.ItemStackNewOwners[Global.ItemStackIndex]);
			Call Subroutine(Acquire);
		End;
	}
}

rule("Distribute Queued Items")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.ItemDistributionQueue) > 2;
	}

	actions
	{
		"[Item (name), Target Player, Count]"
		Global.ItemDistributionInfo = Array Slice(Global.ItemDistributionQueue, 0, 3);
		Call Subroutine(DistributeItem);
		Global.ItemDistributionQueue = Array Slice(Global.ItemDistributionQueue, 3, 1000);
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Create Item Stack Subroutine")
{
	event
	{
		Subroutine;
		CreateItemStack;
	}

	actions
	{
		Global.NewItemStackIndex = Count Of(Global.ItemStacks);
		Global.ItemStacks[Global.NewItemStackIndex] = Global.ItemDistributionInfo[0];
		Global.ItemStackOwners[Global.NewItemStackIndex] = Global.ItemDistributionInfo[1];
		Global.ItemStackNewOwners[Global.NewItemStackIndex] = Null;
		Modify Player Variable(Global.ItemDistributionInfo[1], ItemStacks, Append To Array, Global.ItemStacks[Global.NewItemStackIndex]);
		Create HUD Text(Global.ItemStackSizes[Evaluate Once(Global.NewItemStackIndex)] == 0 ? Null : Global.ItemStackOwners[Evaluate Once(
			Global.NewItemStackIndex)], Evaluate Once(Global.ItemSymbols[Index Of Array Value(Global.Items, Global.ItemDistributionInfo[0])
			]), Custom String("×{0}", Global.ItemStackSizes[Evaluate Once(Global.NewItemStackIndex)]), Null, Left, 4 + Evaluate Once(
			Global.NewItemStackIndex + 1) / (Count Of(Global.ItemStacks) + 1), Global.ItemColours[Index Of Array Value(Global.Items,
			Global.ItemDistributionInfo[0])], Color(White), Null, Visible To Sort Order and String, Default Visibility);
		Global.ItemStackHUDs[Global.NewItemStackIndex] = Last Text ID;
		Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Global.NewItemStackIndex, 1, Global.ItemDistributionInfo[2]));
	}
}

rule("Update Item Stacks from Queue")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State != Null;
		Count Of(Global.ItemStackUpdateInfos) > 2;
	}

	actions
	{
		Global.ItemStackUpdateInfo = Array(Global.ItemStackUpdateInfos[0], Global.ItemStacks[Global.ItemStackUpdateInfos[0]],
			Global.ItemStackOwners[Global.ItemStackUpdateInfos[0]], Global.ItemStackUpdateInfos[2]);
		If(Array Contains(Array(2, 4), Global.ItemRarities[Index Of Array Value(Global.Items, Global.ItemStackUpdateInfo[1])]));
			Global.ItemStackUpdateInfo[2].EvenRarityItemsCount += Global.ItemStackUpdateInfo[3];
		End;
		If(Global.ItemStackUpdateInfos[1] == 0);
			Call Subroutine(UpdateItemStack_Modify);
		Else;
			If(Global.ItemStackUpdateInfos[1] > 1);
				Call Subroutine(UpdateItemStack_Remove);
			End;
			If(Global.ItemStackUpdateInfos[1] % 2 == 1);
				Call Subroutine(UpdateItemStack_Add);
			End;
		End;
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Modify Global Variable(ItemStackUpdateInfos, Remove From Array By Index, 0);
		Wait(0.100, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Update Item Stack (Add)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Add;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Health, Evaluate Once(Global.ItemStackUpdateInfo[2])
				.HealthScale * 25 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])], True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Shields, Max Health Of Type(Evaluate Once(Global.ItemStackUpdateInfo[2]),
				Health) * 0.080 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])], True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Add Health Pool To Player(Global.ItemStackUpdateInfo[2], Health, Evaluate Once(Global.ItemStackUpdateInfo[2])
				.HealthScale * 40 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])], True, True);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Health Pool;
			Global.ItemStackUpdateInfo[2].HealingModifiers[2] = 1.600 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
		Else If(Array Contains(Array(Custom String("Speed"), Custom String("Double Jump"), Custom String("Barrier")),
				Global.ItemStackUpdateInfo[1]));
			Global.ItemStackUpdateInfo[2].BarrierInfo[0] = True;
			Call Subroutine(UpdateItemStack_Modify);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Close Range Damage"));
			Start Damage Modification(Players Within Radius(Eye Position(Global.ItemStackUpdateInfo[2]), 13, All Teams, Off),
				Global.ItemStackUpdateInfo[2], 100 + 20 * Global.ItemStackSizes[Evaluate Once(Global.ItemStackUpdateInfo[0])],
				Receivers Damagers and Damage Percent);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Damage Modification ID;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Ice Blast"));
			Chase Player Variable At Rate(Global.ItemStackUpdateInfo[2], BlastCooldown, 0, 1, None);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Flame Blast"));
			Chase Player Variable At Rate(Global.ItemStackUpdateInfo[2], BlastCooldown, 0, 1, None);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Big Explosion"));
			If(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] == Null);
				Create Effect(Global.ItemStackOwners[Evaluate Once(Global.ItemStackUpdateInfo[0])].BoomTime[0] ? All Players(All Teams) : Null,
					Winston Tesla Cannon Target Sound, Color(White), Eye Position(Global.ItemStackOwners[Evaluate Once(
					Global.ItemStackUpdateInfo[0])]), 100, Visible To Position and Radius);
			End;
			Create Effect(Evaluate Once(Global.ItemStackUpdateInfo[2]).BoomTime[0] ? All Players(All Teams) : Null, Sphere, Color(White),
				Eye Position(Evaluate Once(Global.ItemStackUpdateInfo[2])), 30 - (Evaluate Once(Global.ItemStackUpdateInfo[2])
				.BoomTime[0] - Total Time Elapsed) * 10, Visible To Position and Radius);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Last Created Entity;
		End;
	}
}

rule("Update Item Stack (Modify)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Modify;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP"));
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null,
				Global.ItemStackUpdateInfo[2].HealthScale * 25 * Global.ItemStackUpdateInfo[3] / Global.ItemStackUpdateInfo[2].HealingModifiers[0]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Shields"));
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null, Max Health Of Type(Global.ItemStackUpdateInfo[2], Health)
				* 0.080 * Global.ItemStackUpdateInfo[3] / Global.ItemStackUpdateInfo[2].HealingModifiers[0]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Speed"));
			Global.ItemStackUpdateInfo[2].MoveSpeedBuffs[2] = 14 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateMoveSpeed = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Double Jump"));
			Global.ItemStackUpdateInfo[2].DoubleJumps[0] = Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].BarrierInfo[0] = False;
			Global.ItemStackUpdateInfo[2].ArmourModifiers[6] = 100 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateArmour = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Global.ItemStackUpdateInfo[2].HealingModifiers[2] = 1.600 * Global.ItemStackSizes[Global.ItemStackUpdateInfo[0]];
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
			Wait(0.100, Ignore Condition);
			Heal(Global.ItemStackUpdateInfo[2], Null,
				Global.ItemStackUpdateInfo[2].HealthScale * 40 * Global.ItemStackUpdateInfo[3] / Global.ItemStackUpdateInfo[2].HealingModifiers[0]);
		End;
	}
}

rule("Update Item Stack (Remove)")
{
	event
	{
		Subroutine;
		UpdateItemStack_Remove;
	}

	actions
	{
		If(Global.ItemStackUpdateInfo[1] == Custom String("Max HP"));
			Remove Health Pool From Player(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Null;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Speed"));
			Global.ItemStackUpdateInfo[2].MoveSpeedBuffs[2] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateMoveSpeed = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Close Range Damage"));
			Stop Damage Modification(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Double Jump"));
			Global.ItemStackUpdateInfo[2].DoubleJumps[0] = 0;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Big Explosion"));
			Destroy Effect(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackUpdateInfo[2].BoomTime[0] = 0;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Barrier"));
			Global.ItemStackUpdateInfo[2].ArmourModifiers[6] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateArmour = True;
		Else If(Global.ItemStackUpdateInfo[1] == Custom String("Rock"));
			Remove Health Pool From Player(Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]]);
			Global.ItemStackEffects[Global.ItemStackUpdateInfo[0]] = Null;
			Global.ItemStackUpdateInfo[2].HealingModifiers[2] = 0;
			Global.ItemStackUpdateInfo[2].ShouldUpdateHealing = True;
		End;
	}
}

disabled rule("PHASE 0")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter State: Buy")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Buy");
	}

	actions
	{
		Global.ItemShops = Append To Array(Global.Items, Array(Custom String("?"), Custom String("??"), Custom String("???")));
		Global.ItemShopPositions = Mapped Array(Global.ItemShops, Vector(95, 0, ((Count Of(Global.ItemShops) - 1)
			/ 2 - Current Array Index) * 3));
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			Create In-World Text(All Players(Team 1), Mapped Array(Index Of Array Value(Global.Items, Global.ItemShops[Global.ItemShopIndex]),
				Current Array Element == -1 ? Global.ItemShops[Global.ItemShopIndex] : Global.ItemSymbols[Current Array Element]),
				Global.ItemShopPositions[Global.ItemShopIndex] + Up, 4, Do Not Clip, Visible To, Mapped Array(Index Of Array Value(
				Global.Items, Global.ItemShops[Global.ItemShopIndex]), Current Array Element == -1 ? Color(White)
				: Global.ItemColours[Current Array Element]), Default Visibility);
			Global.ItemShopEffects1[Global.ItemShopIndex] = Last Text ID;
			Create Effect(All Players(All Teams), Orb, Array(Color(White), Color(Green), Color(Red), Color(Yellow))[Mapped Array(
				Index Of Array Value(Global.Items, Global.ItemShops[Global.ItemShopIndex]), Current Array Element == -1 ? String Length(
				Global.ItemShops[Global.ItemShopIndex]) : Global.ItemRarities[Current Array Element]) - 1],
				Global.ItemShopPositions[Global.ItemShopIndex], 1, Visible To);
			Global.ItemShopEffects2[Global.ItemShopIndex] = Last Created Entity;
			Wait(0.016, Ignore Condition);
		End;
		Global.ItemShopPrices = Mapped Array(Global.ItemShops, Global.ItemRarities[Index Of Array Value(Global.Items,
			Current Array Element)] > 3 ? Custom String("∞") : (Array Contains(Global.Items, Current Array Element) ? 30 : 25) * Array(1,
			2, 16)[(Array Contains(Global.Items, Current Array Element) ? Global.ItemRarities[Index Of Array Value(Global.Items,
			Current Array Element)] : String Length(Current Array Element)) - 1]);
		Wait(20, Abort When False);
		Wait Until(Is True For All(All Players(Team 1), !Current Array Element.CouldBeHumanPlayer || (
			Current Array Element.State == Custom String("Ready") && (X Component Of(Position Of(Current Array Element))
			< 80 || Current Array Element.Currency < 25))), 70);
		For Global Variable(ItemShopIndex, 0, Count Of(Global.ItemShops), 1);
			Destroy In-World Text(Global.ItemShopEffects1[Global.ItemShopIndex]);
			Destroy Effect(Global.ItemShopEffects2[Global.ItemShopIndex]);
			Wait(0.016, Ignore Condition);
		End;
		Global.State = Custom String("Waiting");
	}
}

rule("Buy (with interact)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Global.State == Custom String("Buy");
		Is True For Any(Global.ItemShopPositions, Distance Between(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(
			Event Player) + 4 * Facing Direction Of(Event Player), Null, Event Player, False), Current Array Element) < 1.500) == True;
	}

	actions
	{
		Event Player.BuyIndex = Filtered Array(Mapped Array(Global.ItemShopPositions, Current Array Index), Distance Between(
			Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 4 * Facing Direction Of(Event Player), Null,
			Event Player, False), Global.ItemShopPositions[Current Array Element]) < 1.500);
		Abort If(Count Of(Event Player.BuyIndex) == 0);
		Event Player.BuyIndex = Event Player.BuyIndex[0];
		Call Subroutine(Buy);
	}
}

rule("Random Buy")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.TestMode == True;
		Global.State == Custom String("Buy");
		Is Button Held(Host Player, Button(Interact)) == True;
	}

	actions
	{
		Wait(1.250, Abort When False);
		While(True);
			Wait(0.250, Abort When False);
			Event Player.BuyIndex = Random Integer(0, Count Of(Global.ItemShops) - 1);
			Call Subroutine(Buy);
		End;
	}
}

rule("Buy subroutine")
{
	event
	{
		Subroutine;
		Buy;
	}

	actions
	{
		If(Event Player.Currency >= Global.ItemShopPrices[Event Player.BuyIndex] || (
			Global.TestMode && Global.ItemShopPrices[Event Player.BuyIndex] == Custom String("∞")));
			Event Player.Currency -= Global.ItemShopPrices[Event Player.BuyIndex];
			If(Array Contains(Global.Items, Global.ItemShops[Event Player.BuyIndex]));
				Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Global.ItemShops[Event Player.BuyIndex], Event Player, 1));
			Else;
				If(Global.ItemShops[Event Player.BuyIndex] == Custom String("??") && Random Real(0, 1) < 0.150 * Min(1, Global.StagesCompleted / (
					Event Player.EvenRarityItemsCount + 1)));
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == 4)), Event Player, 1));
				Else;
					Modify Global Variable(ItemDistributionQueue, Append To Array, Array(Random Value In Array(Filtered Array(Global.Items,
						Global.ItemRarities[Current Array Index] == String Length(Global.ItemShops[Event Player.BuyIndex]))), Event Player, 1));
				End;
			End;
			Play Effect(All Players(All Teams), Brigitte Repair Pack Armor Sound, Color(White),
				Global.ItemShopPositions[Event Player.BuyIndex], 100);
		Else;
			Play Effect(Event Player, Sombra Translocator Reappear Sound, Color(White), Global.ItemShopPositions[Event Player.BuyIndex], 50);
		End;
	}
}

rule("On Enter State: Waiting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Waiting");
	}

	actions
	{
		Set Invisible(Event Player, All);
		Start Forcing Player Position(Event Player, Vector(1, 2.500, 0), False);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Status(Event Player, Null, Unkillable, 9999);
		Event Player.CanSwing = False;
	}
}

rule("Enter State: OnTheWay")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Waiting");
		disabled Is True For Any(All Living Players(Team 1), Has Spawned(Current Array Element) && Absolute Value(X Component Of(Position Of(
			Current Array Element))) < 16 && Absolute Value(Z Component Of(Position Of(Current Array Element))) < 16) == True;
		Is True For Any(All Living Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0,
			0, 0)) < 70) == True;
		Is True For Any(Players On Hero(Hero(Reinhardt), Team 2), Has Spawned(Current Array Element)) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.State = Custom String("OnTheWay");
	}
}

rule("On Enter State: OnTheWay")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("OnTheWay");
	}

	actions
	{
		Global.Heroes = Filtered Array(All Players(Team 1), Current Array Element.CouldBeHumanPlayer);
		Global.Bosses = Players On Hero(Hero(Reinhardt), Team 2);
		Global.PlayerCount = Number Of Players(Team 1);
		Global.BossCount = Count Of(Global.Bosses);
		Global.PlayerFactor = 1 + 0.300 * (Global.PlayerCount - 1);
		Global.TimeFactor = 0.051 * Global.DifficultyValue * Global.PlayerCount ^ 0.200;
		Call Subroutine(SetCoefficient);
		Wait(2, Ignore Condition);
		Global.State = Custom String("Cutscene");
	}
}

rule("On Enter State: Cutscene (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("Cutscene");
	}

	actions
	{
		Enable Built-In Game Mode Music;
		Wait(2, Ignore Condition);
		Global.Bosses.State = Custom String("Cutscene");
		Call Subroutine(SetCoefficient);
		Destroy Effect(Global.BossSpawnEffect);
		Wait Until(Is True For All(Global.Bosses, Current Array Element.State == Custom String("Ready")), 99999);
		Global.State = Custom String("BossFight");
		Global.Phase = 1;
	}
}

rule("On Enter State: Cutscene (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Cutscene");
	}

	actions
	{
		Start Facing(Event Player, Left, 10000, To World, None);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Stop Forcing Player Position(Event Player);
		Clear Status(Event Player, Phased Out);
		Apply Impulse(Event Player, Down, 70, To World, Cancel Contrary Motion);
		"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
		Event Player.TotalHPUnits = Event Player.HealthScale * (1000 + 300 * (Event Player.Level - 1)) * (1 + Global.DifficultyCoefficient)
			* Square Root(Count Of(Filtered Array(Global.Heroes, Is Alive(Current Array Element)))) / Global.BossCount / 25;
		Event Player.BaseDamageMultiplier = 2 * (16 + 3.200 * (Event Player.Level - 1)) * 0.600 / 85;
		Event Player.BaseRegen = 15 / Event Player.HealthScale * (5 + (Event Player.Level - 1)) / 24;
		Call Subroutine(UpdateStats);
		Set Invisible(Event Player, None);
		Create Icon(Has Spawned(Event Player) && Event Player.State != Custom String("Waiting") && Event Player.State != Custom String(
			"Absent") ? Filtered Array(Global.Heroes, Has Status(Event Player, Phased Out) || !Is In View Angle(Current Array Element,
			Eye Position(Event Player), 45)) : Null, Event Player, Arrow: Down, Visible To and Position, Color(Red), True);
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is On Ground(Event Player), 99999);
		Wait(1.500, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1.500, Ignore Condition);
		Event Player.State = Custom String("Ready");
	}
}

rule("On Enter State: Cutscene (Team 1)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.State == Custom String("Cutscene");
	}

	actions
	{
		Event Player.CameraPosition = Eye Position(Event Player) + World Vector Of(Forward, Event Player, Rotation);
		Disable Hero HUD(Event Player);
		Set Status(Event Player, Null, Rooted, 9999);
		Set Ability 1 Enabled(Event Player, False);
		Set Ability 2 Enabled(Event Player, False);
		Set Primary Fire Enabled(Event Player, False);
		Set Secondary Fire Enabled(Event Player, False);
		Set Ultimate Ability Enabled(Event Player, False);
		Disallow Button(Event Player, Button(Interact));
		Set Melee Enabled(Event Player, False);
		Set Reload Enabled(Event Player, False);
		Start Camera(Event Player, Event Player.CameraPosition, World Vector Of(2 * Up, Global.Bosses[Slot Of(Event Player) % Count Of(
			Global.Bosses)], Rotation And Translation), 60);
		If(Distance Between(Global.Bosses[Slot Of(Event Player) % Count Of(Global.Bosses)], Event Player.CameraPosition)
			< Distance Between(Global.Bosses[Slot Of(Event Player) % Count Of(Global.Bosses)], World Vector Of(Vector(0, 2, 35),
			Global.Bosses[Slot Of(Event Player) % Count Of(Global.Bosses)], Rotation And Translation)));
			Chase Player Variable At Rate(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 6), Global.Bosses[Slot Of(Event Player)
				% Count Of(Global.Bosses)], Rotation And Translation), 15, Destination and Rate);
		Else;
			Chase Player Variable Over Time(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 35), Global.Bosses[Slot Of(Event Player)
				% Count Of(Global.Bosses)], Rotation And Translation), 1, Destination and Duration);
			Wait(1, Abort When False);
			Chase Player Variable At Rate(Event Player, CameraPosition, World Vector Of(Vector(0, 2, 6), Global.Bosses[Slot Of(Event Player)
				% Count Of(Global.Bosses)], Rotation And Translation), 30, Destination and Rate);
		End;
	}
}

rule("On Exit State: Cutscene (Team 1)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.State != Custom String("Cutscene");
	}

	actions
	{
		Clear Status(Event Player, Rooted);
		Set Ability 1 Enabled(Event Player, True);
		Set Ability 2 Enabled(Event Player, True);
		Set Primary Fire Enabled(Event Player, True);
		Set Secondary Fire Enabled(Event Player, True);
		Set Ultimate Ability Enabled(Event Player, True);
		Allow Button(Event Player, Button(Interact));
		Set Melee Enabled(Event Player, True);
		Set Reload Enabled(Event Player, True);
		Chase Player Variable At Rate(Event Player, CameraPosition, Eye Position(Event Player) + World Vector Of(Forward, Event Player,
			Rotation), 60, Destination and Rate);
		Enable Hero HUD(Event Player);
		Wait Until(Distance Between(Event Player.CameraPosition, Eye Position(Event Player)) < 1.500, 1);
		Stop Camera(Event Player);
		Stop Chasing Player Variable(Event Player, CameraPosition);
		Event Player.CameraPosition = Null;
	}
}

disabled rule("PHASE 1")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Reset Shockwave")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.ShockwaveRadius == 55;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, ShockwaveRadius);
		Event Player.ShockwaveRadius = -1;
		Destroy Effect(Event Player.ShockwaveEffect);
	}
}

rule("On Phase 1 Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 1;
	}

	actions
	{
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.ShowBossBar = True;
		Stop Facing(Event Player);
		Wait(1, Abort When False);
		Chase Player Variable At Rate(Event Player, TakeoffCooldown, 0, 1, None);
		Event Player.State = Custom String("ClosingIn");
	}
}

rule("On Enter State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("ClosingIn");
	}

	actions
	{
		Event Player.CanSprint = True;
		Event Player.CanNeedle[1] = Event Player.CanNeedle[0];
		Event Player.MoveSpeedBuffs[1] = 200;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Start Forcing Throttle(Event Player, 1, 1, 0, 0, 0, 1);
	}
}

rule("Exit State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("ClosingIn");
		Is True For Any(All Living Players(Team 1), Distance Between(Event Player, Current Array Element) < 6) == True;
		Event Player.PizzaIndex == Custom String("Dormant");
	}

	actions
	{
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("On Exit State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
	}

	actions
	{
		Event Player.CanNeedle[1] = False;
		Event Player.MoveSpeedBuffs[1] = 0;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("On Enter State: Becoming Idle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("BecomingIdle");
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		"Remove Armour Boost"
		Event Player.ArmourModifiers[1] = 0;
		Start Rule(UpdateArmour, Restart Rule);
		Stop Holding Button(Event Player, Button(Crouch));
		Stop Forcing Throttle(Event Player);
		If(Event Player.PizzaIndex == Custom String("ASAP"));
			Event Player.State = Custom String("Pizza");
		Else If(Array Contains(Array(1, 3), Global.Phase) && Is On Ground(Event Player) && Normalized Health(Event Player)
				< 0.750 && Event Player.TakeoffCooldown == 0);
			Event Player.State = Custom String("StartingTakeoff");
		Else;
			Stop Forcing Throttle(Event Player);
			If(Global.Phase == 4);
				Event Player.CanNeedle = Array(True, True);
			End;
			Event Player.State = Custom String("Idle");
		End;
	}
}

rule("Enable Sprint")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Idle");
		Is True For Any(All Living Players(Team 1), Distance Between(Position Of(Current Array Element) - Y Component Of(Position Of(
			Current Array Element)) * Up, Event Player) < 13) == False;
	}

	actions
	{
		Event Player.CanSprint = True;
	}
}

rule("Disable Sprint")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
		(Event Player.State == Custom String("Idle") && !Is True For Any(All Living Players(Team 1), Distance Between(Position Of(
			Current Array Element) - Y Component Of(Position Of(Current Array Element)) * Up, Event Player) < 13)) == False;
	}

	actions
	{
		Event Player.CanSprint = False;
	}
}

rule("Enter State: Closing In")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("ClosingIn");
		Event Player.CanSprint == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		Event Player.State = Custom String("ClosingIn");
	}
}

rule("Enable Takeoff (cooldown & state etc permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		"Maybe add an extra requirement - either a manual keypress or taking 2 instances of damage for each takeoff or something?"
		Normalized Health(Event Player) < 0.750;
	}

	actions
	{
		Event Player.CanTakeOff = True;
	}
}

rule("Enter State: StartingTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanTakeOff == True;
		Event Player.State == Custom String("Idle");
		"Maybe add an extra requirement - either a manual keypress or taking 2 instances of damage for each takeoff or something?"
		Event Player.TakeoffCooldown == 0;
		Is On Ground(Event Player) == True;
		"don't initiate takeoff just before hammer hits the ground"
		Ultimate Charge Percent(Event Player) > 95;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is Crouching(Event Player), 99999);
		Abort If Condition Is False;
		Event Player.State = Custom String("StartingTakeoff");
	}
}

rule("On Enter State: StartingTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingTakeoff");
	}

	actions
	{
		Event Player.State = Custom String("Takeoff");
	}
}

rule("On Enter State: FinishingFullTakeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("FinishingFullTakeoff");
	}

	actions
	{
		If(Global.Phase == 3);
			Stop Chasing Player Variable(Event Player, TakeoffCooldown);
		End;
		Event Player.TakeoffCooldown = 30;
		If(Global.Phase == 3);
			Event Player.PizzaIndex = Custom String("Soon");
		End;
		Wait(3, Abort When False);
		Event Player.State = Custom String("Landing");
	}
}

rule("On Enter State: Landing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Landing");
	}

	actions
	{
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Stop Forcing Player Position(Event Player);
		Clear Status(Event Player, Phased Out);
		Apply Impulse(Event Player, Down, 70, To World, Cancel Contrary Motion);
		Set Invisible(Event Player, None);
		Start Holding Button(Event Player, Button(Crouch));
		Wait Until(Is On Ground(Event Player), 99999);
		If(Global.Phase == 1 || Event Player.PizzaIndex == Custom String("Soon"));
			Create Effect(All Players(All Teams), Ring, Color(Sky Blue), Vector(0, 0, 0), Event Player.ShockwaveRadius + 2,
				Visible To Position and Radius);
			Event Player.ShockwaveEffect = Last Created Entity;
			Event Player.ShockwaveRadius = 0;
			Chase Player Variable At Rate(Event Player, ShockwaveRadius, 55, 10, None);
			Event Player.CanNeedle = Array(True, False);
		End;
		Wait(1, Abort When False);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1, Abort When False);
		"Remove Armour Boost"
		Event Player.ArmourModifiers[1] = 0;
		Start Rule(UpdateArmour, Restart Rule);
		Clear Status(Event Player, Rooted);
		Call Subroutine(ChooseState);
		Abort If(Event Player.PizzaIndex != Custom String("Soon"));
		Event Player.PizzaTime[0] = Total Time Elapsed + Random Real(5, 8.500);
	}
}

rule("Shockwave Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is True For Any(Global.Bosses, Current Array Element.ShockwaveRadius > 0 && Distance Between(Event Player,
			Current Array Element.ShockwaveRadius * Direction From Angles(Horizontal Angle From Direction(Position Of(Event Player)), 0))
			< 0.500) == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Phased Out) == False;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Damage(Event Player, Global.NullPlayer[1], 170 * Global.Bosses[0].BaseDamageMultiplier);
		Modify Player Variable(Event Player, CrippleTime, Max, 3);
	}
}

rule("Low health")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Health(Event Player) < 2;
	}

	actions
	{
		Abort If(Event Player.HasLostThisPhase);
		Log To Inspector(Custom String("\"death\""));
		"probably need a bunch more caveats"
		If(Global.Phase == 1);
			Event Player.HasLostThisPhase = True;
			If(Event Player.State == Custom String("Takeoff"));
				Event Player.State = Custom String("Takeoff2");
			Else If(Event Player.State == Custom String("FullTakeoff"));
				Event Player.State = Custom String("FullTakeoff2");
			Else If(Event Player.State == Custom String("FinishingFullTakeoff"));
				Event Player.State = Custom String("FinishingFullTakeoff2");
			Else;
				Event Player.State = Custom String("StartingTakeoff2");
			End;
		Else If(Global.Phase == 3);
			Event Player.HasLostThisPhase = True;
			Event Player.CanSwing = False;
			Event Player.CanSlam = False;
			Cancel Primary Action(Event Player);
			Set Status(Event Player, Null, Phased Out, 9999);
			Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
			Set Invisible(Event Player, All);
			Event Player.ShowBossBar = False;
			Call Subroutine(CleanseAllDebuffs);
			Event Player.State = Custom String("Absent");
		End;
	}
}

rule("On Enter State: StartingTakeoff2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingTakeoff2");
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Event Player.State = Custom String("Takeoff2");
	}
}

rule("TakeOff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(Custom String("Takeoff"), Custom String("Takeoff2")), Event Player.State) == True;
	}

	actions
	{
		"Add Armour Boost"
		Event Player.ArmourModifiers[1] = 200;
		Start Rule(UpdateArmour, Restart Rule);
		Event Player.CanSwing = False;
		Event Player.CanSlam = False;
		Start Holding Button(Event Player, Button(Crouch));
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Wait(1, Abort When False);
		Event Player.State = Custom String("Full{0}", Event Player.State);
		Apply Impulse(Event Player, Up, 70, To World, Cancel Contrary Motion);
		Wait(0.250, Ignore Condition);
		Set Invisible(Event Player, All);
		Start Forcing Player Position(Event Player, Vector(1, 50, 0), False);
		Set Status(Event Player, Null, Phased Out, 9999);
		Event Player.State = Custom String("Finishing{0}", Event Player.State);
	}
}

rule("Stunned during takeoff")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Takeoff");
		Has Status(Event Player, Stunned) == True;
	}

	actions
	{
		Event Player.TakeoffCooldown = 30;
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("On Enter State: FinishingFullTakeoff2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("FinishingFullTakeoff2");
	}

	actions
	{
		Event Player.ShowBossBar = False;
		Event Player.TakeoffCooldown = 0;
		Call Subroutine(CleanseAllDebuffs);
		Event Player.State = Custom String("Absent");
	}
}

rule("Enter Phase: 2/4")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.Bosses) > 0;
		Is True For All(Global.Bosses, Current Array Element.State == Custom String("Absent")) == True;
	}

	actions
	{
		If(Global.Phase == 1);
			Global.Phase = 2;
		Else If(Global.Phase == 3);
			Global.Phase = 4;
		End;
	}
}

disabled rule("SWING")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Disable Swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Event Player.CanSwing && Event Player.SwingCooldown == 0) == False;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
	}
}

rule("Enable swing (cooldown permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
	}

	actions
	{
		Event Player.CanSwing = True;
	}
}

rule("Enable swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanSwing == True;
		Event Player.SwingCooldown == 0;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("Enter State: StartingSwing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		If(Event Player.CanSwing);
			Event Player.State = Custom String("StartingSwing");
		Else;
			Cancel Primary Action(Event Player);
		End;
	}
}

rule("On Enter State: StartingSwing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StartingSwing");
	}

	actions
	{
		Disable Movement Collision With Players(Event Player);
		Event Player.CanSlam = False;
		Event Player.SwingCooldown = 5;
		Wait(0.200, Ignore Condition);
		Start Forcing Throttle(Event Player, 0, 1, 0, 1, 0, 0);
		Wait Until(Is On Ground(Event Player), 1);
		Event Player.DashAngles[0] = Horizontal Facing Angle Of(Event Player);
		Event Player.DashAngles[1] = 4.945;
		Set Gravity(Event Player, 63);
		Event Player.DashSpeed = 32;
		Call Subroutine(Dash);
		Event Player.State = Custom String("Swinging");
	}
}

disabled rule("SLAM")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Disable Slam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Event Player.CanSlam && Event Player.SlamCooldown == 0) == False;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, False);
	}
}

rule("Remove knockdown from slam")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		Clear Status(Event Player, Knocked Down);
	}
}

rule("Enable slam (cooldown permitting)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(1, 3), Global.Phase) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
	}

	actions
	{
		Event Player.CanSlam = True;
	}
}

rule("Enable slam")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanSlam == True;
		Event Player.SlamCooldown == 0;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		Set Ultimate Ability Enabled(Event Player, True);
	}
}

rule("Enter State: Slamming")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Slamming");
	}
}

rule("On Enter State: Slamming")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Slamming");
	}

	actions
	{
		Event Player.SlamCooldown = 4;
		Set Status(Event Player, Null, Rooted, 2.750);
		If(Global.Phase == 3);
			Modify Global Variable(FlamePillarPositions, Append To Array, World Vector Of(3 * Forward, Event Player,
				Rotation And Translation));
			Modify Global Variable(FlamePillarExpirationTimes, Append To Array, Total Time Elapsed + 45);
			Create Effect(All Players(All Teams), Light Shaft, Color(Blue), Last Of(Global.FlamePillarPositions), 1, Visible To);
			Modify Global Variable(FlamePillars, Append To Array, Last Created Entity);
		End;
	}
}

rule("Exit State: Slamming")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Slamming");
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Event Player.State = Custom String("BecomingIdle");
	}
}

disabled rule("DASH")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Enable Dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) == True;
		Global.Phase != 4;
	}

	actions
	{
		Event Player.CanDash = True;
	}
}

rule("Disable Dash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Is On Ground(Event Player) && Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State)
			&& Global.Phase != 4) == False;
	}

	actions
	{
		Event Player.CanDash = False;
	}
}

rule("Enter State: Dashing (with jump button)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanDash == True;
		Event Player.DashCooldown == 0;
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Event Player.State = Custom String("Dashing");
	}
}

rule("Enter State: Dashing (with sideways movement)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.DashCooldown == 0;
		Absolute Value(X Component Of(Throttle Of(Event Player))) > 0.700;
	}

	actions
	{
		Abort If(!Event Player.CanDash || Event Player.State != Custom String("ClosingIn"));
		Event Player.State = Custom String("Dashing");
	}
}

rule("On Enter State: Dashing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Dashing");
	}

	actions
	{
		Event Player.DashCooldown = 4;
		Call Subroutine(CleanseSomeDebuffs);
		Disable Movement Collision With Players(Event Player);
		Event Player.CanSlam = False;
		Event Player.DashAngles[0] = Horizontal Angle From Direction(World Vector Of(Mapped Array(Throttle Of(Event Player),
			X Component Of(Current Array Element) == 0 ? (Z Component Of(Current Array Element) == 0 ? Forward : Backward)
			: Current Array Element), Event Player, Rotation));
		Event Player.DashAngles[1] = 6.300;
		Set Gravity(Event Player, 175);
		Event Player.DashSpeed = 31;
		Call Subroutine(Dash);
	}
}

rule("Is On Ground")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.DoubleJumps[1] = 0;
		Event Player.DoubleJumps[2] = 0;
		If(Team Of(Event Player) != Team 2 || !Event Player.CouldBeHumanPlayer);
			Event Player.DoubleJumps[3] = False;
		End;
		If(Array Contains(Array(Custom String("Dashing"), Custom String("Swinging")), Event Player.State));
			Log To Inspector(Custom String("S: {0} T: {1}", Distance Between(Event Player, Event Player.DashStartPosition),
				Total Time Elapsed - Event Player.DashStartTime));
			Set Gravity(Event Player, 100);
			Event Player.State = Custom String("BecomingIdle");
		End;
	}
}

rule("On Exit State: Dash/Swing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State != Custom String("Dashing");
		Event Player.State != Custom String("Swinging");
		Event Player.State != Custom String("StartingSwing");
	}

	actions
	{
		Enable Movement Collision With Players(Event Player);
	}
}

rule("Dash subroutine")
{
	event
	{
		Subroutine;
		Dash;
	}

	actions
	{
		Event Player.DashStartPosition = Position Of(Event Player);
		Event Player.DashStartTime = Total Time Elapsed;
		Apply Impulse(Event Player, Direction From Angles(Event Player.DashAngles[0], Is On Ground(Event Player)
			? -1 * Event Player.DashAngles[1] : Max(-1 * Event Player.DashAngles[1], Vertical Facing Angle Of(Event Player))),
			Event Player.DashSpeed / Event Player.MoveSpeedDebuffs[0], To World, Cancel Contrary Motion XYZ);
	}
}

disabled rule("SHOOT")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Needler Bot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ramattra;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.CouldBeHumanPlayer == False;
	}

	actions
	{
		Event Player.Master[0].Bots[0] = Event Player;
		Wait(0.250, Ignore Condition);
		Start Forcing Dummy Bot Name(Event Player, Event Player.Master[0]);
		Set Gravity(Event Player, 0);
		Disable Movement Collision With Environment(Event Player, True);
		Attach Players(Event Player, Event Player.Master[0], Vector Towards(Local Vector Of(Eye Position(Event Player), Event Player,
			Rotation And Translation), Local Vector Of(Eye Position(Event Player.Master[0]), Event Player.Master[0],
			Rotation And Translation)));
		Set Max Ammo(Event Player, 0, 30);
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Invisible(Event Player, All);
		Start Facing(Event Player, Facing Direction Of(Event Player.Master[0]), 720, To World, Direction and Turn Rate);
	}
}

rule("Start Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.NeedleCooldown == 0;
		Event Player.CanNeedle[1] == True;
	}

	actions
	{
		Event Player.NeedleCooldown = 6;
		Set Ammo(Event Player.Bots[0], 0, Max Ammo(Event Player.Bots[0], 0));
		Start Holding Button(Event Player.Bots[0], Button(Primary Fire));
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Ammo(Event Player.Bots[0], 0) == 0;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots, Button(Primary Fire));
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
	}
}

rule("Stop Holding Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.CanNeedle[1] == False;
	}

	actions
	{
		Stop Holding Button(Event Player.Bots[0], Button(Primary Fire));
	}
}

disabled rule("PHASE 2")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter Phase: 2 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 2;
	}

	actions
	{
		Call Subroutine(SetCoefficient);
		For Global Variable(BossIndex, 0, Min(2, Global.BossCount) * 4, 1);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Tracer), Team 2));
			Wait(0.016, Abort When False);
		End;
		For Global Variable(BossIndex, 0, Min(2, Global.BossCount) * 2, 1);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Zenyatta), Team 2));
			Wait(0.016, Abort When False);
		End;
		For Global Variable(BossIndex, 0, Min(2, Global.BossCount) * 2, 1);
			Modify Global Variable(BotCreationQueue, Append To Array, Array(Hero(Wrecking Ball), Team 2));
			Wait(0.016, Abort When False);
		End;
	}
}

rule("Enter Phase: 3")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 2;
		Is True For All(Remove From Array(Filtered Array(All Players(Team 2),
			Current Array Element.Master[0] == Current Array Element && !Current Array Element.CouldBeHumanPlayer), Global.NullPlayer),
			Current Array Element.IsDead) == True;
	}

	actions
	{
		Wait(5, Abort When False);
		Global.Phase = 3;
	}
}

rule("Add. choose target")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Idle");
		Is Alive(Event Player) == True;
		Event Player.Target == Null;
		Is True For Any(All Living Players(Team 1), !Has Status(Current Array Element, Phased Out)
			&& Current Array Element.StealthTime[0] == 0 && Current Array Element.Master[0] == Current Array Element) == True;
	}

	actions
	{
		Event Player.Target = Sorted Array(Filtered Array(All Living Players(Team 1), !Has Status(Current Array Element, Phased Out)
			&& Current Array Element.StealthTime[0] == 0 && Current Array Element.Master[0] == Current Array Element), Distance Between(
			Event Player, Current Array Element))[0];
	}
}

rule("Add. target attacker")
{
	event
	{
		Player Took Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Master[0] == Event Player;
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Is Alive(Event Player) == True;
		Is Alive(Attacker) == True;
		Attacker.StealthTime[0] == 0;
		Random Real(0, 1) < Event Damage / Max Health(Event Player) * Normalized Health(Event Player.Target);
	}

	actions
	{
		Event Player.Target = Attacker;
	}
}

rule("Add. enter state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Idle");
		Event Player.Target != Null;
		Distance Between(Event Player, Event Player.Target) < 25;
		(Distance Between(Event Player, Event Player.Target) < 15 && Ultimate Charge Percent(Event Player) == 100) == False;
		(Hero Of(Event Player) != Hero(Tracer) || Is In View Angle(Event Player, Eye Position(Event Player.Target), 35)) == True;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Event Player.State = Custom String("Shoot");
	}
}

rule("Add. enter state: idle")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
		Distance Between(Event Player, Event Player.Target) > 25;
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Event Player.State = Custom String("Idle");
	}
}

rule("Add. on exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Master[1] == Null;
		Event Player.State != Custom String("Shoot");
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Primary Fire));
		Stop Holding Button(Event Player, Button(Secondary Fire));
	}
}

rule("Add. clear target")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Target != Null;
		Array Contains(Filtered Array(All Living Players(Team 1), Current Array Element.StealthTime[0] == 0), Event Player.Target)
			== False;
	}

	actions
	{
		Event Player.Target = Null;
	}
}

rule("Add. has target")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
	}

	actions
	{
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.Target)), Array(12.600, 720,
			Is Firing Primary(Event Player) ? 12.600 : 35)[Index Of Array Value(Array(Hero(Wrecking Ball), Hero(Zenyatta), Hero(Tracer)),
			Hero Of(Event Player))], To World, Direction and Turn Rate);
	}
}

rule("Add. has no target")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Target == Null;
		Array Contains(Array(Custom String("Shoot"), Custom String("Ult")), Event Player.State) == True;
		Event Player.State != Custom String("Idle");
	}

	actions
	{
		Stop Facing(Event Player);
		Stop Forcing Throttle(Event Player);
		Event Player.State = Custom String("Idle");
	}
}

rule("Add. move forward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) > 15;
	}

	actions
	{
		Start Forcing Throttle(Event Player, 1, 1, 0, 0, 0, 1);
		Log To Inspector(Custom String("start moving forward"));
	}
}

disabled rule("EXPLODER")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Exploder Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.State == Custom String("IndividualSetup");
	}

	actions
	{
		"160 dps at level 17 (expected BossLevel for phase 2 on hard difficulty)"
		Event Player.FlameTornadoDamage = 160 / 0.500;
		"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
		Event Player.TotalHPUnits = Event Player.HealthScale * (180 + 54 * (Event Player.Level - 1)) / Global.BossCount / 25;
		"50% damage at level 17 (expected BossLevel for phase 2 on hard difficulty)"
		Event Player.BaseDamageMultiplier = 0.500 / (17 + 4) / 2.200 * (11 + 2.200 * (Event Player.Level - 1));
		Call Subroutine(UpdateStats);
		Event Player.BaseMoveSpeedModifier = 55;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Start Scaling Player(Event Player, 0.400, False);
		Teleport(Event Player, Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0));
		Set Max Ammo(Event Player, 0, Round To Integer(Event Player.Level, To Nearest) + 3);
		Event Player.Name = Random Value In Array(Remove From Array(Global.BallNames, Mapped Array(All Players(Team 2),
			Current Array Element.Name)));
		If(Event Player.Name == Null);
			Event Player.Name = Random Value In Array(Global.BallNames);
		End;
		Start Forcing Dummy Bot Name(Event Player, Event Player.Name);
		Event Player.State = Custom String("Idle");
	}
}

rule("Exploder go into ball form")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Idle");
		Is In Alternate Form(Event Player) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Ability 1));
		Wait Until(Is In Alternate Form(Event Player), 3);
		Stop Holding Button(Event Player, Button(Ability 1));
		Wait(0.500, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Exploder on enter state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Exploder jump")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Is On Ground(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
		Magnitude Of(Throttle Of(Event Player)) > 0.200;
	}

	actions
	{
		Press Button(Event Player, Button(Jump));
	}
}

rule("Exploder stop moving forward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 4.500;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		Log To Inspector(Custom String("exploder stop throttle"));
	}
}

disabled rule("GOLEM")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Golem Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.State == Custom String("IndividualSetup");
	}

	actions
	{
		"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
		Event Player.TotalHPUnits = Event Player.HealthScale * (1615 + 485 * (Event Player.Level - 1)) / Global.BossCount / 25;
		Event Player.BaseDamageMultiplier = (35 + 7 * (Event Player.Level - 1)) * 0.600 / 48;
		Call Subroutine(UpdateStats);
		Start Scaling Player(Event Player, 1.150, False);
		Teleport(Event Player, Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0));
		Set Max Ammo(Event Player, 0, 1);
		Event Player.Name = Random Value In Array(Remove From Array(Global.ZenyattaNames, Mapped Array(All Players(Team 2),
			Current Array Element.Name)));
		If(Event Player.Name == Null);
			Event Player.Name = Random Value In Array(Global.ZenyattaNames);
		End;
		Start Forcing Dummy Bot Name(Event Player, Event Player.Name);
		Event Player.State = Custom String("Idle");
	}
}

rule("Golem stop moving forward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 11;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		Log To Inspector(Custom String("golem stop throttle"));
	}
}

rule("Golem slow")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 60;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Golem normal speed")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
		Is Firing Secondary(Event Player) == False;
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Golem fast")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Idle");
	}

	actions
	{
		Event Player.BaseMoveSpeedModifier = 170;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("On enter state: shoot (Golem)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Zenyatta;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
	}

	actions
	{
		Wait(0.250, Abort When False);
		Start Holding Button(Event Player, Button(Secondary Fire));
	}
}

disabled rule("WISP")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Wisp Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Event Player.State == Custom String("IndividualSetup");
	}

	actions
	{
		"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
		Event Player.TotalHPUnits = Event Player.HealthScale * (850 + 255 * (Event Player.Level - 1)) / Global.BossCount / 25;
		"40% damage at level 17 (expected BossLevel for phase 2 on hard difficulty)"
		Event Player.BaseDamageMultiplier = 0.400 / (17 + 4) / 3 * (15 + 3 * (Event Player.Level - 1));
		Call Subroutine(UpdateStats);
		Set Jump Enabled(Event Player, False);
		Start Scaling Player(Event Player, 1.150, False);
		Teleport(Event Player, Random Real(25, 60) * Direction From Angles(Random Integer(-179, 0), 0) + Random Real(10, 13) * Up);
		If(Global.TestMode);
			disabled Create HUD Text(Global.Phase == 2 ? All Players(All Teams) : Null, Slot Of(Event Player), Null, Custom String(
				"State: {0} \n{1} \nHorizontal Distance: {2}", Event Player.State, Event Player.State == Custom String("Idle") ? Custom String(
				"Altitude: {0}", Y Component Of(Position Of(Event Player))) : Custom String("Angle: {0}", Vertical Angle Towards(
				Event Player.Target, Event Player)), Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(
				X Component Of(Current Array Element), 0, Z Component Of(Current Array Element))))), Left, 0, Color(White), Color(White),
				Color(White), Visible To and String, Default Visibility);
		End;
		Event Player.Name = Random Value In Array(Remove From Array(Global.TracerNames, Mapped Array(All Players(Team 2),
			Current Array Element.Name)));
		If(Event Player.Name == Null);
			Event Player.Name = Random Value In Array(Global.TracerNames);
		End;
		Start Forcing Dummy Bot Name(Event Player, Event Player.Name);
		Event Player.State = Custom String("Idle");
	}
}

rule("Wisp gravity on")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) > 50;
	}

	actions
	{
		Set Gravity(Event Player, 100);
	}
}

rule("Wisp gravity off")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < 25;
	}

	actions
	{
		Set Gravity(Event Player, 0);
	}
}

rule("Wisp on enter state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Shoot");
	}

	actions
	{
		Wait(2, Abort When False);
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Wisp exit state: shoot")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Target != Null;
		Event Player.State == Custom String("Shoot");
		Is In View Angle(Event Player, Eye Position(Event Player.Target), 35) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Event Player.State = Custom String("Idle");
	}
}

rule("Wisp is shooting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		If(Magnitude Of(Event Player.WispAcceleration));
			Event Player.WispAcceleration = 4 * Normalize(Event Player.WispAcceleration);
		End;
		Event Player.BaseMoveSpeedModifier = 40;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Wisp is not shooting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		Is Firing Primary(Event Player) == False;
	}

	actions
	{
		If(Magnitude Of(Event Player.WispAcceleration));
			Event Player.WispAcceleration = 10 * Normalize(Event Player.WispAcceleration);
		End;
		"Was 115, but nerfed slightly to make them grouping up take longer"
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
	}
}

rule("Wisp descent")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Jump)) == False;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.WispAcceleration = Down * (Is Firing Primary(Event Player) ? 4 : 10);
	}
}

rule("Wisp ascent")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Crouch)) == False;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.WispAcceleration = Up * (Is Firing Primary(Event Player) ? 4 : 10);
	}
}

rule("Wisp enter state: ult")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Array Contains(Array(Custom String("Idle"), Custom String("Shoot")), Event Player.State) == True;
		Event Player.Target != Null;
		Distance Between(Event Player, Event Player.Target) < 15;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Event Player.State = Custom String("Ult");
	}
}

rule("Wisp on enter state: ult")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.State == Custom String("Ult");
	}

	actions
	{
		Start Holding Button(Event Player, Button(Ultimate));
		Wait Until(Ultimate Charge Percent(Event Player) < 50, 5);
		Stop Holding Button(Event Player, Button(Ultimate));
		Wait Until(!Is Using Ultimate(Event Player), 5);
		Event Player.State = Custom String("Idle");
	}
}

rule("Wisp move backward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(Current Array Element), 0,
			Z Component Of(Current Array Element)))) < 6;
	}

	actions
	{
		Start Forcing Throttle(Event Player, 0, 0, 1, 1, 0, 1);
		Log To Inspector(Custom String("wisp move back"));
	}
}

rule("Wisp stop moving forward/backward")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		Event Player.Target != Null;
		"Min: 10.5 - 2.5 = 8, Max: 10.5 + 2.5 = 13"
		Absolute Value(Magnitude Of(Mapped Array(Vector Towards(Event Player, Event Player.Target), Vector(X Component Of(
			Current Array Element), 0, Z Component Of(Current Array Element)))) - 10.500) < 2.500;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		Log To Inspector(Custom String("wisp stop throttle"));
	}
}

rule("Start accelerating")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Magnitude Of(Event Player.WispAcceleration) + Event Player.WallAcceleration > 0;
	}

	actions
	{
		Start Accelerating(Event Player, Event Player.WispAcceleration - Event Player.WallAcceleration * Direction From Angles(
			Horizontal Angle From Direction(Position Of(Event Player)), 0), Magnitude Of(
			Event Player.WispAcceleration - Event Player.WallAcceleration * Direction From Angles(Horizontal Angle From Direction(
			Position Of(Event Player)), 0)), 60, To World, Direction Rate and Max Speed);
	}
}

rule("Stop accelerating")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Magnitude Of(Event Player.WispAcceleration) + Event Player.WallAcceleration == 0;
	}

	actions
	{
		Stop Accelerating(Event Player);
	}
}

rule("Inwards")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 1 > Global.ArenaRadius;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, WallAcceleration, (Is On Ground(Event Player) ? 400 : 0) + Max(0,
			18 * Speed Of In Direction(Event Player, Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 81 * (
			Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player)) * Up) + 1 - Global.ArenaRadius)),
			1000000000, Destination and Rate);
		Start Throttle In Direction(Event Player, Direction Towards(Event Player, Vector(0, 0, 0)), 2 * Max(0, Dot Product(World Vector Of(
			Throttle Of(Event Player), Event Player, Rotation), Direction From Angles(Horizontal Angle From Direction(Position Of(
			Event Player)), 0))), To World, Add to existing throttle, Direction and Magnitude);
	}
}

rule("Not Inwards")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Global.State == Custom String("BossFight") && Magnitude Of(Position Of(Event Player) - Y Component Of(Position Of(Event Player))
			* Up) + 1 > Global.ArenaRadius) == False;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, WallAcceleration);
		Event Player.WallAcceleration = 0;
		Stop Throttle In Direction(Event Player);
	}
}

rule("Wisp stop accelerating")
{
	event
	{
		Ongoing - Each Player;
		All;
		Tracer;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == False;
		Is Button Held(Event Player, Button(Jump)) == False;
	}

	actions
	{
		Event Player.WispAcceleration = Vector(0, 0, 0);
	}
}

rule("Wisp ascend")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		((Event Player.State == Custom String("Idle") ? Y Component Of(Position Of(Event Player)) < 15 : Vertical Angle Towards(
			Event Player.Target, Event Player) > 0) || ((Event Player.State == Custom String("Idle") ? Y Component Of(Position Of(
			Event Player)) < 20 : Vertical Angle Towards(Event Player.Target, Event Player) > -35) && Vertical Speed Of(Event Player)
			< -1)) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Jump));
		Log To Inspector(Custom String("ascend"));
	}
}

rule("Wisp stop ascending")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		(Event Player.State == Custom String("Idle") ? Y Component Of(Position Of(Event Player)) > 20 : Vertical Angle Towards(
			Event Player.Target, Event Player) < 10) == True;
		Vertical Speed Of(Event Player) > -1;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Jump));
		Log To Inspector(Custom String("stop ascend"));
	}
}

rule("Wisp descend")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		((Event Player.State == Custom String("Idle") ? Y Component Of(Position Of(Event Player)) > 25 : Vertical Angle Towards(
			Event Player.Target, Event Player) < -50) || ((Event Player.State == Custom String("Idle") ? Y Component Of(Position Of(
			Event Player)) > 20 : Vertical Angle Towards(Event Player.Target, Event Player) < 10) && Vertical Speed Of(Event Player) > 1))
			== True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Crouch));
		Log To Inspector(Custom String("descend"));
	}
}

rule("Wisp stop descending")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Event Player.Master[1] == Null;
		(Event Player.State == Custom String("Idle") ? Y Component Of(Position Of(Event Player)) < 20 : Vertical Angle Towards(
			Event Player.Target, Event Player) > -35) == True;
		Vertical Speed Of(Event Player) < 1;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Crouch));
		Log To Inspector(Custom String("stop descend"));
	}
}

disabled rule("PHASE 3")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Phase 3 Start")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 3;
	}

	actions
	{
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 100;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Stop Chasing Player Variable(Event Player, TakeoffCooldown);
		Event Player.CanNeedle = Array(False, False);
		Call Subroutine(SetCoefficient);
		"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
		Event Player.TotalHPUnits = Event Player.HealthScale * (1000 + 300 * (Event Player.Level - 1)) * (1 + Global.DifficultyCoefficient)
			* Square Root(Count Of(Filtered Array(Global.Heroes, Is Alive(Current Array Element)))) / Global.BossCount / 25;
		Event Player.BaseDamageMultiplier = 2 * (16 + 3.200 * (Event Player.Level - 1)) * 0.600 / 85;
		Event Player.BaseRegen = 15 / Event Player.HealthScale * (5 + (Event Player.Level - 1)) / 24;
		Call Subroutine(UpdateStats);
		Event Player.ShowBossBar = True;
		Event Player.State = Custom String("Landing");
	}
}

rule("Pizza Time")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.PizzaIndex == Custom String("Soon");
		Event Player.PizzaTime[0] != Null;
		Total Time Elapsed > Event Player.PizzaTime[0];
	}

	actions
	{
		If(Array Contains(Array(Custom String("Idle"), Custom String("ClosingIn")), Event Player.State) && Ultimate Charge Percent(
			Event Player) > 95 && !Has Status(Event Player, Stunned));
			Event Player.State = Custom String("Pizza");
		Else;
			Event Player.PizzaIndex = Custom String("ASAP");
		End;
		Event Player.PizzaTime[0] = Null;
	}
}

rule("On Enter State: Pizza")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Array Contains(Array(Custom String("Pizza"), Custom String("PizzaDamage"), Custom String("PizzaWait")), Event Player.State)
			== True;
		Event Player.HasLostThisPhase == False;
	}

	actions
	{
		Event Player.CanSwing = False;
		Event Player.CanSlam = False;
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Start Holding Button(Event Player, Button(Crouch));
		For Player Variable(Event Player, PizzaIndex, 0, 5, 1);
			Abort If Condition Is False;
			Event Player.State = Custom String("Pizza");
			Chase Player Variable At Rate(Event Player, PizzaAngle, Event Player.PizzaAngle + 10 * Event Player.PizzaAngularVelocity,
				Absolute Value(Event Player.PizzaAngularVelocity), Destination and Rate);
			Event Player.PizzaTime[1] = 99999;
			Event Player.PizzaAngularVelocity = Random Value In Array(Array(1, -1)) * 50;
			Event Player.PizzaAngle = Random Integer(0, 180);
			Wait(0.700, Abort When False);
			Event Player.PizzaTime[1] = Total Time Elapsed;
			Stop Chasing Player Variable(Event Player, PizzaAngle);
			"doesn't dynamically update with NumDeathLines"
			Event Player.Victims = Remove From Array(Filtered Array(All Living Players(Team 1), Absolute Value(Cosine From Degrees(
				Event Player.PizzaAngle) * X Component Of(Vector Towards(Current Array Element, Event Player)) - Sine From Degrees(
				Event Player.PizzaAngle) * Z Component Of(Vector Towards(Current Array Element, Event Player)))
				< Global.DeathLineRadius || Absolute Value(Cosine From Degrees(Event Player.PizzaAngle + 45) * X Component Of(Vector Towards(
				Current Array Element, Event Player)) - Sine From Degrees(Event Player.PizzaAngle + 45) * Z Component Of(Vector Towards(
				Current Array Element, Event Player))) < Global.DeathLineRadius || Absolute Value(Cosine From Degrees(
				Event Player.PizzaAngle + 90) * X Component Of(Vector Towards(Current Array Element, Event Player)) - Sine From Degrees(
				Event Player.PizzaAngle + 90) * Z Component Of(Vector Towards(Current Array Element, Event Player)))
				< Global.DeathLineRadius || Absolute Value(Cosine From Degrees(Event Player.PizzaAngle + 135) * X Component Of(Vector Towards(
				Current Array Element, Event Player)) - Sine From Degrees(Event Player.PizzaAngle + 135) * Z Component Of(Vector Towards(
				Current Array Element, Event Player))) < Global.DeathLineRadius), Global.NullPlayer);
			Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Event Player, 100);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Sound, Color(White), Event Player, 100);
			Damage(Event Player.Victims, Event Player, 382.500);
			"Make sure that the cripple doesn't apply before the pizza damage"
			Modify Player Variable(Event Player.Victims, CrippleTime, Max, 3);
			Event Player.State = Custom String("PizzaDamage");
			Wait(0.200, Ignore Condition);
			Event Player.State = Custom String("PizzaWait");
			Wait(1.200, Abort When False);
		End;
		Event Player.PizzaIndex = Custom String("Dormant");
		Stop Holding Button(Event Player, Button(Crouch));
		Chase Player Variable At Rate(Event Player, TakeoffCooldown, 0, 1, None);
		Call Subroutine(ChooseState);
	}
}

rule("Destroy Flame Pillar")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Global.FlamePillars) > 0;
		Total Time Elapsed > Global.FlamePillarExpirationTimes[0];
	}

	actions
	{
		Destroy Effect(Global.FlamePillars[0]);
		Modify Global Variable(FlamePillarPositions, Remove From Array By Index, 0);
		Modify Global Variable(FlamePillarExpirationTimes, Remove From Array By Index, 0);
		Modify Global Variable(FlamePillars, Remove From Array By Index, 0);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Flame Pillar Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is True For Any(Global.FlamePillarPositions, Distance Between(Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(
			Position Of(Event Player))), Vector(X Component Of(Current Array Element), 0, Z Component Of(Current Array Element))) < 1)
			== True;
	}

	actions
	{
		Set Status(Event Player, Global.NullPlayer[1], Burning, 0.250);
		Damage(Event Player, Global.NullPlayer[1], 42.500 * Global.Bosses[0].BaseDamageMultiplier);
		Wait(0.200, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Slam cripples")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 3;
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Modify Player Variable(Victim, CrippleTime, Max, 3);
	}
}

disabled rule("PHASE 4")
{
	event
	{
		Ongoing - Global;
	}
}

rule("On Enter Phase: 4 (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 4;
	}

	actions
	{
		Call Subroutine(SetCoefficient);
		disabled Wait(5, Ignore Condition);
		disabled Global.FlamePillarExpirationTimes = Mapped Array(Global.FlamePillarExpirationTimes, Total Time Elapsed);
	}
}

rule("On Enter Phase: 4 (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 4;
	}

	actions
	{
		Event Player.HasLostThisPhase = False;
		Event Player.CanTakeOff = False;
		Event Player.BaseMoveSpeedModifier = 50;
		Start Rule(UpdateMoveSpeed, Restart Rule);
		Event Player.CanNeedle = Array(True, False);
		Clear Status(Event Player, Unkillable);
		Teleport(Event Player, Vector(0, 0, 0));
		"Add Armour Boost"
		Event Player.ArmourModifiers[1] = 200;
		Start Rule(UpdateArmour, Restart Rule);
		"OW HP = 0.6 * RoR2 HP, all Team 2 HP is / 2.4"
		Event Player.TotalHPUnits = Event Player.HealthScale * (1400 + 420 * (Event Player.Level - 1)) / Global.BossCount / 25;
		Event Player.BaseDamageMultiplier = 2 * (16 + 3.200 * (Event Player.Level - 1)) * 0.600 / 85;
		Event Player.BaseRegen = 15 / Event Player.HealthScale * (5 + (Event Player.Level - 1)) / 24;
		Call Subroutine(UpdateStats);
		Set Invisible(Event Player, None);
		Event Player.PizzaIndex = Custom String("Dormant");
		Wait(5.750, Abort When False);
		Start Holding Button(Event Player, Button(Crouch));
		Wait(0.250, Abort When False);
		Disallow Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Crouch));
		Event Player.CanUseOrbs = False;
		Event Player.ShowBossBar = True;
		Event Player.State = Custom String("Stealing");
	}
}

rule("On Enter State: Stealing (Global)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Phase == 4;
		Is True For All(Global.Bosses, Current Array Element.State == Custom String("Stealing")) == True;
	}

	actions
	{
		Global.Stealees = Filtered Array(Global.Heroes, !Current Array Element.IsDead);
		While(Count Of(Global.Stealees) > 0);
			Global.Stealer = Global.Bosses[Global.BossIndex];
			Global.CurrentStealee = Global.Stealees[Global.StealeeIndex];
			If(Count Of(Global.CurrentStealee.ItemStacks) == 0);
				Modify Global Variable(Stealees, Remove From Array By Index, Global.StealeeIndex);
			Else;
				Global.ItemStackBeingStolenIndex = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
					Global.ItemStacks[Current Array Element] == Global.CurrentStealee.ItemStacks[0] && Global.ItemStackOwners[Current Array Element] == Global.CurrentStealee);
				If(Count Of(Global.ItemStackBeingStolenIndex) == 0);
					Small Message(Host Player, Custom String("Item Steal Error"));
					Modify Global Variable(Stealees, Remove From Array By Index, Global.StealeeIndex);
				Else;
					Global.ItemStackBeingStolenIndex = Global.ItemStackBeingStolenIndex[0];
					Call Subroutine(Steal);
					Global.StealeeIndex += 1;
				End;
				Global.BossIndex = (Global.BossIndex + 1) % Count Of(Global.Bosses);
			End;
			Global.StealeeIndex %= Count Of(Global.Stealees);
			Wait(0.250, Abort When False);
		End;
		Wait Until(Is True For All(Global.ItemStackNewOwners, Current Array Element == Null), 99999);
		Global.Bosses.State = Custom String("StealingFinished");
	}
}

rule("On Enter State: Stealing Finished")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("StealingFinished");
	}

	actions
	{
		Event Player.HealthPerItemStack = Max Health(Event Player) / (Count Of(Event Player.ItemStackReturnInfo) / 2);
		Clear Status(Event Player, Phased Out);
		Allow Button(Event Player, Button(Crouch));
		Start Holding Button(Event Player, Button(Crouch));
		Wait(4, Abort When False);
		Disallow Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1, Abort When False);
		Allow Button(Event Player, Button(Crouch));
		"Remove Armour Boost (as late as possible)"
		Event Player.ArmourModifiers[1] = 0;
		Start Rule(UpdateArmour, Restart Rule);
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("Enter State: Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 4;
		Event Player.CanUseOrbs == True;
		Event Player.State == Custom String("Idle");
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Event Player.State = Custom String("Orbs");
	}
}

rule("On Enter State: Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.State == Custom String("Orbs");
	}

	actions
	{
		Start Facing(Event Player, Vector(0, -1, 1), 120, To Player, None);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Start Holding Button(Event Player, Button(Crouch));
		Wait(1.500, Abort When False);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 100);
		Damage(Event Player, Global.NullPlayer[0], 0.080 * Health(Event Player));
		"May want to do more to ensure two bosses simultaneously creating orbs doesn't break this"
		For Player Variable(Event Player, OrbCreationIndex, 0, 8, 1);
			Modify Global Variable(OrbCreators, Append To Array, Event Player);
			Wait(0.016, Ignore Condition);
			Event Player.NewOrbGlobalIndex = Last Of(Remove From Array(Mapped Array(Global.OrbCreators,
				Current Array Element == Event Player ? Current Array Index : -1), -1));
			Global.OrbInitialAngles[Event Player.NewOrbGlobalIndex] = Horizontal Facing Angle Of(Event Player) + (
				0.500 - Event Player.OrbCreationIndex) * 45;
			Global.OrbCreationTimes[Event Player.NewOrbGlobalIndex] = Total Time Elapsed;
			Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex] = Mapped Array(Position Of(Event Player),
				Current Array Element - Y Component Of(Current Array Element) * Up)[0];
			Global.OrbPositions[Event Player.NewOrbGlobalIndex] = Global.OrbInitialPositions[Event Player.NewOrbGlobalIndex];
			Create Effect(All Players(All Teams), Sphere, Color(Sky Blue), Global.OrbPositions[Evaluate Once(Event Player.NewOrbGlobalIndex)],
				1, Visible To Position and Radius);
			Global.OrbEffects[Event Player.NewOrbGlobalIndex] = Last Created Entity;
			Create Effect(All Players(All Teams), Orisa Amplifier Sound, Color(White), Global.OrbPositions[Evaluate Once(
				Event Player.NewOrbGlobalIndex)], 100, Visible To Position and Radius);
			Global.OrbSounds[Event Player.NewOrbGlobalIndex] = Last Created Entity;
		End;
		Stop Facing(Event Player);
		Wait(4, Abort When False);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(1, Abort When False);
		Event Player.State = Custom String("BecomingIdle");
	}
}

rule("Orb Loop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For Any(Global.OrbPositions, Current Array Element != Null) == True;
	}

	actions
	{
		For Global Variable(OrbEvaluationIndex, 0, Count Of(Global.OrbPositions), 1);
			Wait(0.016, Ignore Condition);
			Call Subroutine(HandleOrb);
			Global.OrbPositions = Mapped Array(Mapped Array(Global.OrbCreationTimes, Total Time Elapsed - Current Array Element),
				Global.OrbPositions[Current Array Index] ? Global.OrbInitialPositions[Current Array Index] + 50 * Square Root(3.250 / (
				1 + Absolute Value(1.500 * Sine From Radians(0.524 * Current Array Element)) ^ 2)) * Sine From Radians(
				0.524 * Current Array Element) * Direction From Angles(
				Global.OrbInitialAngles[Current Array Index] - 22.500 * Current Array Element, 0) : Null);
		End;
		Loop If Condition Is True;
	}
}

rule("Destroy Orb")
{
	event
	{
		Subroutine;
		DestroyOrb;
	}

	actions
	{
		"Don't set effect to null, to ensure this is definitely destroyed."
		Destroy Effect(Global.OrbEffects[Global.OrbEvaluationIndex]);
		Destroy Effect(Global.OrbSounds[Global.OrbEvaluationIndex]);
		Global.OrbPositions[Global.OrbEvaluationIndex] = Null;
	}
}

rule("Enable Orbs")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Normalized Health(Event Player) < 0.900;
	}

	actions
	{
		If(Global.Phase == 4);
			Event Player.CanUseOrbs = True;
		End;
	}
}

rule("Return Items")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.HealthPerItemStack > 0;
		Count Of(Event Player.ItemStackReturnInfo) > 0;
		(Is Dead(Event Player) || Event Player.Phase4DamageReceived >= (Event Player.NumberOfStacksReturned + 1)
			* Event Player.HealthPerItemStack) == True;
	}

	actions
	{
		Play Effect(Event Player, Moira Fade Disappear Sound, Color(White), Event Player, 100);
		Play Effect(Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex], Moira Fade Reappear Sound, Color(White),
			Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex], 100);
		While(True);
			Abort If Condition Is False;
			Event Player.StackBeingReturnedIndex = Event Player.ItemStackReturnInfo[0];
			Event Player.RemainingMatchingStacks = Filtered Array(Mapped Array(Global.ItemStacks, Current Array Index),
				Global.ItemStacks[Current Array Element] == Global.ItemStacks[Event Player.StackBeingReturnedIndex] && Global.ItemStackOwners[Current Array Element] == Event Player);
			Global.ItemStackOwners[Event Player.StackBeingReturnedIndex] = Null;
			If(Count Of(Event Player.RemainingMatchingStacks) == 1);
				Modify Player Variable(Event Player, ItemStacks, Remove From Array By Value,
					Global.ItemStacks[Event Player.StackBeingReturnedIndex]);
				Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingReturnedIndex, 2,
					-1 * Global.ItemStackSizes[Event Player.StackBeingReturnedIndex]));
			Else;
				Event Player.StackBeingDepletedIndex = Filtered Array(Event Player.RemainingMatchingStacks,
					Global.ItemStackSizes[Current Array Element] > 0)[0];
				If(Event Player.StackBeingReturnedIndex == Event Player.StackBeingDepletedIndex);
					Global.ItemStackSizes[Remove From Array(Event Player.RemainingMatchingStacks, Event Player.StackBeingDepletedIndex)
						[0]] += Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] - Event Player.ItemStackReturnInfo[1];
					Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] = Event Player.ItemStackReturnInfo[1];
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingReturnedIndex, 2,
						-1 * Event Player.ItemStackReturnInfo[1]));
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Remove From Array(Event Player.RemainingMatchingStacks,
						Event Player.StackBeingDepletedIndex)[0], 1, Global.ItemStackSizes[Remove From Array(Event Player.RemainingMatchingStacks,
						Event Player.StackBeingDepletedIndex)[0]]));
				Else;
					Global.ItemStackSizes[Event Player.StackBeingDepletedIndex] -= Event Player.ItemStackReturnInfo[1];
					Global.ItemStackSizes[Event Player.StackBeingReturnedIndex] += Event Player.ItemStackReturnInfo[1];
					Modify Global Variable(ItemStackUpdateInfos, Append To Array, Array(Event Player.StackBeingDepletedIndex, 0,
						-1 * Event Player.ItemStackReturnInfo[1]));
				End;
			End;
			Global.ItemStackNewOwners[Event Player.StackBeingReturnedIndex] = Global.ItemStackOriginalOwners[Event Player.StackBeingReturnedIndex];
			Event Player.NumberOfStacksReturned += 1;
			Modify Player Variable(Event Player, ItemStackReturnInfo, Remove From Array By Index, 0);
			Modify Player Variable(Event Player, ItemStackReturnInfo, Remove From Array By Index, 0);
			Wait(0.100, Abort When False);
		End;
	}
}

rule("Handle Orb")
{
	event
	{
		Subroutine;
		HandleOrb;
	}

	actions
	{
		Abort If(Global.OrbPositions[Global.OrbEvaluationIndex] == Null);
		Global.OrbVictims = Remove From Array(Filtered Array(All Living Players(Team 1), Distance Between(Current Array Element,
			Global.OrbPositions[Global.OrbEvaluationIndex]) < 1), Global.NullPlayer);
		If(Count Of(Global.OrbVictims) > 0);
			Damage(Global.OrbVictims, Global.OrbCreators[Global.OrbEvaluationIndex], 170);
			"Don't set effect to null, to ensure this is definitely destroyed."
			Call Subroutine(DestroyOrb);
		Else If(Total Time Elapsed > Global.OrbCreationTimes[Global.OrbEvaluationIndex] + 9);
			"Don't set effect to null, to ensure this is definitely destroyed."
			Call Subroutine(DestroyOrb);
		End;
	}
}

disabled rule("PHASE X")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Player Died")
{
	event
	{
		Player Died;
		All;
		All;
	}

	actions
	{
		Event Player.BoomTime[0] = 0;
		Call Subroutine(CleanseAllDebuffs);
		Event Player.WispAcceleration = Vector(0, 0, 0);
		Event Player.Target = Null;
		If(Is True For Any(Global.ItemStackSizes, Current Array Element > 0 && Global.ItemStacks[Current Array Index] == Custom String(
			"Extra Life") && Global.ItemStackOwners[Current Array Index] == Event Player));
			If(Team Of(Event Player) != Team 2);
				Global.ItemStackSizes[Filtered Array(Mapped Array(Global.ItemStackSizes, Current Array Index),
					Global.ItemStackSizes[Current Array Element] > 0 && Global.ItemStacks[Current Array Element] == Custom String("Extra Life")
					&& Global.ItemStackOwners[Current Array Element] == Event Player)[0]] -= 1;
			End;
			Wait(2, Ignore Condition);
			Resurrect(Event Player);
			Set Status(Event Player, Null, Invincible, 3);
		Else;
			Event Player.IsDead = True;
		End;
	}
}

rule("Player Is Alive")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Event Player.IsDead == True;
	}

	actions
	{
		Event Player.IsDead = False;
	}
}

rule("Add. Died")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.Master[0] == Event Player;
		Event Player.CouldBeHumanPlayer == False;
		Event Player.IsDead == True;
	}

	actions
	{
		If(Hero Of(Event Player) == Hero(Wrecking Ball));
			Event Player.FlameTornadoPosition = Position Of(Event Player);
			Event Player.FlameTornadoExpirationTime = Total Time Elapsed + 7;
			Create Effect(All Players(All Teams), Ring, Color(Sky Blue), Event Player.FlameTornadoPosition, 5, Visible To);
			Event Player.FlameTornado = Last Created Entity;
		End;
		Wait(9, Ignore Condition);
		Call Subroutine(DestroyMe);
	}
}

rule("Boss Died")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.IsDead == True;
	}

	actions
	{
		Event Player.ShowBossBar = False;
		Event Player.HasLostThisPhase = True;
		Play Effect(All Players(All Teams), Sombra EMP Explosion Sound, Color(White), Event Player, 100);
	}
}

rule("Ramattra Bot Boss Gone")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ramattra;
	}

	conditions
	{
		Event Player.Master[0] != Null;
		(!Array Contains(Filtered Array(All Players(Team 2), !Current Array Element.IsDead), Event Player.Master[0]) || Is Match Complete)
			== True;
	}

	actions
	{
		Call Subroutine(DestroyMe);
	}
}

rule("Hide Null Players from victory screen")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Match Complete == True;
		Array Contains(Global.NullPlayer, Event Player) == True;
	}

	actions
	{
		Call Subroutine(DestroyMe);
	}
}

rule("All Bosses Gone")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Is True For All(Global.Bosses, Current Array Element.IsDead) == True;
	}

	actions
	{
		Global.State = Custom String("PlayerVictory");
		Global.Phase = Custom String("X");
		If(Current Game Mode == Game Mode(Skirmish));
			Declare Team Victory(Team 1);
		End;
	}
}

rule("All Heroes Gone")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.State == Custom String("BossFight");
		Is True For All(Global.Heroes, Current Array Element.IsDead) == True;
	}

	actions
	{
		If(Current Game Mode == Game Mode(Skirmish));
			Declare Team Victory(Team 2);
		End;
	}
}

rule("Choose State (Closing In / Becoming Idle)")
{
	event
	{
		Subroutine;
		ChooseState;
	}

	actions
	{
		If(Event Player.PizzaIndex == Custom String("Dormant") && Is True For Any(All Living Players(Team 1), Distance Between(
			Event Player, Current Array Element) < 6));
			Event Player.State = Custom String("BecomingIdle");
		Else;
			Event Player.State = Custom String("ClosingIn");
		End;
	}
}

rule("Cleanse some debuffs")
{
	event
	{
		Subroutine;
		CleanseSomeDebuffs;
	}

	actions
	{
		Event Player.CrippleTime = 0;
		Event Player.SlowTime = 0;
	}
}

rule("Cleanse all debuffs")
{
	event
	{
		Subroutine;
		CleanseAllDebuffs;
	}

	actions
	{
		Call Subroutine(CleanseSomeDebuffs);
		Event Player.BleedTime = 0;
		Event Player.APTime = 0;
		Event Player.RecoveryTime = 0;
		Event Player.ArmourPiercingStacks[1] = 0;
		Event Player.ArmourModifiers[5] = 0;
		Start Rule(UpdateArmour, Restart Rule);
	}
}

rule("On enter Phase 2 (Boss)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 2;
		(Event Player.Target && Is Alive(Event Player.Target)) == False;
	}

	actions
	{
		Wait(2, Abort When False);
		Event Player.Target = Random Value In Array(Remove From Array(Filtered Array(All Living Players(Team 2),
			Current Array Element.Master[0] == Current Array Element && !Current Array Element.CouldBeHumanPlayer), Global.NullPlayer));
	}
}

rule("Boss spectate")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.Phase == 2;
		Event Player.Target != Null;
	}

	actions
	{
		Start Camera(Event Player, Eye Position(Event Player.Target) + World Vector Of(Right, Event Player.Target, Rotation), Eye Position(
			Event Player.Target) + World Vector Of(Right, Event Player.Target, Rotation) + 5 * Facing Direction Of(Event Player.Target),
			60);
	}
}

rule("Stop Phase 2 camera")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Global.Phase == 2 && Event Player.Target) == False;
	}

	actions
	{
		Stop Camera(Event Player);
	}
}