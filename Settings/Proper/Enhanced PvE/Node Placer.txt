variables
{
	global:
		0: Nodes
		1: EdgeStart
		2: EdgeModifyMode
		3: Edges
		5: NodeToDestroy
		6: NodeEffects
		7: NodeLabels
		8: NewNodeIndex
		9: NewEdgeIndex
		10: EdgeEffects
		11: EdgesToDestroy
		19: OneWay
		20: EdgeToDestroy
		21: EdgeDirectionEffects

	player:
		0: Path
		1: Queue
		2: VisitedNodes
		3: PathStart
		4: CurrentNode
		5: DestinationNode
		6: Neighbours
		7: NearestNode
}

subroutines
{
	0: BFS
	1: SetNearestNode
	2: DrawNode
	3: DrawEdge
	4: DrawExisting
	5: InitializeNodesAndEdges
}

rule("Global Setup")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.Nodes = Empty Array;
		Global.Edges = Empty Array;
		Create HUD Text(All Players(All Teams), Custom String("One Way: {0}", Global.OneWay), Null, Null, Left, 0, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Call Subroutine(InitializeNodesAndEdges);
		Call Subroutine(DrawExisting);
	}
}

rule("Initialize Nodes & Edges")
{
	event
	{
		Subroutine;
		InitializeNodesAndEdges;
	}
}

rule("Set Nearest Node")
{
	event
	{
		Subroutine;
		SetNearestNode;
	}

	actions
	{
		Event Player.NearestNode = Mapped Array(Global.Nodes, Current Array Index);
		Event Player.NearestNode = Filtered Array(Event Player.NearestNode, Global.Nodes[Current Array Element]);
		If(Count Of(Event Player.NearestNode) == 0);
			Event Player.NearestNode = -1;
		Else;
			Event Player.NearestNode = First Of(Sorted Array(Event Player.NearestNode, Distance Between(Global.Nodes[Current Array Element],
				Event Player)));
		End;
	}
}

disabled rule("**EDITING**")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Player Setup")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
	}
}

rule("Add Node")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Global.NewNodeIndex = Index Of Array Value(Global.Nodes, Null);
		If(Global.NewNodeIndex == -1);
			Global.NewNodeIndex = Count Of(Global.Nodes);
		End;
		Global.Nodes[Global.NewNodeIndex] = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 100 * Facing Direction Of(Event Player), Null, Event Player, False);
		Call Subroutine(DrawNode);
	}
}

rule("Destroy All Nodes")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		Global.Nodes = Empty Array;
		Global.Edges = Empty Array;
		Global.EdgeModifyMode = 0;
		Destroy All Effects;
		Destroy All In-World Text;
	}
}

rule("Add Edge")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Call Subroutine(SetNearestNode);
		Abort If(Event Player.NearestNode == -1);
		If(Global.EdgeModifyMode == 1);
			Global.NewEdgeIndex = Index Of Array Value(Global.Edges, Null);
			If(Global.NewEdgeIndex == -1);
				Global.NewEdgeIndex = Count Of(Global.Edges);
			End;
			Global.Edges[Global.NewEdgeIndex] = Vector(Global.EdgeStart, Event Player.NearestNode, Global.OneWay ? 1 : 3);
			Call Subroutine(DrawEdge);
			Global.EdgeModifyMode = 0;
		Else;
			Global.EdgeStart = Event Player.NearestNode;
			Global.EdgeModifyMode = 1;
		End;
	}
}

rule("Destroy Specific Node")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		Global.NodeToDestroy = Mapped Array(Global.Nodes, Current Array Index);
		Global.NodeToDestroy = Filtered Array(Global.NodeToDestroy, Global.Nodes[Current Array Element]);
		Abort If(Count Of(Global.NodeToDestroy) == 0);
		Global.NodeToDestroy = First Of(Sorted Array(Global.NodeToDestroy, Distance Between(Ray Cast Hit Position(Eye Position(
			Event Player), Eye Position(Event Player) + 100 * Facing Direction Of(Event Player), Null, Event Player, False),
			Global.Nodes[Current Array Element])));
		Global.Nodes[Global.NodeToDestroy] = Null;
		Destroy Effect(Global.NodeEffects[Global.NodeToDestroy]);
		Destroy In-World Text(Global.NodeLabels[Global.NodeToDestroy]);
	}
}

rule("Destroy Specific Edge")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		Call Subroutine(SetNearestNode);
		Abort If(Event Player.NearestNode == -1);
		If(Global.EdgeModifyMode == 2);
			Global.EdgesToDestroy = Mapped Array(Global.Edges, Current Array Index);
			Global.EdgesToDestroy = Filtered Array(Global.EdgesToDestroy, Global.Edges[Current Array Element]);
			If(Global.OneWay);
				Global.EdgesToDestroy = Filtered Array(Global.EdgesToDestroy, (X Component Of(Global.Edges[Current Array Element])
					== Global.EdgeStart && Y Component Of(Global.Edges[Current Array Element]) == Event Player.NearestNode && Z Component Of(
					Global.Edges[Current Array Element]) % 2 == 1) || (X Component Of(Global.Edges[Current Array Element])
					== Event Player.NearestNode && Y Component Of(Global.Edges[Current Array Element]) == Global.EdgeStart && Z Component Of(
					Global.Edges[Current Array Element]) > 1));
			Else;
				Global.EdgesToDestroy = Filtered Array(Global.EdgesToDestroy, (X Component Of(Global.Edges[Current Array Element])
					== Global.EdgeStart && Y Component Of(Global.Edges[Current Array Element]) == Event Player.NearestNode) || (X Component Of(
					Global.Edges[Current Array Element]) == Event Player.NearestNode && Y Component Of(Global.Edges[Current Array Element])
					== Global.EdgeStart));
			End;
			While(Count Of(Global.EdgesToDestroy));
				Global.EdgeToDestroy = Global.Edges[First Of(Global.EdgesToDestroy)];
				If(Global.OneWay && Z Component Of(Global.EdgeToDestroy) == 3);
					Global.Edges[First Of(Global.EdgesToDestroy)] = Vector(Global.EdgeStart, Event Player.NearestNode, Y Component Of(
						Global.EdgeToDestroy) == Global.EdgeStart ? 1 : 2);
				Else;
					Global.Edges[First Of(Global.EdgesToDestroy)] = Null;
					Destroy Effect(Global.EdgeEffects[First Of(Global.EdgesToDestroy)]);
					Destroy Effect(Global.EdgeDirectionEffects[First Of(Global.EdgesToDestroy)]);
				End;
				Modify Global Variable(EdgesToDestroy, Remove From Array By Index, 0);
			End;
			Global.EdgeModifyMode = 0;
		Else;
			Global.EdgeStart = Event Player.NearestNode;
			Global.EdgeModifyMode = 2;
		End;
	}
}

rule("Toggle one way mode")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Global.OneWay = !Global.OneWay;
	}
}

disabled rule("**VISUAL EFFECTS**")
{
	event
	{
		Ongoing - Global;
	}
}

rule("Draw Node")
{
	event
	{
		Subroutine;
		DrawNode;
	}

	actions
	{
		Create Effect(All Players(All Teams), Sphere, Color(Yellow), Global.Nodes[Global.NewNodeIndex], 0.700, Visible To);
		Global.NodeEffects[Global.NewNodeIndex] = Last Created Entity;
		Create In-World Text(All Players(All Teams), Global.NewNodeIndex, Global.Nodes[Global.NewNodeIndex] + Up, 3, Do Not Clip,
			Visible To, Color(White), Default Visibility);
		Global.NodeLabels[Global.NewNodeIndex] = Last Text ID;
	}
}

rule("Draw Edge")
{
	event
	{
		Subroutine;
		DrawEdge;
	}

	actions
	{
		Create Beam Effect(Global.Nodes[Evaluate Once(Global.EdgeStart)] && Global.Nodes[Evaluate Once(Event Player.NearestNode)
			] ? All Players(All Teams) : Null, Good Beam, Global.Nodes[Evaluate Once(Global.EdgeStart)], Global.Nodes[Evaluate Once(
			Event Player.NearestNode)], Color(Green), Visible To Position and Radius);
		Global.EdgeEffects[Global.NewEdgeIndex] = Last Created Entity;
		Create Effect(Z Component Of(Global.Edges[Evaluate Once(Global.NewEdgeIndex)]) == 3 ? Null : All Players(All Teams), Sphere, Color(
			Blue), Global.Nodes[Evaluate Once(X Component Of(Global.Edges[Global.NewEdgeIndex]))] * Z Component Of(
			Global.Edges[Evaluate Once(Global.NewEdgeIndex)]) / 3 + Global.Nodes[Evaluate Once(Y Component Of(
			Global.Edges[Global.NewEdgeIndex]))] * (3 - Z Component Of(Global.Edges[Evaluate Once(Global.NewEdgeIndex)])) / 3, 0.500,
			Visible To Position and Radius);
		Global.EdgeDirectionEffects[Global.NewEdgeIndex] = Last Created Entity;
	}
}

rule("Draw Existing Nodes & Edges")
{
	event
	{
		Subroutine;
		DrawExisting;
	}

	actions
	{
		For Global Variable(NewNodeIndex, 0, Count Of(Global.Nodes), 1);
			Call Subroutine(DrawNode);
		End;
		For Global Variable(NewEdgeIndex, 0, Count Of(Global.Edges), 1);
			Global.EdgeStart = X Component Of(Global.Edges[Global.NewEdgeIndex]);
			Event Player.NearestNode = Y Component Of(Global.Edges[Global.NewEdgeIndex]);
			Call Subroutine(DrawEdge);
		End;
	}
}

disabled rule("**PATHFINDING**")
{
	event
	{
		Ongoing - Global;
	}
}

rule("BFS")
{
	event
	{
		Subroutine;
		BFS;
	}

	actions
	{
		Event Player.Path = Empty Array;
		Event Player.Queue = Array(Event Player.PathStart);
		Event Player.VisitedNodes = Array(Vector(Event Player.PathStart, -1, 0));
		While(Count Of(Event Player.Queue));
			Event Player.CurrentNode = First Of(Event Player.Queue);
			Modify Player Variable(Event Player, Queue, Remove From Array By Index, 0);
			If(Event Player.CurrentNode == Event Player.DestinationNode);
				Event Player.Path = Array(Event Player.DestinationNode);
				While(First Of(Event Player.Path) != Event Player.PathStart);
					Event Player.Path = Append To Array(Y Component Of(First Of(Filtered Array(Event Player.VisitedNodes, X Component Of(
						Current Array Element) == First Of(Event Player.Path)))), Event Player.Path);
					Wait(0.016, Ignore Condition);
				End;
				Abort;
			End;
			Event Player.Neighbours = Append To Array(Mapped Array(Filtered Array(Global.Edges, X Component Of(Current Array Element)
				== Event Player.CurrentNode && Z Component Of(Current Array Element) % 2 == 1), Y Component Of(Current Array Element)),
				Mapped Array(Filtered Array(Global.Edges, Y Component Of(Current Array Element) == Event Player.CurrentNode && Z Component Of(
				Current Array Element) > 1), X Component Of(Current Array Element)));
			Modify Player Variable(Event Player, Neighbours, Remove From Array By Value, Mapped Array(Event Player.VisitedNodes,
				X Component Of(Current Array Element)));
			Modify Player Variable(Event Player, Queue, Append To Array, Event Player.Neighbours);
			Modify Player Variable(Event Player, VisitedNodes, Append To Array, Mapped Array(Event Player.Neighbours, Vector(
				Current Array Element, Event Player.CurrentNode, 0)));
			Wait(0.016, Ignore Condition);
		End;
	}
}

rule("Set Destination")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating Any Spray(Event Player) == True;
	}

	actions
	{
		Call Subroutine(SetNearestNode);
		Abort If(Event Player.NearestNode == -1);
		Event Player.DestinationNode = Event Player.NearestNode;
	}
}

rule("Pathfind")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Ready) == True;
	}

	actions
	{
		Call Subroutine(SetNearestNode);
		Abort If(Event Player.NearestNode == -1);
		Event Player.PathStart = Event Player.NearestNode;
		Call Subroutine(BFS);
		Abort If(Count Of(Event Player.Path) == 0);
		Event Player.Path = Mapped Array(Event Player.Path, Global.Nodes[Current Array Element]);
		Start Throttle In Direction(Event Player, Vector Towards(Event Player, First Of(Event Player.Path)), 1, To World,
			Replace existing throttle, Direction and Magnitude);
		While(Count Of(Event Player.Path));
			Wait Until(Distance Between(Event Player, First Of(Event Player.Path)) < 1, 30);
			Modify Player Variable(Event Player, Path, Remove From Array By Index, 0);
		End;
		Stop Throttle In Direction(Event Player);
	}
}