settings
{
	lobby
	{
		Max Team 1 Players: 4
		Max Team 2 Players: 4
	}

	modes
	{
		Team Deathmatch
		{
			disabled maps
			{
				Black Forest Winter
				Blizzard World Winter
				ChÃ¢teau Guillard Halloween
				Ecopoint: Antarctica Winter
				Eichenwalde Halloween
				Hanamura Winter
				Hollywood Halloween
				King's Row Winter
				Lijiang Control Center Lunar New Year
				Lijiang Garden Lunar New Year
				Lijiang Night Market Lunar New Year
				Workshop Chamber
				Workshop Expanse
				Workshop Island
			}
		}
	}
}

rule("Setup")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Set Status(Event Player, Null, Unkillable, 9999);
		Event Player.G = Empty Array;
		Chase Player Variable At Rate(Event Player, T, 0, 1, None);
	}
}

rule("Knock Down")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Health(Event Player) == 1;
	}

	actions
	{
		Abort If(Has Status(Event Player, Knocked Down));
		Event Player.T = 10;
		Set Status(Event Player, Null, Hacked, 0.001);
		Set Status(Event Player, Null, Knocked Down, 9999);
		Create In-World Text(All Players(All Teams), Event Player.T, Position Of(Event Player) + Up, 2, Clip Against Surfaces,
			Visible To Position and String, Color(Red), Default Visibility);
		Event Player.W = Last Text ID;
	}
}

rule("Revive")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) >= 0.300;
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		Clear Status(Event Player, Knocked Down);
	}
}

rule("Tea")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Crouching(Event Player) == True;
		Is True For Any(All Players(Opposite Team Of(Team Of(Event Player))), Has Status(Current Array Element, Knocked Down) && Is Alive(
			Current Array Element) && Distance Between(Event Player, Current Array Element) <= 1.500) == True;
	}

	actions
	{
		Event Player.N = Filtered Array(All Players(Opposite Team Of(Team Of(Event Player))), Has Status(Current Array Element,
			Knocked Down) && Distance Between(Event Player, Current Array Element) <= 1.500);
		Modify Player Variable(Event Player.N, G, Append To Array, Event Player);
	}
}

rule("Oh No")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Event Player.G) > 0;
	}

	actions
	{
		Event Player.O = First Of(Event Player.G);
		Event Player.U = Min(Ultimate Charge Percent(Event Player), Min(100 - Ultimate Charge Percent(Event Player.O), 2.750));
		Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) - Event Player.U);
		Set Ultimate Charge(Event Player.O, Ultimate Charge Percent(Event Player.O) + Event Player.U);
		Event Player.H = Min(Max Health(Event Player) - 0.200 * Event Player.M, Min(100 * Event Player.O.M - Max Health(Event Player.O),
			3));
		Event Player.X = Max Health(Event Player) - Event Player.H;
		Event Player.O.X = Max Health(Event Player.O) + Event Player.H;
		Modify Player Variable(Event Player, G, Remove From Array By Index, 0);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Update Raw Max Health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Hero Of(Event Player) != Event Player.E;
	}

	actions
	{
		Set Max Health(Event Player, 100);
		Wait(0.016, Ignore Condition);
		Event Player.X = 0;
		Event Player.M = Max Health(Event Player);
		Event Player.E = Hero Of(Event Player);
	}
}

rule("Remove Unkillable Status")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.T == 0;
	}

	actions
	{
		Abort If(!Has Status(Event Player, Knocked Down));
		Clear Status(Event Player, Unkillable);
		Event Player.D = True;
	}
}

rule("Emote = Heal")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating Any Emote(Event Player) == True;
		Is True For Any(All Players(Opposite Team Of(Team Of(Event Player))), Has Status(Current Array Element, Knocked Down) && Is Alive(
			Current Array Element) && Distance Between(Event Player, Current Array Element) <= 1.500) == True;
	}

	actions
	{
		Heal(Event Player, Null, 0.250);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Kill")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.D == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Kill(Event Player, Event Player.K);
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
		Set Status(Event Player, Null, Unkillable, 9999);
	}
}

rule("Set Max Health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Round To Integer(Max Health(Event Player), To Nearest) != Event Player.X;
		Has Spawned(Event Player) == True;
		Event Player.X != 0;
		Hero Of(Event Player) == Event Player.E;
	}

	actions
	{
		Event Player.X = Round To Integer(Event Player.X, To Nearest);
		Event Player.A = Health(Event Player);
		Set Max Health(Event Player, 100 * (Event Player.X / Event Player.M));
		Wait(0.016, Ignore Condition);
		Heal(Event Player, Null, Event Player.A - Health(Event Player));
		Damage(Event Player, Null, Health(Event Player) - Event Player.A);
		Loop If Condition Is True;
	}
}

rule("Destroy Text")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Dead(Event Player) || !Has Status(Event Player, Knocked Down)) == True;
		Event Player.W != Null;
	}

	actions
	{
		Destroy In-World Text(Event Player.W);
	}
}

rule("Is Dead")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Event Player.D = False;
		Event Player.K = Null;
	}
}

rule("Last Attacker")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	actions
	{
		Victim.K = Attacker;
	}
}